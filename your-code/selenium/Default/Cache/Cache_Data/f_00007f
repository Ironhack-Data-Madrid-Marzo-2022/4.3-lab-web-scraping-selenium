{"version":3,"sources":["app/assets/modules/github/behaviors/ajax-error.ts","app/assets/modules/github/behaviors/keyboard-shortcuts-helper.ts","app/assets/modules/github/dimensions.ts","app/assets/modules/github/fetch.ts","app/assets/modules/github/form.ts","app/assets/modules/github/html-safe.ts","app/assets/modules/github/scrollto.ts","app/assets/modules/github/navigation.ts","app/assets/modules/github/notifications/v2/notification-list-focus.ts","app/assets/modules/github/parse-html.ts","app/assets/modules/github/remote-submit.ts","app/assets/modules/github/subscription.ts","app/assets/modules/github/visible.ts","app/assets/modules/github/notifications/notification-indicator-element.ts","app/assets/modules/github/notifications/focus_mode/notification-focus-indicator-element.ts","app/assets/modules/github/notifications/focus_mode/notification-focus-filters-element.ts","app/assets/modules/github/notifications/focus_mode/notification-focus-list-element.ts","app/assets/modules/github/notifications/focus_mode/notification-focus-list-item-element.ts","app/assets/modules/github/notifications/focus_mode/notification-focus-sidebar-element.ts","app/assets/modules/github/notifications/notifications-list-subscription-form-element.ts","app/assets/modules/github/notifications/notifications-team-subscription-form-element.ts","app/assets/modules/github/notifications/notifications-subscriptions-dialog-label-item.ts"],"names":[],"mappings":"qOAOO,YAA2B,CAChC,KAAM,GAAmB,SAAS,eAAe,sBAC7C,GACF,GAAiB,OAAS,IAHd,uBAOT,YAA2B,CAChC,KAAM,GAAmB,SAAS,eAAe,sBAC7C,GACF,GAAiB,OAAS,IAHd,uBAOhB,SAAG,sBAAuB,gBAAiB,SAAU,EAAO,CAC1D,KAAM,GAAU,EAAsB,OAChC,CAAC,QAAO,QAAQ,EAElB,EAAM,gBAAkB,EAAM,QAG9B,KAAU,SAAW,IAAU,YAInC,CAAI,QAAQ,KAAK,GACf,KACA,EAAM,4BAEN,WAAW,UAAY,CACjB,EAAM,kBAGV,KACC,OAKP,SAAG,qBAAsB,gBAAiB,UAAY,CACpD,MAIF,SAAG,QAAS,yBAA0B,UAAY,CAChD,O,mECjDK,KAAM,GAAkC,MAAM,CACnD,KAAM,GAA8B,SAAS,cAC3C,4CAEF,MAAI,GACK,EAA4B,UAAY,MAE1C,IAPsC,mCAclC,EAA4B,EAAC,GACjC,sCAAsC,KAAK,IAAY,EAAO,SAAS,QAAU,EAAO,SAAS,SADjE,6BAK5B,EAAoB,EAAC,GAAyB,CACzD,KAAM,GAAS,SAAoB,GACnC,MAAI,KACK,GAEF,EAA0B,IALF,sB,6DCP1B,WAAgB,EAA8B,CACnD,KAAM,GAAO,EAAQ,wBACrB,MAAO,CACL,IAAK,EAAK,IAAM,OAAO,YACvB,KAAM,EAAK,KAAO,OAAO,aAJb,cAYT,WAAwB,EAA4D,CACzF,GAAI,GAAU,EACd,KAAM,GAAW,EAAQ,cAKzB,GAJI,CAAC,GAID,CAAC,EAAQ,aACX,OAKF,KAAM,GAAc,EAAS,YAAY,YAEzC,GAAI,IAAY,EAAS,KAIzB,MAAO,IAAY,EAAS,MAAM,CAChC,GAAI,EAAQ,wBAAyB,GACnC,EAAU,EAAQ,kBAElB,QAGF,KAAM,CAAC,WAAU,YAAW,aAAa,iBAAiB,GAC1D,GACE,IAAa,SACb,IAAc,QACd,IAAc,QACd,IAAc,UACd,IAAc,SAEd,MAIJ,MAAO,aAAmB,UAAW,KAAO,GAtC9B,sBAoET,WACL,EACA,EACwB,CACxB,GAAI,GAAY,EAChB,KAAM,GAAW,EAAQ,cACzB,GAAI,CAAC,EACH,OAGF,KAAM,GAAkB,EAAS,gBAKjC,GAJI,CAAC,GAID,IAAY,EACd,OAGF,KAAM,GAAgB,EAAiB,EAAS,GAChD,GAAI,CAAC,EACH,OAGF,EAAY,EAAc,WAE1B,KAAM,GACJ,IAAc,EAAS,iBAAmB,EAAS,YAC/C,CACE,IAAK,EAAS,YAAY,YAC1B,KAAM,EAAS,YAAY,aAE7B,CACE,IAAK,EAAU,UACf,KAAM,EAAU,YAGlB,EAAM,EAAc,IAAM,EAAO,IACjC,EAAO,EAAc,KAAO,EAAO,KACnC,EAAS,EAAU,aACnB,EAAQ,EAAU,YAClB,EAAS,EAAU,GAAM,EAAQ,cACjC,EAAQ,EAAS,GAAO,EAAQ,aACtC,MAAO,CAAC,MAAK,OAAM,SAAQ,QAAO,SAAQ,SA3C5B,sBA2ET,WACL,EACA,EACsD,CACtD,GAAI,GAAU,EACd,KAAM,GAAW,EAAQ,cACzB,GAAI,CAAC,EACH,OAGF,KAAM,GAAkB,EAAS,gBACjC,GAAI,CAAC,EACH,OAKF,KAAM,GAAc,EAAS,YAAY,YAEzC,GAAI,GAAM,EACN,EAAO,EACX,KAAM,GAAS,EAAQ,aACjB,EAAQ,EAAQ,YAEtB,KAAO,CAAE,KAAY,EAAS,MAAQ,IAAY,IAIhD,GAHA,GAAO,EAAQ,WAAa,EAC5B,GAAQ,EAAQ,YAAc,EAE1B,EAAQ,uBAAwB,GAClC,EAAU,EAAQ,iBAElB,QAIJ,GAAI,GACA,EACA,EAEJ,GACE,CAAC,GACD,IAAc,GACd,IAAc,EAAS,aACvB,IAAc,EAAS,iBACvB,IAAc,EAAS,KAEvB,EAAoB,EACpB,EAAe,EAAkB,EAAS,KAAM,GAChD,EAAc,EAAiB,EAAS,KAAM,WACrC,YAAqB,GAC9B,EAAoB,EACpB,EAAe,EAAU,aACzB,EAAc,EAAU,gBAExB,QAGF,KAAM,GAAS,EAAgB,GAAM,GAC/B,EAAQ,EAAe,GAAO,GACpC,MAAO,CAAC,MAAK,OAAM,SAAQ,QAAO,WAAY,GA3DhC,wBA8DhB,WAA2B,EAA2B,EAAsC,CAC1F,MAAO,MAAK,IACV,EAAa,aACb,EAAgB,aAChB,EAAa,aACb,EAAgB,aAChB,EAAgB,cANX,yBAUT,WAA0B,EAA2B,EAAsC,CACzF,MAAO,MAAK,IACV,EAAa,YACb,EAAgB,YAChB,EAAa,YACb,EAAgB,YAChB,EAAgB,aANX,yB,kEC/OF,iBACL,EACA,EACA,EAC2B,CAC3B,KAAM,GAAU,GAAI,SAAQ,EAAK,GACjC,EAAQ,QAAQ,OAAO,mBAAoB,kBAC3C,KAAM,GAAW,KAAM,MAAK,MAAM,GAClC,GAAI,EAAS,OAAS,KAAO,EAAS,QAAU,IAC9C,KAAM,IAAI,OAAM,QAAQ,EAAS,SAAS,EAAS,YAAc,MAEnE,cAA4B,QAA0B,GAAW,GAC1D,QAAU,EAAU,KAAM,GAAS,QAZtB,iCAef,WAAmB,EAAkB,EAAuB,EAAsB,IAAyB,CAChH,MAAQ,oBAAoB,EAAiC,CAC3D,KAAM,GAAU,GAAI,SAAQ,EAAK,GACjC,EAAQ,QAAQ,OAAO,mBAAoB,kBAC3C,KAAM,GAAW,KAAM,MAAK,MAAM,GAClC,GAAI,EAAS,OAAS,KAAO,EAAS,QAAU,IAC9C,KAAM,IAAI,OAAM,QAAQ,EAAS,SAAS,EAAS,YAAc,MAGnE,GAAI,EAAS,SAAW,IAAK,MAAO,GACpC,GAAI,EAAS,SAAW,IACtB,YAAM,IAAI,SAAQ,GAAW,WAAW,EAAS,IAC1C,EAAK,EAAO,KAErB,KAAM,IAAI,OAAM,cAAc,EAAS,8CAbjC,QAcL,GAfW,kB,oHCVhB,SAAG,QAAS,2BAA4B,eAAgB,EAAO,CAE7D,KAAM,GAAO,EADQ,cACD,KACpB,EAAM,iBACN,GAAI,GACJ,GAAI,CACF,EAAW,KAAM,OAAM,EAAK,OAAQ,CAClC,OAAQ,EAAK,OACb,KAAM,GAAI,UAAS,GACnB,QAAS,CACP,OAAQ,mBACR,mBAAoB,2BAMtB,GAAY,CAAC,EAAS,IACxB,YAIJ,WAAc,EAAqB,EAAc,EAA8B,CAC7E,MAAO,GAAO,cACZ,GAAI,aAAY,EAAM,CACpB,QAAS,GACT,gBAJG,YAgBF,WAAuB,EAAuB,EAAoB,CACnE,GACF,GAAoB,EAAM,GAC1B,QAAyB,IAEvB,EAAK,EAAM,SAAU,KACvB,EAAK,SANO,qBAYhB,WAA6B,EAAuB,EAAmB,CACrE,GAAI,CAAE,aAAgB,kBAAkB,KAAM,IAAI,WAAU,yDAC5D,GAAI,CAAE,aAAqB,cAAc,KAAM,IAAI,WAAU,qDAC7D,GAAI,EAAU,OAAS,SAAU,KAAM,IAAI,WAAU,iDACrD,GAAI,CAAC,GAAQ,IAAS,EAAU,KAAM,KAAM,IAAI,OAAM,2DAJ/C,2BAUF,WAAqB,EAAkB,EAAyB,CACrE,GAAI,MAAO,IAAU,UACnB,GAAI,YAAiB,kBACnB,EAAM,QAAU,MAEhB,MAAM,IAAI,WAAU,mDAEjB,CACL,GAAI,EAAM,OAAS,WACjB,KAAM,IAAI,WAAU,yCAEpB,EAAM,MAAQ,EAGlB,EAAK,EAAO,SAAU,IAdR,mBAkBT,WAAwB,EAAuB,EAAiC,CACrF,SAAW,KAAQ,GAAQ,CACzB,KAAM,GAAQ,EAAO,GACf,EAAU,EAAK,SAAS,UAAU,GAEpC,aAAmB,mBAEZ,YAAmB,uBAC5B,GAAQ,MAAQ,IARN,sBAcT,WAAqB,EAAwB,CAClD,GAAI,CAAE,aAAmB,cACvB,MAAO,GAGT,KAAM,GAAO,EAAQ,SAAS,cACxB,EAAQ,GAAQ,aAAa,SAAW,IAAI,cAClD,MACE,KAAS,UACT,IAAS,YACR,IAAS,SAAW,IAAS,UAAY,IAAS,SACnD,EAAQ,kBAXI,mBAehB,WAAkC,EAAqC,CAErE,MAAO,IAAI,iBAAgB,GAFpB,gCAMF,WAAoC,EAAiB,EAA4B,CACtF,KAAM,GAAkB,GAAI,iBAAgB,EAAW,QACjD,EAAyB,EAAyB,GACxD,SAAW,CAAC,EAAK,IAAU,GACzB,EAAgB,OAAO,EAAK,GAE9B,MAAO,GAAgB,WANT,kCAUT,WAAmB,EAA+B,CACvD,MAAO,GAAyB,GAAI,UAAS,IAAO,WADtC,kB,wCC9HT,WAAmC,EAA8B,CACtE,KAAM,GAAS,CAAC,GAAG,EAAS,iBAAkC,+BAA+B,IAAI,GAAQ,EAAK,SAE9G,GAAI,EAAO,OAAS,EAClB,KAAM,IAAI,OAAM,8CAElB,MAAO,GANO,iCAchB,eAA4B,MAAM,CAGhC,YAAY,EAAiB,EAAoB,CAC/C,MAAM,GAAG,cAAoB,EAAS,UACtC,KAAK,SAAW,GALpB,qBASO,WAAqC,EAAkB,EAAoB,EAAY,GAAO,CACnG,KAAM,GAAc,EAAS,QAAQ,IAAI,iBAAmB,GAC5D,GAAI,CAAC,GAAa,CAAC,EAAY,WAAW,aACxC,KAAM,IAAI,GAAc,6CAA6C,IAAe,GAGtF,GAAI,GAAa,CAAE,GAAY,WAAW,cAAgB,EAAY,WAAW,qBAC/E,KAAM,IAAI,GAAc,iEAAiE,IAAe,GAG1G,KAAM,GAAgB,EAAS,QAAQ,IAAI,eAC3C,GAAK,GACkD,GAC5C,CAAC,EAAO,SAAS,GAC1B,KAAM,IAAI,GAAc,2CAA4C,OAFpE,MAAM,IAAI,GAAc,4BAA6B,GAZzC,oC,+JCvBD,WAAkB,EAA8B,EAA0B,CACvF,GAAI,GAAkB,EACtB,KAAM,GAAW,EAAgB,cAG/B,KAAc,GAGd,IAAc,EAAS,aACvB,IAAc,EAAS,iBACvB,IAAc,EAAS,OAEvB,GAAY,GAGd,KAAM,GAAW,EAAS,YAAa,SAEvC,GAAI,YAAqB,GAAU,CACjC,KAAM,GAAM,EAAQ,KAAO,KAAO,EAAQ,IAAM,EAAS,YAAa,YAChE,EAAO,EAAQ,MAAQ,KAAO,EAAQ,KAAO,EAAS,YAAa,YACzE,EAAS,YAAa,SAAS,EAAM,GACrC,OAGF,KAAM,GAAc,EAAS,YAAa,YAE1C,GAAI,CAAE,aAAqB,IACzB,KAAM,IAAI,OAAM,aAGlB,EAAU,UAAY,EAAQ,IAC1B,EAAQ,MAAQ,MAClB,GAAU,WAAa,EAAQ,MAhCX,gB,eCsGxB,KAAM,GAAe,UAAU,UAAU,MAAM,aACzC,EAAc,EAAe,UAAY,UACzC,EAAiB,EAAe,OAAS,UAE/C,GAAI,GAAqB,GACrB,EAAgB,CAClB,EAAG,EACH,EAAG,GAQL,SAAQ,kEAAmE,CACzE,UAAW,GACT,SAAQ,SAAU,EAAI,YAAa,GAAuB,SAAU,EAAI,YAAa,MAIzF,WAA8B,EAAc,CACpC,YAAiB,aACnB,IAAc,IAAM,EAAM,SAAW,EAAc,IAAM,EAAM,UACjE,GAAqB,IAEvB,EAAgB,CACd,EAAG,EAAM,QACT,EAAG,EAAM,UAPJ,4BAWT,WAA8B,EAAc,CAC1C,GAAI,EACF,OAEF,KAAM,GAAY,EAAM,cAClB,CAAC,UAAU,EACjB,GACE,CAAE,aAAkB,WACpB,CAAE,aAAqB,eACvB,CAAC,EAAU,QAAQ,mCAEnB,OAEF,KAAM,GAAO,EAAO,QAAQ,uBACxB,GAAM,EAAU,EAAM,GAdnB,4BAiBT,GAAI,GAAQ,EACZ,SAAQ,kCAAmC,CACzC,KAAM,CACJ,IACI,IAAU,GAAG,SAAS,iBAAiB,UAAW,IAExD,QAAS,CACP,IACI,IAAU,GAAG,SAAS,oBAAoB,UAAW,MAO7D,WAA2B,EAAsB,CAC/C,GACE,EAAM,SAAW,SAAS,MAC1B,EAAM,iBAAkB,cACxB,CAAC,EAAM,OAAO,UAAU,SAAS,wBAEjC,OAGF,EAAqB,GAErB,KAAM,GAAY,IAClB,GAAI,GAAa,GAEjB,GAAI,EAAW,CACb,KAAM,GAAS,EAAU,cAAc,yCAA2C,EAClF,EAAa,QAAK,EAAQ,qBAAsB,CAC9C,OAAQ,SAAoB,GAC5B,cAAe,EACf,eAAgB,EAAM,SAIrB,GACH,EAAM,iBAxBD,yBA4BT,SAAG,qBAAsB,kCAAmC,SAAU,EAAO,CAC3E,KAAM,GAAY,EAAM,cAClB,EAAU,EAAM,OAAO,eAAe,QAAQ,mBAC9C,EAAO,EAAM,OAEnB,GAAI,EAAC,SAAkB,EAAM,OAAO,eAEpC,IAAI,EAAK,UAAU,SAAS,sBAC1B,GAAI,EAAS,CACX,GAAI,EACF,OAAQ,SAAoB,EAAM,OAAO,oBAClC,YACH,EAAW,EAAM,GACjB,UACG,YACH,EAAS,EAAM,GAGrB,OAAQ,SAAoB,EAAM,OAAO,oBAClC,UACH,EAAS,EAAM,GACf,UACG,YACH,EAAW,EAAM,GACjB,UACG,YACA,GAAG,UACN,EAAQ,EAAM,EAAM,OAAO,cAAc,IACzC,WAEC,CACL,GAAI,EACF,OAAQ,SAAoB,EAAM,OAAO,oBAClC,YACH,EAAW,EAAM,GACjB,UACG,YACH,EAAS,EAAM,GACf,UACG,QACH,GAAO,EAAM,GACb,UACG,YACH,EAAS,EAAM,GAGrB,OAAQ,SAAoB,EAAM,OAAO,oBAClC,QACA,IACH,EAAW,EAAM,GACjB,UACG,QACA,IACH,EAAS,EAAM,GACf,UACG,QACA,YACA,GAAG,UACN,EAAQ,EAAM,EAAM,OAAO,IAC3B,WAGD,CACL,KAAM,GAAY,EAAS,GAAW,GACtC,GAAI,EACF,GAAI,EAAS,CACX,GAAI,EACF,OAAQ,SAAoB,EAAM,OAAO,oBAClC,YACH,EAAU,EAAW,GAG3B,OAAQ,SAAoB,EAAM,OAAO,oBAClC,YACH,EAAU,EAAW,QAEpB,CACL,GAAI,EACF,OAAQ,SAAoB,EAAM,OAAO,oBAClC,gBACA,YACH,EAAU,EAAW,GAG3B,OAAQ,SAAoB,EAAM,OAAO,oBAClC,IACH,EAAU,EAAW,KAM/B,GAAI,EAAS,CACX,GAAI,EACF,OAAQ,SAAoB,EAAM,OAAO,oBAClC,gBACA,YACH,EAAM,iBAGZ,OAAQ,SAAoB,EAAM,OAAO,oBAClC,cACA,YACH,EAAM,iBACN,UACG,QACH,EAAM,sBAEL,CACL,GAAI,EACF,OAAQ,SAAoB,EAAM,OAAO,oBAClC,gBACA,gBACA,gBACA,QACH,EAAM,iBAGZ,OAAQ,SAAoB,EAAM,OAAO,oBAClC,QACA,QACA,IACH,EAAM,iBACN,UACG,YACA,GAAG,UACN,EAAM,sBAYd,WACE,EACA,CAGA,KAAM,GAAW,EAAM,aAAe,EAAM,QAAU,EAAM,SAAW,EAAM,QAOxE,GANc,KAAK,EAAM,cAA0B,kBAAmB,CACzE,YAAa,EACb,SAAU,EAAM,YAKhB,EAAM,iBAbD,gBAkBT,SAAG,QAAS,sDAAuD,SAAU,EAAO,CAClF,EAAS,KAIX,SAAG,qBAAsB,sDAAuD,SAAU,EAAO,CAC/F,KAAM,GAAI,EAAM,cAAc,UAAU,SAAS,sBAC7C,EAAM,cACN,EAAM,cAAc,cAAc,uBAClC,YAAa,mBACf,CAAI,EAAM,OAAO,YACf,QAAO,KAAK,EAAE,KAAM,UACpB,OAAO,SAQH,EANc,cAChB,GAAI,YAAW,QAAS,CACtB,QAAS,GACT,WAAY,OAId,EAAE,QAGN,EAAM,kBAEN,EAAS,KAKN,WAAkB,EAA2B,CAClD,KAAM,GAAkB,IACpB,IAAc,GACZ,KAAoB,MAAM,EAAW,GACzC,WAAW,UAAU,IAAI,mCAJb,gBAST,WAAoB,EAAoB,CAC7C,EAAU,UAAU,OAAO,kCADb,kBAIhB,KAAM,GAA4B,GAG3B,WAAc,EAAwB,CAC3C,KAAM,GAAkB,IACpB,GACF,EAAe,KAAK,GAEtB,EAAS,GALK,YAST,YAAa,EAAoB,CACtC,EAAW,GACX,EAAM,GAEN,KAAM,GAAkB,EAAe,MACnC,GACF,EAAS,GANG,YAWT,WAAe,EAAwB,EAA6B,CACzE,KAAM,GAAS,GAAiB,EAE1B,EAAY,EAAS,GAAW,GAChC,EAAO,EAAO,QAAQ,wBAA0B,EAItD,GAFA,EAAS,GAEL,YAAgB,aAAa,CAE/B,GADuB,EAAU,EAAM,GAErC,OAEF,KAAM,GAAS,SAAe,GAC9B,EAAa,EAAS,IAdV,wBAmBT,WAAe,EAAoB,CACxC,KAAM,GAAW,EAAU,iBAAiB,wCAC5C,SAAW,KAAW,GACpB,EAAQ,UAAU,OAAO,oBAHb,aAQT,WAAiB,EAAwB,EAAsB,CACpE,EAAM,GACN,EAAM,EAAW,GAFH,eAMhB,WAAkB,EAAmB,EAAwB,CAC3D,KAAM,GAAQ,EAAS,GACjB,EAAQ,EAAM,QAAQ,GACtB,EAAW,EAAM,EAAQ,GAC/B,GAAI,EAAU,CAEZ,GADuB,EAAU,EAAU,GAEzC,OAGF,KAAM,GAAmB,SAAe,GACpC,EAAe,KAAe,OAChC,EAAa,EAAmB,GAEhC,EAAa,EAAmB,IAd7B,gBAoBT,WAAoB,EAAmB,EAAwB,CAC7D,KAAM,GAAQ,EAAS,GACjB,EAAQ,EAAM,QAAQ,GACtB,EAAO,EAAM,EAAQ,GAE3B,GAAI,EAAM,CAER,GADuB,EAAU,EAAM,GAErC,OAGF,KAAM,GAAmB,SAAe,GACpC,EAAe,KAAe,OAChC,EAAa,EAAmB,GAEhC,EAAa,EAAmB,IAf7B,kBAqBT,YAAgB,EAAmB,EAAwB,CACzD,KAAM,GAAQ,EAAS,GACvB,GAAI,GAAQ,EAAM,QAAQ,GAC1B,KAAM,GAAmB,SAAe,GAExC,GAAI,GAAoB,KACtB,OAGF,GAAI,GACA,EACJ,KACG,GAAW,EAAM,EAAQ,KACzB,GAAY,SAAe,EAAU,KACtC,EAAU,KAAO,GAEjB,IAGF,GAAI,EAAU,CAEZ,GADuB,EAAU,EAAU,GAEzC,OAGF,EAAa,EAAkB,IAzB1B,eA8BT,WAAkB,EAAmB,EAAwB,CAC3D,KAAM,GAAQ,EAAS,GACvB,GAAI,GAAQ,EAAM,QAAQ,GAC1B,KAAM,GAAmB,SAAe,GAExC,GAAI,GAAoB,KACtB,OAGF,GAAI,GACA,EACJ,KAAQ,GAAO,EAAM,EAAQ,KAAQ,GAAY,SAAe,EAAM,KAAsB,EAAU,QAAU,GAC9G,IAGF,GAAI,EAAM,CAER,GADuB,EAAU,EAAM,GAErC,OAEF,EAAa,EAAkB,IApB1B,gBA2BT,WAAiB,EAAe,EAAW,GAAO,CAChD,QAAK,EAAM,qBAAsB,CAC/B,YAAa,IAFR,eAMT,WAAmB,EAAiB,EAA6B,CAC/D,MAAI,QAAK,EAAQ,oBACf,GAAM,GACN,EAAO,UAAU,IAAI,oBAEd,IAEA,GAPF,iBAWT,YAA8B,CAC5B,MAAO,UAAS,cAAc,mCADvB,0BAIT,WAAkB,EAAmC,CACnD,KAAM,GAAQ,GACd,SAAW,KAAW,GAAU,iBAAiB,uBAC3C,YAAmB,cAAe,QAAQ,IAC5C,EAAM,KAAK,GAIf,MAAO,GARA,gBAWT,WAAwB,EAAgC,CACtD,MAAO,GAAU,aAAa,2BAA6B,OADpD,sBAIT,WAAsB,EAAwB,EAAsB,EAA2B,SAAU,CACvG,KAAM,GAAW,SAAe,EAAS,GACrC,CAAC,GAEL,CAAI,EAAS,QAAU,EACrB,EAAQ,eAAe,CAAC,WAAU,MAAO,UAChC,EAAS,KAAO,GACzB,EAAQ,eAAe,CAAC,WAAU,MAAO,SAPpC,oBAWT,WAAsB,EAAwB,EAAsB,CAClE,KAAM,GAAW,SAAiB,EAAS,GACrC,EAAW,SAAe,EAAS,GAEzC,GAAI,KAAY,MAAQ,GAAY,MAIpC,GAAI,EAAS,QAAU,GAAK,SAAS,KAAM,CAEzC,KAAM,GAAY,GADa,cAAgB,KAAO,EAAU,aAAe,SAAS,KAAK,cAC3D,GAAS,OAAS,EAAS,QAC7D,EAAS,EAAW,CAClB,IAAK,QAEE,GAAS,KAAO,GACzB,EAAS,EAAW,CAClB,IAAK,EAAS,MAhBX,qB,mECtkBF,WAAyB,EAAiC,EAAiD,CAChH,KAAM,GAAY,GAAqB,IACvC,GAAI,CAAC,EAAW,MAAO,GAEvB,KAAM,GAAkB,EAAU,cAChC,GAA2B,gDAE7B,MAAM,aAA2B,aAE1B,CACL,GAAI,EAAgB,aAAa,wBACjC,SAAU,EAAS,GAAW,QAAQ,IAJc,GAPxC,uBA8BT,WAAsB,CAAC,KAAI,YAA0B,EAAiC,CAC3F,KAAM,GAAY,GAAqB,IACvC,GAAI,CAAE,aAAqB,cAAc,OAEzC,KAAM,GAAQ,EAAS,GACvB,GAAI,GAGA,GACF,GAAS,EAAM,KAAK,GAAM,EAAG,aAAa,0BAA4B,IAKpE,CAAC,GAAU,GAAY,MACzB,GAAS,EAAM,KAAK,IAAI,EAAU,EAAM,OAAS,KAG/C,YAAkB,cACpB,SAAgB,EAAW,GAnBf,oBAuBhB,YAAgC,CAC9B,MAAO,UAAS,cAAc,mDADvB,4BAKT,WAAkB,EAA+B,CAC/C,MAAO,OAAM,KAAK,EAAU,iBAA8B,wBAAwB,OAAO,KADlF,iB,iCC5EF,WAAmB,EAAoB,EAAgC,CAC5E,KAAM,GAAW,EAAS,cAAc,YACxC,SAAS,UAAY,EACd,EAAS,WAAW,EAAS,QAAS,IAH/B,kB,yCCqBT,WAAkC,EAA8C,CACrF,KAAM,GAAO,EAAO,QAAQ,QAC5B,GAAI,CAAE,aAAgB,kBACpB,OAGF,GAAI,GAAQ,EAA+B,GAE3C,GAAI,EAAO,KAAM,CACf,KAAM,GAAe,EAAO,QAAQ,sBAAwB,SAAW,GACjE,EAAQ,EAAO,OAAS,EACzB,GACH,GAAQ,SAAS,cAAc,SAC/B,EAAM,KAAO,SACb,EAAM,UAAU,IAAI,0BACpB,EAAK,QAAQ,IAEf,EAAM,KAAO,EAAO,KACpB,EAAM,MAAQ,MACL,IACT,EAAM,SApBM,gCAwBT,WAAwC,EAAgD,CAC7F,KAAM,GAAQ,EAAK,cAAc,gCACjC,MAAO,aAAiB,kBAAmB,EAAQ,KAFrC,uC,oDCzCT,OAAmB,CACxB,YAAY,EAAqB,CAC/B,KAAK,OAAS,GACd,KAAK,YAAc,IAAM,CACvB,IACA,KAAK,OAAS,KALb,oBAgBA,WACL,EACA,EACA,EACA,EAAmC,CAAC,QAAS,IAC/B,CACd,SAAO,iBAAiB,EAAW,EAAQ,GACpC,GAAI,GAAa,IAAM,CAC5B,EAAO,oBAAoB,EAAW,EAAQ,KARlC,iBAiBT,cAAoB,EAA6C,CACtE,MAAO,IAAI,GAAa,IAAM,CAC5B,SAAW,KAAgB,GACzB,EAAa,gBAHH,gB,iCCvBhB,WAAgB,EAA+B,CAC7C,MAAO,GAAQ,aAAe,GAAK,EAAQ,cAAgB,EADpD,cAIM,WAAiB,EAA+B,CAC7D,MAAO,CAAC,EAAO,GADO,gB,gPCfxB,qBAA2C,YAAY,CAKrD,aAAc,CACZ,QACA,KAAK,iBAAiB,iBAAkB,KAAK,OAAO,KAAK,OAG3D,OAAO,EAAc,CACnB,KAAM,GAAQ,EAAsB,OAAO,KAC3C,KAAK,KAAK,aAAa,aAAc,EAAK,YAC1C,KAAK,KAAK,aAAa,gBAAiB,EAAK,UAC7C,KAAK,SAAS,aAAa,QAAS,EAAK,cAd7C,gCACU,GAAP,MAAO,sBACA,GAAP,MAAO,0BAFV,KADC,MACD,G,wPCAA,qBAAgD,YAAY,CAI1D,mBAAoB,CAClB,KAAK,iBAAiB,iBAAkB,GAAS,CAC/C,KAAM,GAAQ,EAAsB,OAAO,KAC3C,KAAK,KAAK,aAAa,aAAc,EAAK,YAC1C,KAAK,KAAK,aAAa,gBAAiB,EAAK,UAC7C,KAAK,SAAS,aAAa,QAAS,EAAK,cAI7C,eAAsB,CACpB,KAAM,GAAQ,GAAI,aAAY,oCAAqC,CAAC,QAAS,KAC7E,KAAK,cAAc,KAfvB,qCACU,GAAP,MAAO,sBACA,GAAP,MAAO,0BAFV,KADC,MACD,G,sPCAO,qBAA8C,YAAY,CAI/D,aAAa,EAAU,CACrB,EAAE,iBACF,KAAK,iBAAiB,gBAAgB,QACtC,KAAM,GAAO,EAAE,cAEf,KAAK,eAAe,EAAK,WAEzB,KAAK,cACH,GAAI,aAAY,2BAA4B,CAC1C,OAAQ,CAAC,IAAK,EAAK,SAKjB,eAAe,EAAc,CACnC,KAAK,YAAY,UAAY,IAnB1B,mCACG,GAAP,MAAO,kCACA,GAAP,MAAO,6BAFH,KADN,MACM,G,0SCSA,qBAA2C,YAAY,CAc5D,mBAAoB,CAClB,SAAQ,8BAA+B,IAAM,CAC3C,KAAK,4BAMP,SAAG,WAAY,0BAA2B,IAAM,CAC9C,KAAK,qCAIT,sBAAuB,CACrB,KAAK,4BAGP,sBAAuB,CACrB,SAAI,KAAK,WAGX,oBAAqB,CACnB,SAAK,KAAK,WAGZ,eAAe,EAAgC,CAC7C,KAAK,UAAU,UAAY,GAC3B,KAAK,UAAU,YAAY,GAC3B,KAAK,0BAIP,aAAa,EAAsB,CA1DrC,UA2DI,KAAM,GAAiB,EAAE,OAAO,eAC1B,EAAe,QAAgB,KAAK,UAAW,wCAErD,cAAK,eAAL,cACI,KAAK,GAAQ,EAAK,iBAAmB,KADzC,cAEI,QAAQ,QAFZ,QAGI,SAEA,KAAK,aAAa,SAAW,EAC/B,MAAK,WAAW,OAAS,GACzB,KAAK,KAAK,OAAS,IAEnB,QAAa,EAAc,KAAK,WAI5B,kCAAmC,CACzC,SAAW,KAAY,MAAK,aAAc,CACxC,KAAM,GAAY,OAAO,SAAS,KAAK,SAAS,EAAS,OACzD,EAAS,gBAAgB,IAIrB,yBAA0B,CAC5B,CAAC,CAAC,OAAO,sBAAwB,KAAK,cACxC,MAAK,gBAAkB,GAAI,sBACxB,GAAyC,CACpC,CAAC,EAAQ,GAAG,gBAIhB,MAAK,4BACL,KAAK,iBAEP,CACE,KAAM,KAAK,UACX,UAAW,IAGf,KAAK,gBAAgB,QAAQ,KAAK,oBAIxB,eAAe,CAC3B,GAAI,CAAC,KAAK,aACR,OAGF,KAAM,GAAc,KAAK,aAAa,aAAa,sBACnD,GAAI,EAAa,CACf,KAAK,oBAAoB,OAAS,GAClC,KAAM,GAAW,KAAM,QAA0B,SAAU,GAE3D,KAAK,aAAa,SAElB,KAAM,GAAsB,EAAS,iBAAiB,mCACtD,SAAW,KAAQ,GACjB,KAAK,KAAK,YAAY,GAGxB,KAAM,GAAuB,EAAS,cAAc,sCAChD,GACF,KAAK,KAAK,YAAY,GAKxB,KAAK,2BAID,2BAA4B,CAC9B,KAAK,iBACP,KAAK,gBAAgB,eAxHpB,gCACG,GAAP,MAAO,2BAEA,GAAP,MAAO,iCACA,GAAP,MAAO,sBACA,GAAP,MAAO,4BAEC,GAAR,MAAQ,8BAED,GAAP,MAAO,8BACA,GAAP,MAAO,qCAVH,KADN,MACM,G,oQCTA,qBAA+C,YAAY,CAA3D,aAHP,CAGO,oBACC,oBAAiB,GACjB,cAAW,GAOjB,mBAAoB,CAZtB,QAaI,QAAK,QAAQ,yBAAb,QAAqC,iBAAiB,qBAAsB,KAAK,wBAAwB,KAAK,OAC9G,QAAK,QAAQ,yBAAb,QAAqC,iBAAiB,qBAAsB,KAAK,cAAc,KAAK,OAGtG,KAAM,CAjBR,MAkBI,MAAO,QAAK,mBAAL,cAAuB,KAGhC,wBAAwB,EAAc,CACpC,KAAM,GAAU,EAAsB,OAClC,CAAC,UAAkB,EAAO,gBAE9B,CAAI,EAAO,SAAW,IACpB,KAAK,SAAS,cAAc,GAAI,OAAM,WAC7B,EAAO,SAAW,KAC3B,KAAK,gBAAgB,cAAc,GAAI,OAAM,YAIjD,eAAgB,CACd,KAAK,iBAAiB,cACpB,GAAI,YAAW,QAAS,CACtB,QAAS,GACT,WAAY,MAKlB,gBAAgB,EAAkB,CAzCpC,UA2CQ,GAAW,KAAK,UAClB,MAAK,SAAW,GAChB,QAAK,QAAQ,yBAAb,QAAqC,UAAU,OAAO,oBACtD,QAAK,QAAQ,yBAAb,QAAqC,UAAU,IAAI,oBAGrD,QAAK,QAAQ,yBAAb,QAAqC,UAAU,OAAO,uBAAwB,GAC9E,KAAK,kBAAkB,UAAU,OAAO,YAAa,GAAW,KAAK,eAGjE,iBAAgB,EAAyB,CAC7C,EAAE,iBAEF,KAAM,GAAO,EAAE,cACT,EAAO,GAAI,UAAS,GACpB,EAAS,EAAK,OACd,EAAM,EAAK,OACX,CAAC,MAAM,KAAM,OAAM,EAAK,CAAC,OAAM,WAEjC,GACF,KAAK,cACH,GAAI,aAAY,yBAA0B,CACxC,QAAS,GACT,OAAQ,CAAC,eAAgB,KAAK,qBA/DjC,oCACC,GAAL,MAAK,gCACA,GAAL,MAAK,0BAEE,GAAP,MAAO,0BACA,GAAP,MAAO,iCACA,GAAP,MAAO,kCACA,GAAP,MAAO,mCAPH,KADN,MACM,G,wPCGP,qBAA8C,YAAY,CAKxD,mBAAoB,CAClB,KAAK,iBAAiB,oCAAqC,KAAK,cAAc,KAAK,MAAO,IAGtF,OADoB,aAAa,QAAQ,0BAA4B,QAEvE,KAAK,gBAIT,eAAsB,CACpB,KAAK,wBAED,KAAK,QAAQ,UAAU,SAAS,UAClC,MAAK,YAAY,uBACjB,KAAK,QAAQ,UAAU,OAAO,UAC9B,OAAO,aAAa,WAAW,yBAE/B,MAAK,YAAY,qBACjB,KAAK,QAAQ,UAAU,IAAI,UAC3B,OAAO,aAAa,QAAQ,uBAAwB,cAKlD,qBAAoB,EAAU,CAClC,KAAM,GAAU,EAAkB,OAClC,GAAI,EAAO,IAAK,CACd,KAAK,YAAY,uBACjB,KAAM,GAAO,KAAM,QAA0B,SAAU,EAAO,KAC9D,KAAK,YAAY,eAAe,GAChC,KAAK,YAAY,sBAIb,uBAAwB,CAC9B,KAAM,GAAS,SAAS,cAAc,uBACtC,GAAI,EAAQ,CACV,KAAM,GAAY,EAAO,UAAY,EAAO,aAC5C,KAAK,QAAQ,MAAM,IAAM,GAAG,EAAY,UA3C9C,mCACU,GAAP,MAAO,yBACA,GAAP,MAAO,6BACA,GAAP,MAAO,gCAHV,KADC,MACD,G,sRCKA,qBAAuD,YAAY,CAAnE,aAXA,CAWA,oBAmBE,uBAA+C,GAE/C,mBAAoB,CAElB,KAAM,GAAK,KAAK,cAA2B,gCAE3C,WAAI,iBAAiB,UAAW,IAAM,CAChC,KAAK,oBAAoB,OAAS,GACpC,MAAK,mBAAmB,UACxB,KAAK,qBAAqB,kBAK1B,kBAAiB,EAAU,CAC/B,KAAM,MAAK,WAAW,GACtB,KAAK,iBAGD,YAAW,EAAU,CACzB,EAAE,iBAEF,UAEA,KAAM,GAAO,EAAE,cACT,EAAO,GAAI,UAAS,GAEpB,EAAW,KAAM,MAAK,MAAM,EAAK,OAAQ,CAC7C,OAAQ,EAAK,OACb,OACA,QAAS,CACP,mBAAoB,iBACpB,OAAQ,sBAIZ,GAAI,CAAC,EAAS,GAAI,CAChB,UACA,OAEF,KAAM,GAAO,KAAM,GAAS,OAEtB,EAAU,EAAK,IAAI,MACrB,MAAO,IAAY,UAAU,KAAK,mBAAmB,GACrD,MAAO,IAAY,UAAU,KAAK,qBAAqB,GAC3D,KAAK,kBAAkB,EAAK,OAC5B,KAAK,2DAGP,qBAAqB,EAAsB,CACzC,KAAK,kBAAkB,OAAS,CAAE,KAAiB,cAAgB,IAAiB,UACpF,KAAK,uBAAuB,OAAW,IAAiB,SACxD,KAAK,gBAAgB,OAAS,CAC5B,KAAiB,cACjB,IAAiB,UACjB,IAAiB,UAQrB,0DAA2D,CACzD,SAAW,KAAS,CAAC,GAAG,KAAK,sBAC3B,EAAM,gBAAgB,UAAW,EAAM,SAI3C,mBAAmB,EAAiB,CAClC,SAAW,KAAU,MAAK,oBACxB,EAAO,aAAa,eAAgB,EAAO,QAAU,EAAU,OAAS,SAG1E,GAAI,IAAY,SACd,KAAK,aAAa,aAAa,eAAgB,YAC1C,CACL,KAAK,aAAa,aAAa,eAAgB,SAE/C,SAAW,KAAS,CAAC,GAAG,KAAK,sBAC3B,SAAY,EAAO,IAGrB,GAAI,KAAK,yBAA2B,OAAW,CAC7C,OAAS,GAAI,EAAG,EAAI,KAAK,oBAAoB,OAAQ,IACnD,KAAK,oBAAoB,GAAG,SAG1B,KAAK,wBAA0B,QACjC,KAAK,sBAAsB,gBAAgB,SAAU,IAGvD,KAAK,uBAAuB,UAAY,KAK9C,kBAAkB,EAAe,CAC3B,KAAK,aACP,MAAK,YAAY,YAAc,EAC/B,KAAK,YAAY,aAAa,aAAc,GAAG,KAAK,eAAe,gCAIvE,eAAe,EAAmB,CAChC,MAAO,UAAS,KAAe,EAAI,YAAc,GAAG,cAGtD,wBAAwB,EAAsD,CAG5E,KAAM,GAAa,EAAE,OAAO,WACtB,EAAU,EAAE,OAAO,eACnB,EAA4B,EAAE,OAAO,0BAG3C,GAAI,GAEF,OAAS,GAAI,EAAG,EAAI,KAAK,oBAAoB,OAAQ,IACnD,GAAI,KAAK,oBAAoB,GAAG,aAAa,mBAAqB,EAAS,CACzE,KAAK,oBAAoB,GAAG,SAC5B,WAIJ,GAA0B,gBAAgB,UAC1C,EAA0B,aAAa,eAAgB,4DAEvD,KAAK,uBAAuB,YAAY,GAI5C,iBAAiB,EAAU,CACzB,EAAE,iBACF,EAAE,kBACF,KAAK,KAAK,gBAAgB,SAAU,IACpC,KAAK,+BACL,KAAK,yBACL,KAAK,aAAa,gBAAgB,SAAU,IAC5C,WAAW,IAAM,CAzKrB,MA0KM,QAAK,aAAa,cAAgC,qCAAlD,QAAsF,SACrF,GAGL,8BAA+B,CAGzB,KAFuB,aAAa,iBAA8B,qCAEpD,OAAS,GACzB,MAAK,aAAa,gBAAgB,YAClC,KAAK,qBAAqB,GAAG,QAAU,IAI3C,kBAAkB,EAAU,CAC1B,EAAE,iBACF,EAAE,kBACF,KAAK,KAAK,gBAAgB,SAAU,IACpC,KAAK,aAAa,gBAAgB,SAAU,IAC5C,WAAW,IAAM,CACf,KAAK,aAAa,SACjB,GAIL,wBAAwB,EAAU,CAChC,EAAE,iBACF,EAAE,kBAGF,OAAS,GAAM,EAAG,EAAM,KAAK,oBAAoB,OAAQ,IAAO,CAC9D,KAAM,GAAU,KAAK,oBAAoB,GAAK,aAAa,iBAG3D,OAAS,GAAI,EAAG,EAAI,KAAK,iBAAiB,OAAQ,IAChD,GAAI,KAAK,iBAAiB,GAAG,UAAY,EAAS,CAChD,KAAK,iBAAiB,GAAG,2BAA2B,IACpD,OAMN,OAAS,GAAM,EAAG,EAAM,OAAO,KAAK,KAAK,mBAAmB,OAAQ,IAAO,CACzE,KAAM,GAAU,OAAO,KAAK,KAAK,mBAAmB,GAGpD,OAAS,GAAI,EAAG,EAAI,KAAK,iBAAiB,OAAQ,IAChD,GAAI,KAAK,iBAAiB,GAAG,UAAY,EAAS,CAChD,KAAK,iBAAiB,GAAG,2BAA2B,IACpD,OAKN,KAAK,uBAAuB,gBAAgB,GAAG,OAAO,OAAO,KAAK,oBAClE,KAAK,wBAAwB,GAG/B,uBAAuB,EAAU,CAC/B,EAAE,iBACF,EAAE,kBAEF,KAAK,yBACL,KAAK,aAAa,gBAAgB,SAAU,IAC5C,KAAK,mBAAmB,gBAAgB,SAAU,IAClD,WAAW,IAAM,CA3OrB,MA4OM,QAAK,mBAAmB,cAAgC,qCAAxD,QAA4F,SAC3F,GAGL,wBAAwB,EAAU,CAChC,EAAE,iBACF,EAAE,kBAEF,KAAK,KAAK,gBAAgB,SAAU,IACpC,KAAK,aAAa,gBAAgB,SAAU,IAC5C,KAAK,mBAAmB,gBAAgB,SAAU,IAIpD,wBAAwB,EAAU,CAChC,EAAE,iBACF,EAAE,kBAEF,KAAK,yBAEL,KAAK,qBACL,KAAK,uBACL,KAAK,wBAAwB,GAG/B,sBAAuB,CACrB,KAAM,GAAiB,OAAO,KAAK,KAAK,mBAAmB,OAAS,EAEhE,GAAkB,KAAK,qBAAqB,OAAS,GACvD,MAAK,qBAAqB,GAAG,QAAU,GAGzC,KAAK,8BAGP,oBAAqB,CACnB,KAAM,GAAe,OAAO,KAAK,KAAK,mBAAmB,OAAS,EAClE,KAAK,sBAAsB,gBAAgB,SAAU,GAIvD,wBAAyB,CACvB,KAAK,kBAAoB,GACzB,KAAK,YAAY,UAAY,GAE7B,OAAS,GAAI,EAAG,EAAI,KAAK,oBAAoB,OAAQ,IAAK,CACxD,KAAM,GAAU,KAAK,oBAAoB,GAAG,aAAa,iBACrD,GACF,MAAK,kBAAkB,GAAW,KAAK,oBAAoB,GAAG,UAAU,IACxE,KAAK,uBAAuB,KAKlC,uBAAuB,EAAe,CAEpC,KAAM,GAAQ,SAAS,cAAc,SACrC,EAAM,aAAa,OAAQ,UAC3B,EAAM,aAAa,OAAQ,YAC3B,EAAM,aAAa,QAAS,GAE5B,KAAK,YAAY,YAAY,GAG/B,gBAAiB,CACf,KAAK,KAAK,gBAAgB,SAAU,IACpC,KAAK,aAAa,gBAAgB,SAAU,IAG9C,aAAa,EAAU,CACrB,EAAE,iBACF,KAAK,QAAQ,gBAAgB,OAAQ,IAGvC,6BAA8B,CAC5B,KAAM,GAAe,CAAC,KAAK,qBAAqB,KAAK,GAAS,EAAM,SAEpE,KAAK,aAAa,SAAW,EAG/B,WAAY,CACV,KAAK,QAAQ,gBAAgB,OAAQ,MAlTzC,4CACU,GAAP,MAAO,yBACA,GAAP,MAAO,sBACA,GAAP,MAAO,8BACA,GAAP,MAAO,8BACA,GAAP,MAAO,oCACC,GAAR,MAAQ,qCACA,GAAR,MAAQ,qCACD,GAAP,MAAO,6BACA,GAAP,MAAO,uCACA,GAAP,MAAO,6BACA,GAAP,MAAO,mCACA,GAAP,MAAO,wCACA,GAAP,MAAO,iCACC,GAAR,MAAQ,sCACD,GAAP,MAAO,8BACA,GAAP,MAAO,wCACC,GAAR,MAAQ,kCAjBX,KADC,MACD,G,gQCTA,qBAAuD,YAAY,CAGjE,WAAY,CACV,KAAK,QAAQ,gBAAgB,OAAQ,MAJzC,4CACU,GAAP,MAAO,yBADV,KADC,MACD,G,iQCOO,qBAAkD,YAAY,CAOnE,oBAAoB,EAAU,CAI5B,GAHA,EAAE,iBACF,EAAE,kBAEE,KAAK,MAAO,CAEd,KAAM,GAAa,KAAK,MAAM,aAAa,kBAAoB,OAE/D,KAAK,2BAA2B,CAAC,GAEjC,KAAK,cACH,GAAI,aAAkD,qCAAsC,CAC1F,OAAQ,CACN,aACA,eAAgB,KAAK,QACrB,0BAA2B,KAAK,oBAAoB,UAAU,KAEhE,QAAS,OAMjB,2BAA2B,EAAkB,CAC3C,KAAK,MAAM,aAAa,eAAgB,EAAQ,cA/B7C,uCACG,GAAP,MAAO,uBACA,GAAP,MAAO,qCACA,GAAP,MAAO,qCAEF,GAAL,MAAK,yBALD,KADN,MACM,K","file":"notifications-global-xxxxxxxxxxxx.js","sourcesContent":["// Global handler for uncaught AJAX errors.\n//\n// Only enabled by default on new style `data-remote` requests.\n\n// eslint-disable-next-line no-restricted-imports\nimport {on} from 'delegated-events'\n\nexport function showGlobalError() {\n  const ajaxErrorMessage = document.getElementById('ajax-error-message')\n  if (ajaxErrorMessage) {\n    ajaxErrorMessage.hidden = false\n  }\n}\n\nexport function hideGlobalError() {\n  const ajaxErrorMessage = document.getElementById('ajax-error-message')\n  if (ajaxErrorMessage) {\n    ajaxErrorMessage.hidden = true\n  }\n}\n\non('deprecatedAjaxError', '[data-remote]', function (event) {\n  const detail = (event as CustomEvent).detail\n  const {error, text} = detail\n\n  if (event.currentTarget !== event.target) {\n    return\n  }\n  if (error === 'abort' || error === 'canceled') {\n    return\n  }\n\n  if (/<html/.test(text)) {\n    showGlobalError()\n    event.stopImmediatePropagation()\n  } else {\n    setTimeout(function () {\n      if (event.defaultPrevented) {\n        return\n      }\n      showGlobalError()\n    }, 0)\n  }\n})\n\n// Clear any errors when the request is tried again\non('deprecatedAjaxSend', '[data-remote]', function () {\n  hideGlobalError()\n})\n\n// \"Dismiss\" button\non('click', '.js-ajax-error-dismiss', function () {\n  hideGlobalError()\n})\n","import {eventToHotkeyString} from '@github/hotkey'\n\n// Returns false if a user has explicitly disabled character key shortcuts.\nexport const areCharacterKeyShortcutsEnabled = () => {\n  const keyboardShortcutsPreference = document.querySelector<HTMLMetaElement>(\n    'meta[name=keyboard-shortcuts-preference]'\n  )\n  if (keyboardShortcutsPreference) {\n    return keyboardShortcutsPreference.content === 'all'\n  }\n  return true\n}\n\n// Character-key shortcuts are implemented only with lowercase characters (\"g\", \"g f\"), uppercase characters (\"Shift+a\", \"A\"),\n// symbols (\"Alt+g\"), and punctuation (\"?\", \"!\", \"/\").\n//\n// Returns true if string is NOT what we define as a character key shortcut.\nexport const isNonCharacterKeyShortcut = (hotkey: string) => {\n  return /Enter|Arrow|Escape|Meta|Control|Esc/.test(hotkey) || (hotkey.includes('Alt') && hotkey.includes('Shift'))\n}\n\n// Returns false if a user settings has character key shortcut disabled and keyboard event corresponds to a character key shortcut.\nexport const isShortcutAllowed = (event: KeyboardEvent) => {\n  const hotkey = eventToHotkeyString(event)\n  if (areCharacterKeyShortcutsEnabled()) {\n    return true\n  }\n  return isNonCharacterKeyShortcut(hotkey)\n}\n","type Dimensions = {\n  top: number\n  left: number\n  bottom: number\n  right: number\n  height?: number\n  width?: number\n}\n\ntype Offset = {\n  top: number\n  left: number\n}\n\n// Returns the current coordinates of the element relative to the document.\nexport function offset(element: HTMLElement): Offset {\n  const rect = element.getBoundingClientRect()\n  return {\n    top: rect.top + window.pageYOffset,\n    left: rect.left + window.pageXOffset\n  }\n}\n\n// Get the closest ancestor element that has a scroll overflow.\n//\n// Will walk up the DOM from the element until it reaches an element with\n// overflow scroll. Basically, an element that can have scroll bars.\nexport function overflowParent(targetElement: HTMLElement): HTMLElement | null | undefined {\n  let element = targetElement\n  const document = element.ownerDocument\n  if (!document) {\n    return\n  }\n\n  if (!element.offsetParent) {\n    return\n  }\n\n  /* eslint-disable-next-line @typescript-eslint/ban-ts-comment */\n  // @ts-ignore\n  const HTMLElement = document.defaultView.HTMLElement\n\n  if (element === document.body) {\n    return\n  }\n\n  while (element !== document.body) {\n    if (element.parentElement instanceof HTMLElement) {\n      element = element.parentElement!\n    } else {\n      return\n    }\n\n    const {position, overflowY, overflowX} = getComputedStyle(element)\n    if (\n      position === 'fixed' ||\n      overflowY === 'auto' ||\n      overflowX === 'auto' ||\n      overflowY === 'scroll' ||\n      overflowX === 'scroll'\n    ) {\n      break\n    }\n  }\n\n  return element instanceof Document ? null : element\n}\n\n// Returns overflow/scroll offset relative to the container.\n//\n// Get element overflow offset.\n//\n// This value is useful for figuring out if the element is outside the\n// scrollbars of the container. If `top` is negative, the top of the\n// element is above the scroll view. If `bottom` is negative, the\n// bottom of the element is below the scroll view.\n//\n// +--------------------+.\n// | (outside viewport) |\n// +--------------------+ -|\n// |          |         |  |\n// |    top > |         |  |\n// |          |         |  | h\n// |          |         |  | e\n// |  v left  V right v |  | i\n// |-----> Element <----|  | g\n// |          ^         |  | h\n// |          |         |  | t\n// | bottom > |         |  |\n// |          |         |  |\n// +--------------------+ -|\n// | (outside viewport) |\n// +--------------------+.\n//\n// //=> {top: 100, left: 100, bottom: 800, right: 800, height: 1000, width 1000}.\nexport function overflowOffset(\n  element: HTMLElement,\n  targetContainer: Document | HTMLElement | null\n): Dimensions | undefined {\n  let container = targetContainer\n  const document = element.ownerDocument\n  if (!document) {\n    return\n  }\n\n  const documentElement = document.documentElement\n  if (!documentElement) {\n    return\n  }\n\n  if (element === documentElement) {\n    return\n  }\n\n  const elementOffset = positionedOffset(element, container)\n  if (!elementOffset) {\n    return\n  }\n\n  container = elementOffset._container\n\n  const scroll =\n    container === document.documentElement && document.defaultView\n      ? {\n          top: document.defaultView.pageYOffset,\n          left: document.defaultView.pageXOffset\n        }\n      : {\n          top: container.scrollTop,\n          left: container.scrollLeft\n        }\n\n  const top = elementOffset.top - scroll.top\n  const left = elementOffset.left - scroll.left\n  const height = container.clientHeight\n  const width = container.clientWidth\n  const bottom = height - (top + element.offsetHeight)\n  const right = width - (left + element.offsetWidth)\n  return {top, left, bottom, right, height, width}\n}\n\n// Returns position offset relative to the container.\n//\n// Measures the number of pixels from the top of the container to the\n// top of the element and the number of pixels from the bottom of the\n// containers full scroll height to the bottom of the element. If\n// container is `body`, this is the same as $(element).offset().\n//\n//     +---------------------+ -|\n//     |  outside | viewport |  |\n//     +----------|----------+  |\n//     |          |          |  |\n//     |    top > |          |  |\n//     |          |          |  | h\n//     |          |          |  | e\n//     |  v left  V right v  |  | i\n//     |-----> Element <-----|  | g\n//     |          ^          |  | h\n//     |          |          |  | t\n//     | bottom > |          |  |\n//     |          |          |  |\n//     +----------|----------+  |\n//     |  outside | viewport |  |\n//     +---------------------+ -|\n//\n//   {top: 100, left: 100, bottom: 800, right: 800}.\n//\n// Get element positioned offset.\n//\n// This value is useful for assigning to `scrollTop` to scroll to the item.\nexport function positionedOffset(\n  targetElement: HTMLElement,\n  container: HTMLElement | Document | Window | null\n): (Dimensions & {_container: HTMLElement}) | undefined {\n  let element = targetElement\n  const document = element.ownerDocument\n  if (!document) {\n    return\n  }\n\n  const documentElement = document.documentElement\n  if (!documentElement) {\n    return\n  }\n\n  /* eslint-disable-next-line @typescript-eslint/ban-ts-comment */\n  // @ts-ignore\n  const HTMLElement = document.defaultView.HTMLElement\n\n  let top = 0\n  let left = 0\n  const height = element.offsetHeight\n  const width = element.offsetWidth\n\n  while (!(element === document.body || element === container)) {\n    top += element.offsetTop || 0\n    left += element.offsetLeft || 0\n\n    if (element.offsetParent instanceof HTMLElement) {\n      element = element.offsetParent!\n    } else {\n      return\n    }\n  }\n\n  let scrollHeight\n  let scrollWidth\n  let measuredContainer: HTMLElement\n\n  if (\n    !container ||\n    container === document ||\n    container === document.defaultView ||\n    container === document.documentElement ||\n    container === document.body\n  ) {\n    measuredContainer = documentElement\n    scrollHeight = getDocumentHeight(document.body, documentElement)\n    scrollWidth = getDocumentWidth(document.body, documentElement)\n  } else if (container instanceof HTMLElement) {\n    measuredContainer = container\n    scrollHeight = container.scrollHeight\n    scrollWidth = container.scrollWidth\n  } else {\n    return\n  }\n\n  const bottom = scrollHeight - (top + height)\n  const right = scrollWidth - (left + width)\n  return {top, left, bottom, right, _container: measuredContainer}\n}\n\nfunction getDocumentHeight(documentBody: HTMLElement, documentElement: HTMLElement): number {\n  return Math.max(\n    documentBody.scrollHeight,\n    documentElement.scrollHeight,\n    documentBody.offsetHeight,\n    documentElement.offsetHeight,\n    documentElement.clientHeight\n  )\n}\n\nfunction getDocumentWidth(documentBody: HTMLElement, documentElement: HTMLElement): number {\n  return Math.max(\n    documentBody.scrollWidth,\n    documentElement.scrollWidth,\n    documentBody.offsetWidth,\n    documentElement.offsetWidth,\n    documentElement.clientWidth\n  )\n}\n","import {getDocumentHtmlSafeNonces, verifyResponseHtmlSafeNonce} from './html-safe'\nimport {parseHTML} from './parse-html'\n\nexport async function fetchSafeDocumentFragment(\n  document: Document,\n  url: RequestInfo,\n  options?: RequestInit\n): Promise<DocumentFragment> {\n  const request = new Request(url, options)\n  request.headers.append('X-Requested-With', 'XMLHttpRequest')\n  const response = await self.fetch(request)\n  if (response.status < 200 || response.status >= 300) {\n    throw new Error(`HTTP ${response.status}${response.statusText || ''}`)\n  }\n  verifyResponseHtmlSafeNonce(getDocumentHtmlSafeNonces(document), response)\n  return parseHTML(document, await response.text())\n}\n\nexport function fetchPoll(url: RequestInfo, options?: RequestInit, timeBetweenRequests = 1000): Promise<Response> {\n  return (async function poll(wait: number): Promise<Response> {\n    const request = new Request(url, options)\n    request.headers.append('X-Requested-With', 'XMLHttpRequest')\n    const response = await self.fetch(request)\n    if (response.status < 200 || response.status >= 300) {\n      throw new Error(`HTTP ${response.status}${response.statusText || ''}`)\n    }\n\n    if (response.status === 200) return response\n    if (response.status === 202) {\n      await new Promise(resolve => setTimeout(resolve, wait))\n      return poll(wait * 1.5)\n    }\n    throw new Error(`Unexpected ${response.status} response status from poll endpoint`)\n  })(timeBetweenRequests)\n}\n","// eslint-disable-next-line no-restricted-imports\nimport {on} from 'delegated-events'\nimport {persistSubmitButtonValue} from './remote-submit'\nimport {showGlobalError} from './behaviors/ajax-error'\n\ntype TextField = HTMLInputElement | HTMLTextAreaElement\ntype Button = HTMLInputElement | HTMLButtonElement\n\non('click', '.js-remote-submit-button', async function (event) {\n  const button = event.currentTarget as HTMLButtonElement\n  const form = button.form as HTMLFormElement\n  event.preventDefault()\n  let response\n  try {\n    response = await fetch(form.action, {\n      method: form.method,\n      body: new FormData(form),\n      headers: {\n        Accept: 'application/json',\n        'X-Requested-With': 'XMLHttpRequest'\n      }\n    })\n  } catch {\n    // Ignore network errors\n  }\n  if (response && !response.ok) {\n    showGlobalError()\n  }\n})\n\nfunction fire(target: HTMLElement, name: string, cancelable: boolean): boolean {\n  return target.dispatchEvent(\n    new CustomEvent(name, {\n      bubbles: true,\n      cancelable\n    })\n  )\n}\n\n// Submit a form while ensuring that `submit` event is also triggered.\n//\n// Calling native `form.submit()` method immediately submits the form without triggering the `submit` event.\n// As a result, code that wants to hook into form submits would never execute.\n//\n// This method first triggers the `submit` event and, if that event wasn't `preventDefault`d, submits the\n// form natively.\nexport function requestSubmit(form: HTMLFormElement, submitter?: Button) {\n  if (submitter) {\n    checkButtonValidity(form, submitter)\n    persistSubmitButtonValue(submitter)\n  }\n  if (fire(form, 'submit', true)) {\n    form.submit()\n  }\n}\n\n// Check submitter validity for form.requestSubmit compatibility.\n// See https://html.spec.whatwg.org/#dom-form-requestsubmit.\nfunction checkButtonValidity(form: HTMLFormElement, submitter: Button) {\n  if (!(form instanceof HTMLFormElement)) throw new TypeError('The specified element is not of type HTMLFormElement.')\n  if (!(submitter instanceof HTMLElement)) throw new TypeError('The specified element is not of type HTMLElement.')\n  if (submitter.type !== 'submit') throw new TypeError('The specified element is not a submit button.')\n  if (!form || form !== submitter.form) throw new Error('The specified element is not owned by the form element.')\n}\n\n// Set a form field value while ensuring that `change` event is also triggered.\n//\n// Having the `change` event fire is important for various behaviors to react, such as form validation.\nexport function changeValue(input: TextField, value: string | boolean) {\n  if (typeof value === 'boolean') {\n    if (input instanceof HTMLInputElement) {\n      input.checked = value\n    } else {\n      throw new TypeError('only checkboxes can be set to boolean value')\n    }\n  } else {\n    if (input.type === 'checkbox') {\n      throw new TypeError(\"checkbox can't be set to string value\")\n    } else {\n      input.value = value\n    }\n  }\n  fire(input, 'change', false)\n}\n\n// Fill multiple form fields by item name.\nexport function fillFormValues(form: HTMLFormElement, fields: {[key: string]: string}) {\n  for (const name in fields) {\n    const value = fields[name]\n    const element = form.elements.namedItem(name)\n\n    if (element instanceof HTMLInputElement) {\n      element.value = value\n    } else if (element instanceof HTMLTextAreaElement) {\n      element.value = value\n    }\n  }\n}\n\n// Test if element is a form field.\nexport function isFormField(element: Node): boolean {\n  if (!(element instanceof HTMLElement)) {\n    return false\n  }\n\n  const name = element.nodeName.toLowerCase()\n  const type = (element.getAttribute('type') || '').toLowerCase()\n  return (\n    name === 'select' ||\n    name === 'textarea' ||\n    (name === 'input' && type !== 'submit' && type !== 'reset') ||\n    element.isContentEditable\n  )\n}\n\nfunction searchParamsFromFormData(formData: FormData): URLSearchParams {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return new URLSearchParams(formData as any)\n}\n\n// Get a `?` search string for a URL for a GET form, using its `action` attribute as well as its other fields.\nexport function combineGetFormSearchParams(formAction: URL, formData: FormData): string {\n  const allSearchParams = new URLSearchParams(formAction.search)\n  const searchParamsFromInputs = searchParamsFromFormData(formData)\n  for (const [key, value] of searchParamsFromInputs) {\n    allSearchParams.append(key, value)\n  }\n  return allSearchParams.toString()\n}\n\n// Serialize form data into string.\nexport function serialize(form: HTMLFormElement): string {\n  return searchParamsFromFormData(new FormData(form)).toString()\n}\n","//  Get document's HTML Safe nonce.\n//\n// Example:\n//\n//   <meta name=\"html-safe-nonce\" content=\"de43a1f355c711f7f705e4f971964391ac0c8e13\">\nexport function getDocumentHtmlSafeNonces(document: Document): string[] {\n  const nonces = [...document.querySelectorAll<HTMLMetaElement>('meta[name=html-safe-nonce]')].map(meta => meta.content)\n\n  if (nonces.length < 1) {\n    throw new Error('could not find html-safe-nonce on document')\n  }\n  return nonces\n}\n\ninterface Response {\n  headers: Headers\n  status: number\n}\n\nclass ResponseError extends Error {\n  response: Response\n\n  constructor(message: string, response: Response) {\n    super(`${message} for HTTP ${response.status}`)\n    this.response = response\n  }\n}\n\nexport function verifyResponseHtmlSafeNonce(nonces: string[], response: Response, allowJson = false) {\n  const contentType = response.headers.get('content-type') || ''\n  if (!allowJson && !contentType.startsWith('text/html')) {\n    throw new ResponseError(`expected response with text/html, but was ${contentType}`, response)\n  }\n\n  if (allowJson && !(contentType.startsWith('text/html') || contentType.startsWith('application/json'))) {\n    throw new ResponseError(`expected response with text/html or application/json, but was ${contentType}`, response)\n  }\n\n  const responseNonce = response.headers.get('x-html-safe')\n  if (!responseNonce) {\n    throw new ResponseError(`missing X-HTML-Safe nonce`, response)\n  } else if (!nonces.includes(responseNonce)) {\n    throw new ResponseError(`response X-HTML-Safe nonce did not match`, response)\n  }\n}\n","type ScrollToOptions = {\n  top: number\n  left?: number\n}\n\nexport default function scrollTo(targetContainer: HTMLElement, options: ScrollToOptions) {\n  let container: Node = targetContainer\n  const document = targetContainer.ownerDocument\n\n  if (\n    container === document ||\n    /* eslint-disable-next-line @typescript-eslint/ban-ts-comment */\n    // @ts-ignore - Suppress TS2367 error that I don't trust\n    container === document.defaultView ||\n    container === document.documentElement ||\n    container === document.body\n  ) {\n    container = document\n  }\n\n  const Document = document.defaultView!.Document\n\n  if (container instanceof Document) {\n    const top = options.top != null ? options.top : document.defaultView!.pageYOffset\n    const left = options.left != null ? options.left : document.defaultView!.pageXOffset\n    document.defaultView!.scrollTo(left, top)\n    return\n  }\n\n  const HTMLElement = document.defaultView!.HTMLElement\n\n  if (!(container instanceof HTMLElement)) {\n    throw new Error('invariant')\n  }\n\n  container.scrollTop = options.top\n  if (options.left != null) {\n    container.scrollLeft = options.left\n  }\n}\n","// Navigation Behavior\n//\n// Provides basic cursor, vi and emacs keyboard navigation. As well as\n// mouseover selection.\n//\n// item Element with .js-navigation-item. The current focused\n//            item is denoted with the .navigation-focus class.\n// container Element with .js-navigation-container class name.\n//                 Contains item elements. The active container is denoted\n//                 by the .js-active-navigation-container class.\n//\n// The .js-active-navigation-container class can be part of the html or\n// added programmatically with navigation('focus'). Making it part of\n// the template will automatically activate it without any extra JS.\n// Just make sure its the only active container on the page.\n//\n// li.navigation-focus { background: yellow; }\n//\n// <ul class=\"js-navigation-container js-active-navigation-container\">\n//   <li class=\"js-navigation-item\"><a href=\"\">One</a></li>\n//   <li class=\"js-navigation-item\"><a href=\"\">Two</a></li>\n//   <li class=\"js-navigation-item\"><a href=\"\">Three</a></li>\n// </ul>\n//\n// Methods\n//\n// .navigation('active')\n//\n// Returns current active container.\n//\n// .navigation('activate')\n//\n// Activates navigation container.\n//\n// .navigation('deactivate')\n//\n// Deactivates navigation container.\n//\n// .navigation('push')\n//\n// Activates navigation container and push it onto a stack.\n//\n// .navigation('pop')\n//\n// Deactivates navigation container and remove it from stack. Then\n// activate the previous container on the top of the stack.\n//\n// .navigation('focus')\n//\n// Activates navigation container and focus first item.\n//\n// .navigation('clear')\n//\n// Removes current focus.\n//\n// .navigation('refocus')\n//\n// Removes current focus and focuses on the first item.\n//\n//\n// Events\n//\n// navigation:focus\n//\n// Bubbles Yes\n// Cancelable Yes\n// Default action Focus navigation item\n// Target .js-navigation-item Element\n//\n// navigation:keydown\n//\n// Bubbles Yes\n// Cancelable Yes\n// Default action Deactivate navigation\n// Target .js-navigation-item or .js-navigation-container Element\n// Context info\n//   * originalEvent - keydown event\n//   * relatedTarget - .js-navigation-container Element\n//\n// navigation:keyopen\n//\n// Bubbles Yes\n// Cancelable No\n// Target .js-navigation-item Element\n// Context info\n//   * modifierKey - Boolean for ctrl or command modifier key\n//\n// navigation:open\n//\n// Bubbles Yes\n// Cancelable Yes\n// Target .js-navigation-item Element\n// Context info\n//   * modifierKey - Boolean for ctrl or command modifier key\n//\n\nimport {compose, fromEvent} from './subscription'\n// eslint-disable-next-line no-restricted-imports\nimport {fire, on} from 'delegated-events'\nimport {overflowOffset, overflowParent, positionedOffset} from './dimensions'\nimport {eventToHotkeyString} from '@github/hotkey'\nimport {isShortcutAllowed} from './behaviors/keyboard-shortcuts-helper'\n// eslint-disable-next-line no-restricted-imports\nimport {observe} from 'selector-observer'\nimport scrollTo from './scrollto'\nimport visible from './visible'\n\nconst ctrlBindings = navigator.userAgent.match(/Macintosh/)\nconst modifierKey = ctrlBindings ? 'metaKey' : 'ctrlKey'\nconst hotkeyModifier = ctrlBindings ? 'Meta' : 'Control'\n\nlet disableMouseEvents = false\nlet mousePosition = {\n  x: 0,\n  y: 0\n}\n\ntype ScrollBehavior = 'auto' | 'smooth'\n\n// Binds mouseover handlers on navigation containers.\n//\n// This is an optimization to avoid adding a global mouseover to document.\nobserve('.js-navigation-container:not(.js-navigation-container-no-mouse)', {\n  subscribe: el =>\n    compose(fromEvent(el, 'mouseover', onContainerMouseMove), fromEvent(el, 'mouseover', onContainerMouseOver))\n})\n\n// Tracks last mouse position inside container.\nfunction onContainerMouseMove(event: Event) {\n  if (!(event instanceof MouseEvent)) return\n  if (mousePosition.x !== event.clientX || mousePosition.y !== event.clientY) {\n    disableMouseEvents = false\n  }\n  mousePosition = {\n    x: event.clientX,\n    y: event.clientY\n  }\n}\n\nfunction onContainerMouseOver(event: Event) {\n  if (disableMouseEvents) {\n    return\n  }\n  const container = event.currentTarget\n  const {target} = event\n  if (\n    !(target instanceof Element) ||\n    !(container instanceof HTMLElement) ||\n    !container.closest('.js-active-navigation-container')\n  ) {\n    return\n  }\n  const item = target.closest('.js-navigation-item')\n  if (item) focusItem(item, container)\n}\n\nlet count = 0\nobserve('.js-active-navigation-container', {\n  add() {\n    count++\n    if (count === 1) document.addEventListener('keydown', fireCustomKeydown)\n  },\n  remove() {\n    count--\n    if (count === 0) document.removeEventListener('keydown', fireCustomKeydown)\n  }\n})\n\n// Dispatches custom events from focused items.\n//\n// It also makes it easy to bind custom hotkeys to focused items.\nfunction fireCustomKeydown(event: KeyboardEvent) {\n  if (\n    event.target !== document.body &&\n    event.target instanceof HTMLElement &&\n    !event.target.classList.contains('js-navigation-enable')\n  ) {\n    return\n  }\n\n  disableMouseEvents = true\n\n  const container = getActiveContainer()\n  let dispatched = false\n\n  if (container) {\n    const target = container.querySelector('.js-navigation-item.navigation-focus') || container\n    dispatched = fire(target, 'navigation:keydown', {\n      hotkey: eventToHotkeyString(event),\n      originalEvent: event,\n      originalTarget: event.target\n    })\n  }\n\n  if (!dispatched) {\n    event.preventDefault()\n  }\n}\n\non('navigation:keydown', '.js-active-navigation-container', function (event) {\n  const container = event.currentTarget as HTMLElement\n  const isInput = event.detail.originalTarget.matches('input, textarea')\n  const item = event.target as HTMLElement\n\n  if (!isShortcutAllowed(event.detail.originalEvent)) return\n\n  if (item.classList.contains('js-navigation-item')) {\n    if (isInput) {\n      if (ctrlBindings) {\n        switch (eventToHotkeyString(event.detail.originalEvent)) {\n          case 'Control+n':\n            cursorDown(item, container)\n            break\n          case 'Control+p':\n            cursorUp(item, container)\n        }\n      }\n      switch (eventToHotkeyString(event.detail.originalEvent)) {\n        case 'ArrowUp':\n          cursorUp(item, container)\n          break\n        case 'ArrowDown':\n          cursorDown(item, container)\n          break\n        case 'Enter':\n        case `${hotkeyModifier}+Enter`:\n          keyOpen(item, event.detail.originalEvent[modifierKey])\n          break\n      }\n    } else {\n      if (ctrlBindings) {\n        switch (eventToHotkeyString(event.detail.originalEvent)) {\n          case 'Control+n':\n            cursorDown(item, container)\n            break\n          case 'Control+p':\n            cursorUp(item, container)\n            break\n          case 'Alt+v':\n            pageUp(item, container)\n            break\n          case 'Control+v':\n            pageDown(item, container)\n        }\n      }\n      switch (eventToHotkeyString(event.detail.originalEvent)) {\n        case 'j':\n        case 'J':\n          cursorDown(item, container)\n          break\n        case 'k':\n        case 'K':\n          cursorUp(item, container)\n          break\n        case 'o':\n        case 'Enter':\n        case `${hotkeyModifier}+Enter`:\n          keyOpen(item, event.detail[modifierKey])\n          break\n      }\n    }\n  } else {\n    const firstItem = getItems(container)[0]\n    if (firstItem) {\n      if (isInput) {\n        if (ctrlBindings) {\n          switch (eventToHotkeyString(event.detail.originalEvent)) {\n            case 'Control+n':\n              focusItem(firstItem, container)\n          }\n        }\n        switch (eventToHotkeyString(event.detail.originalEvent)) {\n          case 'ArrowDown':\n            focusItem(firstItem, container)\n        }\n      } else {\n        if (ctrlBindings) {\n          switch (eventToHotkeyString(event.detail.originalEvent)) {\n            case 'Control+n':\n            case 'Control+v':\n              focusItem(firstItem, container)\n          }\n        }\n        switch (eventToHotkeyString(event.detail.originalEvent)) {\n          case 'j':\n            focusItem(firstItem, container)\n        }\n      }\n    }\n  }\n\n  if (isInput) {\n    if (ctrlBindings) {\n      switch (eventToHotkeyString(event.detail.originalEvent)) {\n        case 'Control+n':\n        case 'Control+p':\n          event.preventDefault()\n      }\n    }\n    switch (eventToHotkeyString(event.detail.originalEvent)) {\n      case 'ArrowUp':\n      case 'ArrowDown':\n        event.preventDefault()\n        break\n      case 'Enter':\n        event.preventDefault()\n    }\n  } else {\n    if (ctrlBindings) {\n      switch (eventToHotkeyString(event.detail.originalEvent)) {\n        case 'Control+n':\n        case 'Control+p':\n        case 'Control+v':\n        case 'Alt+v':\n          event.preventDefault()\n      }\n    }\n    switch (eventToHotkeyString(event.detail.originalEvent)) {\n      case 'j':\n      case 'k':\n      case 'o':\n        event.preventDefault()\n        break\n      case 'Enter':\n      case `${modifierKey}+Enter`:\n        event.preventDefault()\n    }\n  }\n})\n\n// Fire custom navigation:open event.\n//\n// Examples:\n//\n// on('navigation:open', '.listings .listing', function() {\n//   window.location = this.querySelector('a').getAttribute('href')\n// }).\nfunction fireOpen(\n  event: Event & {modifierKey?: boolean; altKey?: boolean; ctrlKey?: boolean; metaKey?: boolean; shiftKey?: boolean}\n) {\n  /* eslint eslint-comments/no-use: off */\n  /* eslint-disable no-restricted-syntax */\n  const modifier = event.modifierKey || event.altKey || event.ctrlKey || event.metaKey\n  const dispatched = fire(event.currentTarget as Element, 'navigation:open', {\n    modifierKey: modifier,\n    shiftKey: event.shiftKey\n  })\n  /* eslint-enable no-restricted-syntax */\n\n  if (!dispatched) {\n    event.preventDefault()\n  }\n}\n\n// Open the item on click.\non('click', '.js-active-navigation-container .js-navigation-item', function (event) {\n  fireOpen(event)\n})\n\n// Handle keydown open events.\non('navigation:keyopen', '.js-active-navigation-container .js-navigation-item', function (event) {\n  const a = event.currentTarget.classList.contains('js-navigation-open')\n    ? event.currentTarget\n    : event.currentTarget.querySelector('.js-navigation-open')\n  if (a instanceof HTMLAnchorElement) {\n    if (event.detail.modifierKey) {\n      window.open(a.href, '_blank')\n      window.focus()\n    } else {\n      const clicked = a.dispatchEvent(\n        new MouseEvent('click', {\n          bubbles: true,\n          cancelable: true\n        })\n      )\n      if (clicked) {\n        a.click()\n      }\n    }\n    event.preventDefault()\n  } else {\n    fireOpen(event)\n  }\n})\n\n// Make container active by adding the js-active-navigation-container class to it.\nexport function activate(container: Element | null) {\n  const activeContainer = getActiveContainer()\n  if (container !== activeContainer) {\n    if (activeContainer !== null) deactivate(activeContainer)\n    container?.classList.add('js-active-navigation-container')\n  }\n}\n\n// Remove active id from container.\nexport function deactivate(container: Element) {\n  container.classList.remove('js-active-navigation-container')\n}\n\nconst containerStack: Element[] = []\n\n// Active container and push previous onto a stack.\nexport function push(container: HTMLElement) {\n  const activeContainer = getActiveContainer()\n  if (activeContainer) {\n    containerStack.push(activeContainer)\n  }\n  activate(container)\n}\n\n// Deactivate container and activate the next on the stack.\nexport function pop(container: Element) {\n  deactivate(container)\n  clear(container)\n\n  const activeContainer = containerStack.pop()\n  if (activeContainer) {\n    activate(activeContainer)\n  }\n}\n\n// Active the container and focus on the target or first element.\nexport function focus(container: HTMLElement, targetElement?: HTMLElement) {\n  const target = targetElement || container\n\n  const firstItem = getItems(container)[0]\n  const item = target.closest('.js-navigation-item') || firstItem\n\n  activate(container)\n\n  if (item instanceof HTMLElement) {\n    const focusPrevented = focusItem(item, container)\n    if (focusPrevented) {\n      return\n    }\n    const parent = overflowParent(item)\n    scrollItemTo(parent!, item)\n  }\n}\n\n// Clear current focus.\nexport function clear(container: Element) {\n  const elements = container.querySelectorAll('.js-navigation-item.navigation-focus')\n  for (const element of elements) {\n    element.classList.remove('navigation-focus')\n  }\n}\n\n// Clear current focus and focus on the target or first element.\nexport function refocus(container: HTMLElement, target?: HTMLElement) {\n  clear(container)\n  focus(container, target)\n}\n\n// Select the previous item and scroll to it if its off screen.\nfunction cursorUp(item: HTMLElement, container: HTMLElement) {\n  const items = getItems(container)\n  const index = items.indexOf(item)\n  const previous = items[index - 1]\n  if (previous) {\n    const focusPrevented = focusItem(previous, container)\n    if (focusPrevented) {\n      return\n    }\n\n    const overflowParentEl = overflowParent(previous)\n    if (getScrollStyle(container) === 'page') {\n      scrollPageTo(overflowParentEl!, previous)\n    } else {\n      scrollItemTo(overflowParentEl!, previous)\n    }\n  }\n}\n\n// Select the next item and scroll to it if its off screen.\nfunction cursorDown(item: HTMLElement, container: HTMLElement) {\n  const items = getItems(container)\n  const index = items.indexOf(item)\n  const next = items[index + 1]\n\n  if (next) {\n    const focusPrevented = focusItem(next, container)\n    if (focusPrevented) {\n      return\n    }\n\n    const overflowParentEl = overflowParent(next)\n    if (getScrollStyle(container) === 'page') {\n      scrollPageTo(overflowParentEl!, next)\n    } else {\n      scrollItemTo(overflowParentEl!, next)\n    }\n  }\n}\n\n// Scrolls up to the previous item that is above the viewport.\nfunction pageUp(item: HTMLElement, container: HTMLElement) {\n  const items = getItems(container)\n  let index = items.indexOf(item)\n  const overflowParentEl = overflowParent(item)\n\n  if (overflowParentEl == null) {\n    return\n  }\n\n  let previous\n  let dimension\n  while (\n    (previous = items[index - 1]) &&\n    (dimension = overflowOffset(previous, overflowParentEl)) &&\n    dimension.top >= 0\n  ) {\n    index--\n  }\n\n  if (previous) {\n    const focusPrevented = focusItem(previous, container)\n    if (focusPrevented) {\n      return\n    }\n\n    scrollPageTo(overflowParentEl, previous)\n  }\n}\n\n// Scrolls down to the next item that is below the viewport.\nfunction pageDown(item: HTMLElement, container: HTMLElement) {\n  const items = getItems(container)\n  let index = items.indexOf(item)\n  const overflowParentEl = overflowParent(item)\n\n  if (overflowParentEl == null) {\n    return\n  }\n\n  let next\n  let dimension\n  while ((next = items[index + 1]) && (dimension = overflowOffset(next, overflowParentEl)) && dimension.bottom >= 0) {\n    index++\n  }\n\n  if (next) {\n    const focusPrevented = focusItem(next, container)\n    if (focusPrevented) {\n      return\n    }\n    scrollPageTo(overflowParentEl, next)\n  }\n}\n\n// Handle opening item from keyboard.\n//\n// Hitting o or enter on a item will call this method.\nfunction keyOpen(item: Element, modifier = false) {\n  fire(item, 'navigation:keyopen', {\n    modifierKey: modifier\n  })\n}\n\nfunction focusItem(target: Element, container: Element): boolean {\n  if (fire(target, 'navigation:focus')) {\n    clear(container)\n    target.classList.add('navigation-focus')\n\n    return false\n  } else {\n    return true\n  }\n}\n\nfunction getActiveContainer() {\n  return document.querySelector('.js-active-navigation-container')\n}\n\nfunction getItems(container: Element): HTMLElement[] {\n  const items = []\n  for (const element of container.querySelectorAll('.js-navigation-item')) {\n    if (element instanceof HTMLElement && visible(element)) {\n      items.push(element)\n    }\n  }\n\n  return items\n}\n\nfunction getScrollStyle(container: HTMLElement): string {\n  return container.getAttribute('data-navigation-scroll') || 'item'\n}\n\nfunction scrollPageTo(container: HTMLElement, element: HTMLElement, behavior: ScrollBehavior = 'smooth') {\n  const overflow = overflowOffset(element, container)\n  if (!overflow) return\n\n  if (overflow.bottom <= 0) {\n    element.scrollIntoView({behavior, block: 'start'})\n  } else if (overflow.top <= 0) {\n    element.scrollIntoView({behavior, block: 'end'})\n  }\n}\n\nfunction scrollItemTo(container: HTMLElement, element: HTMLElement) {\n  const position = positionedOffset(element, container)\n  const overflow = overflowOffset(element, container)\n\n  if (position == null || overflow == null) {\n    return\n  }\n\n  if (overflow.bottom <= 0 && document.body) {\n    const scrollHeight = container.offsetParent != null ? container.scrollHeight : document.body.scrollHeight\n    const scrollTop = scrollHeight - (position.bottom + overflow.height!)\n    scrollTo(container, {\n      top: scrollTop\n    })\n  } else if (overflow.top <= 0) {\n    scrollTo(container, {\n      top: position.top\n    })\n  }\n}\n","import {focus as navigationFocus} from '../../navigation'\nimport visible from '../../visible'\n\ninterface FocusPosition {\n  id?: string | null\n  position?: number\n}\n\n/*\n * Returns the currently focussed notification id, and it's position in the\n * notification list This should be saved before the list is modified, and then\n * the result can be passed to restoreFocus() to restore the notification list\n * focus to (roughly) the same place.\n *\n * By default it works with the container and selector used on\n * `/notifications`, but they can be overridden by the `notificationsList` and\n * `keyboardFocusedSelector` optional parameters.\n */\nexport function getCurrentFocus(notificationsList?: HTMLElement, keyboardFocusedSelector?: string): FocusPosition {\n  const container = notificationsList || getNotificationsList()\n  if (!container) return {}\n\n  const keyboardFocused = container.querySelector(\n    keyboardFocusedSelector || '.js-notifications-list-item.navigation-focus'\n  )\n  if (!(keyboardFocused instanceof HTMLElement)) return {}\n\n  return {\n    id: keyboardFocused.getAttribute('data-notification-id'),\n    position: getItems(container).indexOf(keyboardFocused)\n  }\n}\n\n/*\n * Restores the focussed notification list focus, based on the previously\n * focused id/position If `id` is not null, and the notification with that id\n * is still in the notification list, that element will be focussed.\n * Otherwise, the element at the matching position (or the last one if the\n * position exceeds the new list length) will be focussed.\n *\n * Be aware that when notifications are loaded from the server, a notification\n * can jump from anywhere in the list to the top if they are updated with a new\n * notification. So if restoring focus after loading new data from the server,\n * restoring by id may be confusing to users.\n *\n * By default it works with the container on `/notifications` but it can be\n * overridden by the `notificationsList` optional parameter.\n */\nexport function restoreFocus({id, position}: FocusPosition, notificationsList?: HTMLElement) {\n  const container = notificationsList || getNotificationsList()\n  if (!(container instanceof HTMLElement)) return\n\n  const items = getItems(container)\n  let target\n\n  // Try to find target by id if it was passed\n  if (id) {\n    target = items.find(el => el.getAttribute('data-notification-id') === id)\n  }\n\n  // If we didn't find target, and position is passed, find by position\n  // falls back to last item if position > length\n  if (!target && position != null) {\n    target = items[Math.min(position, items.length - 1)]\n  }\n\n  if (target instanceof HTMLElement) {\n    navigationFocus(container, target)\n  }\n}\n\nfunction getNotificationsList() {\n  return document.querySelector('.js-notifications-list .js-navigation-container')\n}\n\n// Returns the visible, navigatable items in the notifications list.\nfunction getItems(container: Element): Element[] {\n  return Array.from(container.querySelectorAll<HTMLElement>('.js-navigation-item')).filter(visible)\n}\n","export function parseHTML(document: Document, html: string): DocumentFragment {\n  const template = document.createElement('template')\n  template.innerHTML = html\n  return document.importNode(template.content, true)\n}\n","// Emulates submit button submission values by inserting a hidden input to the form.\n//\n// Submit events can be triggerd in the following ways:\n// - User clicks on a submit button.\n// - User press Enter when focusing on a form field; also known as \"implicit submission\".\n// - Programmatically via requestSubmit helper.\n//\n// On GitHub.com, the submission is either handled by the browser or remoteForm.\n//\n// For submissions triggered by user actions, the name and value of the clicked submit button (also known as\n// \"the submitter\") is passed along in the request, and can be programmatically retrieved with FormData.entries().\n//\n// However, this value will be lost in the following cases:\n// - 1. When the submitter button is disabled, most commonly by [data-disable-with].\n// - 2. When submitting via requestSubmit (from form.js), because the submission does not originated from a submitter.\n// - 3. When submitting with remoteForm, because FormData(form).entries() does not know about the submitter. In Safari\n// the submitter is known during the submission steps, but this behavior is not supported in any other browsers.\n//\n// @see {@link https://github.com/github/form-data-entries/pull/7}.\n//\n// For the exact workarounds, refer to ./form.js and ./remote.js.\nexport function persistSubmitButtonValue(button: HTMLButtonElement | HTMLInputElement) {\n  const form = button.closest('form')\n  if (!(form instanceof HTMLFormElement)) {\n    return\n  }\n\n  let input = findPersistedSubmitButtonValue(form)\n\n  if (button.name) {\n    const defaultValue = button.matches('input[type=submit]') ? 'Submit' : ''\n    const value = button.value || defaultValue\n    if (!input) {\n      input = document.createElement('input')\n      input.type = 'hidden'\n      input.classList.add('is-submit-button-value')\n      form.prepend(input)\n    }\n    input.name = button.name\n    input.value = value\n  } else if (input) {\n    input.remove()\n  }\n}\n\nexport function findPersistedSubmitButtonValue(form: HTMLFormElement): HTMLInputElement | null {\n  const input = form.querySelector('input.is-submit-button-value')\n  return input instanceof HTMLInputElement ? input : null\n}\n","// TODO: Research replacing this module with a composable observable library.\n// The scope of this module simply returns a finalized subscription object.\n\n// Lightweight TC39 observable Subscription.\nexport class Subscription {\n  constructor(cleanup: () => void) {\n    this.closed = false\n    this.unsubscribe = () => {\n      cleanup()\n      this.closed = true\n    }\n  }\n\n  // A boolean value indicating whether the subscription is closed.\n  closed: boolean\n  // Cancels the subscription.\n  unsubscribe: () => void\n}\n\n// Create a Subscription from an event.\nexport function fromEvent(\n  target: EventTarget,\n  eventName: string,\n  onNext: EventListenerOrEventListenerObject,\n  options: AddEventListenerOptions = {capture: false}\n): Subscription {\n  target.addEventListener(eventName, onNext, options)\n  return new Subscription(() => {\n    target.removeEventListener(eventName, onNext, options)\n  })\n}\n\n// Combine several subscriptions into a single subscription.\n//\n// subscriptions - A list of subscriptions to combine.\n//\n// Returns a single, combined, subscription.\nexport function compose(...subscriptions: Subscription[]): Subscription {\n  return new Subscription(() => {\n    for (const subscription of subscriptions) {\n      subscription.unsubscribe()\n    }\n  })\n}\n","// Due to the way `visible` is implemented, it causes the browser to\n// perform a full page reflow, it lays out all elements again, when called. This\n// is one of the most time consuming operations the browser can perform, so it\n// affects perceived page load times.\n//\n// The preferred way to determine element visibility is check for the presence\n// of the `hidden` attribute: `if (el.hidden) ...` and `el.hidden = false`.\n//\n// More info: https://github.com/github/eslint-plugin-github/blob/master/docs/rules/no-d-none.md.\n//\n// We would ideally like to remove the `visible` function and consistently\n// use the `hidden` attribute.\n//\n// Returns true if the element is hidden.\nfunction hidden(element: HTMLElement): boolean {\n  return element.offsetWidth <= 0 && element.offsetHeight <= 0\n}\n\nexport default function visible(element: HTMLElement): boolean {\n  return !hidden(element)\n}\n","import {controller, target} from '@github/catalyst'\n\n@controller\nclass NotificationIndicatorElement extends HTMLElement {\n  @target link: Element\n  @target modifier: Element\n\n  /* eslint-disable-next-line custom-elements/no-constructor */\n  constructor() {\n    super()\n    this.addEventListener('socket:message', this.update.bind(this))\n  }\n\n  update(event: Event) {\n    const data = (event as CustomEvent).detail.data\n    this.link.setAttribute('aria-label', data.aria_label)\n    this.link.setAttribute('data-ga-click', data.ga_click)\n    this.modifier.setAttribute('class', data.span_class)\n  }\n}\n","import {controller, target} from '@github/catalyst'\n\n@controller\nclass NotificationFocusIndicatorElement extends HTMLElement {\n  @target link: Element\n  @target modifier: Element\n\n  connectedCallback() {\n    this.addEventListener('socket:message', event => {\n      const data = (event as CustomEvent).detail.data\n      this.link.setAttribute('aria-label', data.aria_label)\n      this.link.setAttribute('data-ga-click', data.ga_click)\n      this.modifier.setAttribute('class', data.span_class)\n    })\n  }\n\n  toggleSidebar(): void {\n    const event = new CustomEvent('notification-focus:toggle-sidebar', {bubbles: true})\n    this.dispatchEvent(event)\n  }\n}\n","import {controller, target} from '@github/catalyst'\n\n@controller\nexport class NotificationFocusFiltersElement extends HTMLElement {\n  @target detailsContainer: HTMLElement\n  @target filterTitle: HTMLElement\n\n  changeFilter(e: Event) {\n    e.preventDefault()\n    this.detailsContainer.removeAttribute('open')\n    const link = e.currentTarget as HTMLLinkElement\n\n    this.setFilterTitle(link.innerHTML)\n\n    this.dispatchEvent(\n      new CustomEvent('focus-mode-filter-change', {\n        detail: {url: link.href}\n      })\n    )\n  }\n\n  private setFilterTitle(text: string) {\n    this.filterTitle.innerHTML = text\n  }\n}\n","import {controller, target, targets} from '@github/catalyst'\nimport {getCurrentFocus, restoreFocus} from '../v2/notification-list-focus'\nimport {pop, push} from '../../navigation'\nimport IncludeFragmentElement from '@github/include-fragment-element'\nimport {NotificationFocusListItemElement} from './notification-focus-list-item-element'\nimport {fetchSafeDocumentFragment} from '../../fetch'\n// eslint-disable-next-line no-restricted-imports\nimport {observe} from 'selector-observer'\n// eslint-disable-next-line no-restricted-imports\nimport {on} from 'delegated-events'\n\n@controller\nexport class NotificationFocusListElement extends HTMLElement {\n  @target container: HTMLElement\n\n  @target includeFragment: IncludeFragmentElement\n  @target list: HTMLElement\n  @target blankSlate: HTMLElement\n\n  @targets listElements: NotificationFocusListItemElement[]\n\n  @target nextPageItem: HTMLElement\n  @target nextPageItemSpinner: HTMLElement\n\n  private currentObserver: IntersectionObserver | undefined\n\n  connectedCallback() {\n    observe('.js-notification-focus-list', () => {\n      this.setupPaginationObserver()\n    })\n\n    // We need to catch when pjax navigation is finished successfully,\n    // so we update focused notification in the list.\n    // eslint-disable-next-line delegated-events/global-on\n    on('pjax:end', '#js-repo-pjax-container', () => {\n      this.toggleCurrentFocusedNotification()\n    })\n  }\n\n  disconnectedCallback() {\n    this.disconnectCurrentObserver()\n  }\n\n  deactivateNavigation() {\n    pop(this.container)\n  }\n\n  activateNavigation() {\n    push(this.container)\n  }\n\n  replaceContent(listFragment: DocumentFragment) {\n    this.container.innerHTML = ''\n    this.container.appendChild(listFragment)\n    this.setupPaginationObserver()\n  }\n\n  /* eslint-disable-next-line custom-elements/no-method-prefixed-with-on */\n  onRemoveItem(e: CustomEvent): void {\n    const notificationId = e.detail.notificationId\n    const currentFocus = getCurrentFocus(this.container, '.js-navigation-item.navigation-focus')\n\n    this.listElements\n      ?.find(item => item.notificationId === notificationId)\n      ?.closest('li')\n      ?.remove()\n\n    if (this.listElements.length === 0) {\n      this.blankSlate.hidden = false\n      this.list.hidden = true\n    } else {\n      restoreFocus(currentFocus, this.container)\n    }\n  }\n\n  private toggleCurrentFocusedNotification() {\n    for (const listItem of this.listElements) {\n      const isFocused = window.location.href.includes(listItem.url())\n      listItem.setFocusedState(isFocused)\n    }\n  }\n\n  private setupPaginationObserver() {\n    if (!!window.IntersectionObserver && this.nextPageItem) {\n      this.currentObserver = new IntersectionObserver(\n        (entries: IntersectionObserverEntry[]) => {\n          if (!entries[0].isIntersecting) {\n            return\n          }\n\n          this.disconnectCurrentObserver()\n          this.loadNextPage()\n        },\n        {\n          root: this.container,\n          threshold: 0\n        }\n      )\n      this.currentObserver.observe(this.nextPageItem)\n    }\n  }\n\n  private async loadNextPage() {\n    if (!this.nextPageItem) {\n      return\n    }\n\n    const nextPageUrl = this.nextPageItem.getAttribute('data-next-page-url')\n    if (nextPageUrl) {\n      this.nextPageItemSpinner.hidden = false\n      const nextPage = await fetchSafeDocumentFragment(document, nextPageUrl)\n\n      this.nextPageItem.remove()\n\n      const liNotificationItems = nextPage.querySelectorAll('ul > li.focus-notification-item')\n      for (const node of liNotificationItems) {\n        this.list.appendChild(node)\n      }\n\n      const receivedNextPageItem = nextPage.querySelector('ul > li.focus-pagination-next-item')\n      if (receivedNextPageItem) {\n        this.list.appendChild(receivedNextPageItem)\n      }\n\n      // after new notifications + next page item were attached to\n      // the page we can re-subscribe to intersection observer\n      this.setupPaginationObserver()\n    }\n  }\n\n  private disconnectCurrentObserver() {\n    if (this.currentObserver) {\n      this.currentObserver.disconnect()\n    }\n  }\n}\n","import {attr, controller, target} from '@github/catalyst'\nimport {isShortcutAllowed} from '../../behaviors/keyboard-shortcuts-helper'\n@controller\nexport class NotificationFocusListItemElement extends HTMLElement {\n  @attr notificationId = ''\n  @attr isUnread = false\n\n  @target doneForm: HTMLFormElement\n  @target unsubscribeForm: HTMLFormElement\n  @target notificationLink: HTMLLinkElement\n  @target notificationTitle: HTMLElement\n\n  connectedCallback() {\n    this.closest('.js-navigation-item')?.addEventListener('navigation:keydown', this.handleCustomKeybindings.bind(this))\n    this.closest('.js-navigation-item')?.addEventListener('navigation:keyopen', this.handleKeyOpen.bind(this))\n  }\n\n  url() {\n    return this.notificationLink?.href\n  }\n\n  handleCustomKeybindings(event: Event) {\n    const detail = (event as CustomEvent).detail\n    if (!isShortcutAllowed(detail.originalEvent)) return\n\n    if (detail.hotkey === 'e') {\n      this.doneForm.dispatchEvent(new Event('submit'))\n    } else if (detail.hotkey === 'M') {\n      this.unsubscribeForm.dispatchEvent(new Event('submit'))\n    }\n  }\n\n  handleKeyOpen() {\n    this.notificationLink.dispatchEvent(\n      new MouseEvent('click', {\n        bubbles: true,\n        cancelable: true\n      })\n    )\n  }\n\n  setFocusedState(focused: boolean) {\n    // if we're focused on notification item, we need to mark item as read\n    if (focused && this.isUnread) {\n      this.isUnread = false\n      this.closest('.js-navigation-item')?.classList.remove('color-bg-default')\n      this.closest('.js-navigation-item')?.classList.add('color-bg-subtle')\n    }\n\n    this.closest('.js-navigation-item')?.classList.toggle('current-focused-item', focused)\n    this.notificationTitle.classList.toggle('text-bold', focused || this.isUnread)\n  }\n\n  async runRemoveAction(e: Event): Promise<void> {\n    e.preventDefault()\n\n    const form = e.currentTarget as HTMLFormElement\n    const body = new FormData(form)\n    const method = form.method\n    const url = form.action\n    const {ok} = await fetch(url, {body, method})\n\n    if (ok) {\n      this.dispatchEvent(\n        new CustomEvent('focus-mode-remove-item', {\n          bubbles: true,\n          detail: {notificationId: this.notificationId}\n        })\n      )\n    }\n  }\n}\n","import {controller, target} from '@github/catalyst'\nimport {NotificationFocusFiltersElement} from './notification-focus-filters-element'\nimport {NotificationFocusListElement} from './notification-focus-list-element'\nimport {fetchSafeDocumentFragment} from '../../fetch'\n\n@controller\nclass NotificationFocusSidebarElement extends HTMLElement {\n  @target sidebar: HTMLElement\n  @target listElement: NotificationFocusListElement\n  @target filtersElement: NotificationFocusFiltersElement\n\n  connectedCallback() {\n    this.addEventListener('notification-focus:toggle-sidebar', this.toggleSidebar.bind(this), true)\n\n    const isActive = window.localStorage.getItem('focus-sidebar-active') === 'true'\n    if (isActive) {\n      this.toggleSidebar()\n    }\n  }\n\n  toggleSidebar(): void {\n    this.adjustSidebarPosition()\n\n    if (this.sidebar.classList.contains('active')) {\n      this.listElement.deactivateNavigation()\n      this.sidebar.classList.remove('active')\n      window.localStorage.removeItem('focus-sidebar-active')\n    } else {\n      this.listElement.activateNavigation()\n      this.sidebar.classList.add('active')\n      window.localStorage.setItem('focus-sidebar-active', 'true')\n    }\n  }\n\n  /* eslint-disable-next-line custom-elements/no-method-prefixed-with-on */\n  async onFocusFilterChange(e: Event) {\n    const detail = (e as CustomEvent).detail\n    if (detail.url) {\n      this.listElement.deactivateNavigation()\n      const html = await fetchSafeDocumentFragment(document, detail.url)\n      this.listElement.replaceContent(html)\n      this.listElement.activateNavigation()\n    }\n  }\n\n  private adjustSidebarPosition() {\n    const banner = document.querySelector('header[role=banner]') as HTMLElement\n    if (banner) {\n      const topMargin = banner.offsetTop + banner.offsetHeight\n      this.sidebar.style.top = `${topMargin - 10}px`\n    }\n  }\n}\n","import {\n  NotificationsDialogLabelItemElement,\n  NotificationsDialogLabelToggledEvent\n} from './notifications-subscriptions-dialog-label-item'\nimport {controller, target, targets} from '@github/catalyst'\nimport {hideGlobalError, showGlobalError} from '../behaviors/ajax-error'\nimport type DetailsDialogElement from '@github/details-dialog-element'\nimport DetailsMenuElement from '@github/details-menu-element'\nimport {changeValue} from '../form'\n\n@controller\nclass NotificationsListSubscriptionFormElement extends HTMLElement {\n  @target details: HTMLDetailsElement\n  @target menu: DetailsMenuElement\n  @target customButton: HTMLButtonElement\n  @target customDialog: DetailsDialogElement\n  @target filterLabelsDialog: DetailsDialogElement\n  @targets subscriptionButtons: HTMLButtonElement[]\n  @targets subscriptionsLabels: HTMLElement[]\n  @target labelInputs: HTMLElement\n  @target subscriptionsSubtitle: HTMLElement\n  @target socialCount: HTMLElement\n  @target unwatchButtonCopy: HTMLElement\n  @target stopIgnoringButtonCopy: HTMLElement\n  @target watchButtonCopy: HTMLElement\n  @targets threadTypeCheckboxes: HTMLInputElement[]\n  @target customSubmit: HTMLButtonElement\n  @target subscriptionsContainer: HTMLElement\n  @targets dialogLabelItems: NotificationsDialogLabelItemElement[]\n\n  lastAppliedLabels: {[labelId: string]: Node} = {}\n\n  connectedCallback() {\n    /* eslint-disable-next-line custom-elements/no-dom-traversal-in-connectedcallback */\n    const el = this.querySelector<HTMLElement>('.js-label-subscriptions-load')\n\n    el?.addEventListener('loadend', () => {\n      if (this.subscriptionsLabels.length > 0) {\n        this.updateCheckedState('custom')\n        this.updateMenuButtonCopy('custom')\n      }\n    })\n  }\n\n  async submitCustomForm(e: Event) {\n    await this.submitForm(e)\n    this.closeMenu()\n  }\n\n  async submitForm(e: Event) {\n    e.preventDefault()\n\n    hideGlobalError()\n\n    const form = e.currentTarget as HTMLFormElement\n    const body = new FormData(form)\n\n    const response = await self.fetch(form.action, {\n      method: form.method,\n      body,\n      headers: {\n        'X-Requested-With': 'XMLHttpRequest',\n        Accept: 'application/json'\n      }\n    })\n\n    if (!response.ok) {\n      showGlobalError()\n      return\n    }\n    const json = await response.json()\n\n    const doParam = body.get('do')\n    if (typeof doParam === 'string') this.updateCheckedState(doParam)\n    if (typeof doParam === 'string') this.updateMenuButtonCopy(doParam)\n    this.updateSocialCount(json.count)\n    this.applyInputsCheckedPropertiesToAttributesForNextFormReset()\n  }\n\n  updateMenuButtonCopy(subscription: string) {\n    this.unwatchButtonCopy.hidden = !(subscription === 'subscribed' || subscription === 'custom')\n    this.stopIgnoringButtonCopy.hidden = !(subscription === 'ignore')\n    this.watchButtonCopy.hidden = !(\n      subscription !== 'subscribed' &&\n      subscription !== 'custom' &&\n      subscription !== 'ignore'\n    )\n  }\n\n  // form.reset() will reset the form back to the values in it's html attributes, not to it's current JS properties\n  // therefore, after successfully saving the form to the server, we transfer value of the `.checked` properties\n  // of the inputs in the form into the `[checked]` attribute. This means that if the user reopens the form and\n  // edits it again, cancelling will reset the form to it's last saved state, not the original state on page load\n  applyInputsCheckedPropertiesToAttributesForNextFormReset() {\n    for (const input of [...this.threadTypeCheckboxes]) {\n      input.toggleAttribute('checked', input.checked)\n    }\n  }\n\n  updateCheckedState(doParam: string) {\n    for (const button of this.subscriptionButtons) {\n      button.setAttribute('aria-checked', button.value === doParam ? 'true' : 'false')\n    }\n\n    if (doParam === 'custom') {\n      this.customButton.setAttribute('aria-checked', 'true')\n    } else {\n      this.customButton.setAttribute('aria-checked', 'false')\n\n      for (const input of [...this.threadTypeCheckboxes]) {\n        changeValue(input, false)\n      }\n      // Clean up labels\n      if (this.subscriptionsContainer !== undefined) {\n        for (let i = 0; i < this.subscriptionsLabels.length; i++) {\n          this.subscriptionsLabels[i].remove()\n        }\n\n        if (this.subscriptionsSubtitle !== undefined) {\n          this.subscriptionsSubtitle.toggleAttribute('hidden', false)\n        }\n\n        this.subscriptionsContainer.innerHTML = ''\n      }\n    }\n  }\n\n  updateSocialCount(count: string) {\n    if (this.socialCount) {\n      this.socialCount.textContent = count\n      this.socialCount.setAttribute('aria-label', `${this.pluralizeUsers(count)} watching this repository`)\n    }\n  }\n\n  pluralizeUsers(userCount: string) {\n    return parseInt(userCount) === 1 ? '1 user is' : `${userCount} users are`\n  }\n\n  handleDialogLabelToggle(e: CustomEvent<NotificationsDialogLabelToggledEvent>) {\n    // change aria-checked attribute for the selected label\n    // to make item appear selected/unselected depending on the current state\n    const wasChecked = e.detail.wasChecked\n    const labelId = e.detail.toggledLabelId\n    const templateLabelElementClone = e.detail.templateLabelElementClone\n\n    // add/remove selected label from the list of selected labels\n    if (wasChecked) {\n      // if label was checked previously and is now unchecked, remove label from subscribed labels list\n      for (let i = 0; i < this.subscriptionsLabels.length; i++) {\n        if (this.subscriptionsLabels[i].getAttribute('data-label-id') === labelId) {\n          this.subscriptionsLabels[i].remove()\n          break\n        }\n      }\n    } else {\n      templateLabelElementClone.removeAttribute('hidden')\n      templateLabelElementClone.setAttribute('data-targets', 'notifications-list-subscription-form.subscriptionsLabels')\n\n      this.subscriptionsContainer.appendChild(templateLabelElementClone)\n    }\n  }\n\n  openCustomDialog(e: Event) {\n    e.preventDefault()\n    e.stopPropagation()\n    this.menu.toggleAttribute('hidden', true)\n    this.enableApplyButtonAndCheckbox()\n    this.saveCurrentLabelsState()\n    this.customDialog.toggleAttribute('hidden', false)\n    setTimeout(() => {\n      this.customDialog.querySelector<HTMLInputElement>('input[type=checkbox][autofocus]')?.focus()\n    }, 0)\n  }\n\n  enableApplyButtonAndCheckbox() {\n    const visibleLabels = this.customDialog.querySelectorAll<HTMLElement>('[data-type=\"label\"]:not([hidden])')\n\n    if (visibleLabels.length > 0) {\n      this.customSubmit.removeAttribute('disabled')\n      this.threadTypeCheckboxes[0].checked = true\n    }\n  }\n\n  closeCustomDialog(e: Event) {\n    e.preventDefault()\n    e.stopPropagation()\n    this.menu.toggleAttribute('hidden', false)\n    this.customDialog.toggleAttribute('hidden', true)\n    setTimeout(() => {\n      this.customButton.focus()\n    }, 0)\n  }\n\n  // Apply the previous state of labels selected\n  resetFilterLabelsDialog(e: Event) {\n    e.preventDefault()\n    e.stopPropagation()\n\n    // remove checkboxes from the dialog\n    for (let idx = 0; idx < this.subscriptionsLabels.length; idx++) {\n      const labelId = this.subscriptionsLabels[idx].getAttribute('data-label-id')\n\n      // this is up to O(n^2) but is an im memorty alternative for dom queries, which should be faster\n      for (let i = 0; i < this.dialogLabelItems.length; i++) {\n        if (this.dialogLabelItems[i].labelId === labelId) {\n          this.dialogLabelItems[i].setCheckedForDropdownLabel(false)\n          break\n        }\n      }\n    }\n\n    // add checkboxes to dialog based on last applied labels\n    for (let idx = 0; idx < Object.keys(this.lastAppliedLabels).length; idx++) {\n      const labelId = Object.keys(this.lastAppliedLabels)[idx]\n\n      // this is up to O(n^2) but is an im memorty alternative for dom queries, which should be faster\n      for (let i = 0; i < this.dialogLabelItems.length; i++) {\n        if (this.dialogLabelItems[i].labelId === labelId) {\n          this.dialogLabelItems[i].setCheckedForDropdownLabel(true)\n          break\n        }\n      }\n    }\n\n    this.subscriptionsContainer.replaceChildren(...Object.values(this.lastAppliedLabels))\n    this.closeFilterLabelsDialog(e)\n  }\n\n  openFilterLabelsDialog(e: Event) {\n    e.preventDefault()\n    e.stopPropagation()\n\n    this.saveCurrentLabelsState()\n    this.customDialog.toggleAttribute('hidden', true)\n    this.filterLabelsDialog.toggleAttribute('hidden', false)\n    setTimeout(() => {\n      this.filterLabelsDialog.querySelector<HTMLInputElement>('input[type=checkbox][autofocus]')?.focus()\n    }, 0)\n  }\n\n  closeFilterLabelsDialog(e: Event) {\n    e.preventDefault()\n    e.stopPropagation()\n\n    this.menu.toggleAttribute('hidden', true)\n    this.customDialog.toggleAttribute('hidden', false)\n    this.filterLabelsDialog.toggleAttribute('hidden', true)\n  }\n\n  // Apply changes from labels filter\n  applyFilterLabelsDialog(e: Event) {\n    e.preventDefault()\n    e.stopPropagation()\n\n    this.saveCurrentLabelsState()\n\n    this.hideFilterSubtitle()\n    this.enableIssuesCheckbox()\n    this.closeFilterLabelsDialog(e)\n  }\n\n  enableIssuesCheckbox() {\n    const enableCheckbox = Object.keys(this.lastAppliedLabels).length > 0\n\n    if (enableCheckbox && this.threadTypeCheckboxes.length > 0) {\n      this.threadTypeCheckboxes[0].checked = enableCheckbox\n    }\n\n    this.threadTypeCheckboxesUpdated()\n  }\n\n  hideFilterSubtitle() {\n    const hideSubtitle = Object.keys(this.lastAppliedLabels).length > 0\n    this.subscriptionsSubtitle.toggleAttribute('hidden', hideSubtitle)\n  }\n\n  // Save the selected labels and save label ids in inputs\n  saveCurrentLabelsState() {\n    this.lastAppliedLabels = {}\n    this.labelInputs.innerHTML = ''\n\n    for (let i = 0; i < this.subscriptionsLabels.length; i++) {\n      const labelId = this.subscriptionsLabels[i].getAttribute('data-label-id')\n      if (labelId) {\n        this.lastAppliedLabels[labelId] = this.subscriptionsLabels[i].cloneNode(true)\n        this.appendLabelToFormInput(labelId)\n      }\n    }\n  }\n\n  appendLabelToFormInput(value: string) {\n    // create input in memory to append it to the form element\n    const input = document.createElement('input')\n    input.setAttribute('type', 'hidden')\n    input.setAttribute('name', 'labels[]')\n    input.setAttribute('value', value)\n\n    this.labelInputs.appendChild(input)\n  }\n\n  detailsToggled() {\n    this.menu.toggleAttribute('hidden', false)\n    this.customDialog.toggleAttribute('hidden', true)\n  }\n\n  submitCustom(e: Event) {\n    e.preventDefault()\n    this.details.toggleAttribute('open', false)\n  }\n\n  threadTypeCheckboxesUpdated() {\n    const noneSelected = !this.threadTypeCheckboxes.some(input => input.checked)\n\n    this.customSubmit.disabled = noneSelected\n  }\n\n  closeMenu() {\n    this.details.toggleAttribute('open', false)\n  }\n}\n","import {controller, target} from '@github/catalyst'\n@controller\nclass NotificationsTeamSubscriptionFormElement extends HTMLElement {\n  @target details: HTMLDetailsElement\n\n  closeMenu() {\n    this.details.toggleAttribute('open', false)\n  }\n}\n","import {attr, controller, target} from '@github/catalyst'\n\nexport interface NotificationsDialogLabelToggledEvent {\n  wasChecked: boolean\n  toggledLabelId: string\n  templateLabelElementClone: HTMLElement\n}\n\n@controller\nexport class NotificationsDialogLabelItemElement extends HTMLElement {\n  @target label: HTMLElement\n  @target hiddenLabelTemplate: HTMLElement\n  @target hiddenCheckboxInput: HTMLInputElement\n\n  @attr labelId: string\n\n  toggleDropdownLabel(e: Event) {\n    e.preventDefault()\n    e.stopPropagation()\n\n    if (this.label) {\n      // change aria-checked attribute for the selected label\n      const wasChecked = this.label.getAttribute('aria-checked') === 'true'\n\n      this.setCheckedForDropdownLabel(!wasChecked)\n\n      this.dispatchEvent(\n        new CustomEvent<NotificationsDialogLabelToggledEvent>('notifications-dialog-label-toggled', {\n          detail: {\n            wasChecked,\n            toggledLabelId: this.labelId,\n            templateLabelElementClone: this.hiddenLabelTemplate.cloneNode(true) as HTMLElement\n          },\n          bubbles: true\n        })\n      )\n    }\n  }\n\n  setCheckedForDropdownLabel(checked: boolean) {\n    this.label.setAttribute('aria-checked', checked.toString())\n  }\n}\n"],"sourceRoot":""}