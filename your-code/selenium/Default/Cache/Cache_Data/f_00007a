{"version":3,"sources":["app/assets/modules/github/behaviors/ajax-error.ts","app/assets/modules/github/behaviors/keyboard-shortcuts-helper.ts","app/assets/modules/github/behaviors/task-list.ts","app/assets/modules/github/details-dialog.ts","app/assets/modules/github/fetch.ts","app/assets/modules/github/form.ts","app/assets/modules/github/has-interactions.ts","app/assets/modules/github/html-safe.ts","app/assets/modules/github/onfocus.ts","app/assets/modules/github/remote-submit.ts","app/assets/modules/github/safe-storage.ts","app/assets/modules/github/sso.ts","app/assets/modules/github/subscription.ts"],"names":[],"mappings":"gOAOO,YAA2B,CAChC,KAAM,GAAmB,SAAS,eAAe,sBAC7C,GACF,GAAiB,OAAS,IAHd,uBAOT,YAA2B,CAChC,KAAM,GAAmB,SAAS,eAAe,sBAC7C,GACF,GAAiB,OAAS,IAHd,uBAOhB,SAAG,sBAAuB,gBAAiB,SAAU,EAAO,CAC1D,KAAM,GAAU,EAAsB,OAChC,CAAC,QAAO,QAAQ,EAElB,EAAM,gBAAkB,EAAM,QAG9B,KAAU,SAAW,IAAU,YAInC,CAAI,QAAQ,KAAK,GACf,KACA,EAAM,4BAEN,WAAW,UAAY,CACjB,EAAM,kBAGV,KACC,OAKP,SAAG,qBAAsB,gBAAiB,UAAY,CACpD,MAIF,SAAG,QAAS,yBAA0B,UAAY,CAChD,O,mECjDK,KAAM,GAAkC,MAAM,CACnD,KAAM,GAA8B,SAAS,cAC3C,4CAEF,MAAI,GACK,EAA4B,UAAY,MAE1C,IAPsC,mCAclC,EAA4B,EAAC,GACjC,sCAAsC,KAAK,IAAY,EAAO,SAAS,QAAU,EAAO,SAAS,SADjE,6BAK5B,EAAoB,EAAC,GAAyB,CACzD,KAAM,GAAS,SAAoB,GACnC,MAAI,KACK,GAEF,EAA0B,IALF,sB,iHCwCjC,SAAQ,8CAA+C,SAAU,EAAI,CACnE,KAAM,GAAY,EAAG,QAAqB,2BAC1C,EAAe,GACf,EAAe,KAGjB,SAAG,kBAAmB,aAAc,SAAU,EAAO,CACnD,KAAM,CAAC,MAAK,OAAO,EAAM,OACnB,EAAY,EAAM,cAAc,QAAqB,2BAC3D,EAAa,EAAW,YAAa,CAAC,UAAW,OAAQ,MAAK,UAGhE,SAAG,mBAAoB,aAAc,SAAU,EAAO,CACpD,KAAM,CAAC,WAAU,WAAW,EAAM,OAC5B,EAAY,EAAM,cAAc,QAAqB,2BAC3D,EAAa,EAAW,WAAW,EAAU,EAAI,IAAK,CAAC,UAAW,QAAS,WAAU,cAGhF,WAAwB,EAAoB,CACjD,GAAI,EAAU,cAAc,uBAAwB,CAClD,KAAM,GAAY,EAAU,iBAAiB,cAC7C,SAAW,KAAM,GACf,GAAI,YAAc,KAAkB,CAClC,EAAG,SAAW,GACd,KAAM,GAAU,EAAG,iBAAiB,UACpC,SAAW,KAAU,GACnB,EAAO,SAAW,KARZ,sBAeT,WAAyB,EAAoB,CAClD,SAAW,KAAM,GAAU,iBAAiB,cAC1C,GAAI,YAAc,KAAkB,CAClC,EAAG,SAAW,GAEd,KAAM,GAAU,EAAG,iBAAiB,UACpC,SAAW,KAAU,GACnB,EAAO,SAAW,IAPV,uBAiBhB,WAAsB,EAAoB,EAAe,EAAqC,CAC5F,KAAM,GAAO,EAAU,cAA+B,sBAEtD,EAAgB,GAChB,EAAe,GAEf,KAAM,GAAmB,EAAK,SAAS,UAAU,mBAC7C,YAA4B,UAAS,EAAiB,SAE1D,KAAM,GAAoB,EAAK,SAAS,UAAU,uBAC9C,YAA6B,UAAS,EAAkB,SAE5D,KAAM,GAAW,SAAS,cAAc,SACxC,EAAS,aAAa,OAAQ,UAC9B,EAAS,aAAa,OAAQ,mBAC9B,EAAS,aAAa,QAAS,GAC/B,EAAK,YAAY,GAEjB,KAAM,GAAY,SAAS,cAAc,SAMzC,GALA,EAAU,aAAa,OAAQ,UAC/B,EAAU,aAAa,OAAQ,uBAC/B,EAAU,aAAa,QAAS,KAAK,UAAU,IAC/C,EAAK,YAAY,GAEb,CAAC,EAAK,SAAS,UAAU,iBAAkB,CAG7C,KAAM,GAAQ,EAFK,cAAc,uBACd,aAAa,QACb,MAAM,KAAK,GACxB,EAAQ,SAAS,cAAc,SACrC,EAAM,aAAa,OAAQ,UAC3B,EAAM,aAAa,OAAQ,iBAC3B,EAAM,aAAa,QAAS,GAC5B,EAAK,YAAY,GAInB,EAAU,UAAU,OAAO,oBAE3B,SAAc,GAtCP,oBAyCT,SAAW,6CAA8C,eAAgB,EAAM,EAAO,CACpF,KAAM,GAAY,EAAK,QAAQ,2BACzB,EAAW,EAAK,SAAS,UAAU,mBACrC,YAAoB,UAAS,EAAS,SAE1C,KAAM,GAAY,EAAK,SAAS,UAAU,uBACtC,YAAqB,UAAS,EAAU,SAE5C,GAAI,GACJ,GAAI,CACF,EAAW,KAAM,GAAM,aAChB,EADgB,CAEvB,GAAI,GACJ,GAAI,CACF,EAAO,KAAK,MAAM,EAAM,SAAS,aAKnC,GAAI,GAAQ,EAAK,MAAO,CACtB,KAAM,GAAe,EAAU,cAAmC,uBAKlE,EAAa,UAAU,IAAI,8BAC3B,EAAa,UAAU,OAAO,4BACrB,GAAM,SAAS,SAAW,KAGnC,OAAO,SAAS,SAIhB,GACE,IAEE,EAAS,KAAK,QAChB,GAAU,cAAmC,uBAAwB,MAAQ,EAAS,KAAK,QAG/F,EAAe,GACf,sBAAsB,IAAM,EAAe,OAO/C,GAAI,GAAqB,GAKrB,EAAe,GAIf,EAAoC,KAGxC,WAAsC,EAAW,CAI/C,EADwB,YAAc,kBAIpC,EAAqB,GAFrB,EAAqB,GALhB,oCAYT,WAA6B,EAAW,CACtC,KAAM,GAAQ,EAGd,GAAI,CAAC,GAIC,CADc,GAAM,YAAc,mBACtB,OAGlB,KAAM,GAAU,EAAM,OACtB,EAAiB,GACjB,EAAqB,GAbd,2BAgBT,WAA0B,EAA2B,CACnD,KAAM,GAAS,EAAkB,EAAQ,MAAO,CAAC,EAAQ,eAAgB,EAAQ,eAC7E,IAAW,QAEf,EAAkB,EAAS,GAJpB,wBAOT,WAA2B,EAA2B,EAA0B,CAC9E,GAAI,IAAsB,MAAQ,IAAsB,GAAM,CAC5D,EAAQ,gBAAkB,OAC1B,GAAI,CACF,EAAqB,GACrB,GAAI,GACA,EAAY,YAAc,EAAQ,WACpC,GAAQ,EAAY,mBAEhB,EAAY,eAAe,KAAO,MAAQ,EAAY,eAAe,KAAO,MAC9E,GAAQ,eAAiB,EAAY,eAAe,GACpD,EAAQ,aAAe,EAAY,eAAe,KAIpD,EAAQ,eAAiB,EAAY,UAAU,GAEjD,EAAoB,SAAS,YAAY,EAAY,UAAW,GAAO,SAEvE,EAAoB,GAEtB,EAAQ,gBAAkB,QAG5B,GAAI,CAAC,EAAmB,CACtB,GAAI,CACF,SAAS,YAAY,2BAIvB,EAAQ,MAAQ,EAAY,KAC5B,GAAI,CACF,SAAS,YAAY,yBAIvB,EAAQ,cAAc,GAAI,aAAY,QAAS,CAAC,QAAS,GAAM,WAAY,MAGzE,EAAY,UAAU,IAAM,MAAQ,EAAY,UAAU,IAAM,MAClE,GAAQ,eAAiB,EAAY,UAAU,GAC/C,EAAQ,aAAe,EAAY,UAAU,IAzCxC,yBA6CT,WAA0B,EAAW,CAInC,GAAI,EACF,OAGF,KAAM,GAAQ,EAEd,GAAI,EAAM,MAAQ,SAAW,EAAM,UAAY,CAAC,EAAM,QAAS,CAC7D,KAAM,GAAU,EAAM,OAEhB,EAAS,EAAe,EAAQ,MAAO,CAAC,EAAQ,eAAgB,EAAQ,eAC9E,GAAI,IAAW,OAAW,OAE1B,EAAkB,EAAS,GAE3B,EAAM,iBAEN,QAAK,EAAS,WApBT,wBAyBT,YAA8B,CAC5B,EAAe,GADR,0BAIT,YAA4B,CAC1B,EAAe,GADR,wBAIT,WAA2B,EAAW,CAIpC,GAAI,EACF,OAGF,KAAM,GAAQ,EACd,GAAI,EAAM,MAAQ,SAAU,CAC1B,GAAa,GACb,OAGF,GAAI,EAAM,MAAQ,MAAO,OAEzB,KAAM,GAAU,EAAM,OAEhB,EAAS,EAAO,EAAQ,MAAO,CAAC,EAAQ,eAAgB,EAAQ,cAAe,EAAM,UACvF,IAAW,QAEf,GAAM,iBAEN,EAAkB,EAAS,IAvBpB,yBA0BT,SAAQ,sBAAuB,CAC7B,UAAW,GACT,SACE,SAAU,EAAI,UAAW,GACzB,SAAU,EAAI,UAAW,GACzB,SAAU,EAAI,cAAe,GAC7B,SAAU,EAAI,QAAS,GACvB,SAAU,EAAI,mBAAoB,GAClC,SAAU,EAAI,iBAAkB,MAKtC,GAAK,GAAL,CAAK,GACH,cAAa,aACb,SAAS,SAFN,WAeL,KAAM,GAAiB,UAChB,WAAwB,EAAc,EAAoD,CAC/F,KAAM,GAAS,EAAU,GACzB,GAAI,CAAC,GAAU,CAAC,EAAM,OAEtB,KAAM,GAAQ,EAAK,UAAU,EAAG,GAAQ,MAAM;AAAA,GACxC,EAAc,EAAM,EAAM,OAAS,GACnC,EAAQ,iBAAa,MAAM,GACjC,GAAI,CAAC,EAAO,OAGZ,KAAM,GAAqB;AAAA,EADP,EAAM,IAAM,KAEhC,MAAO,CACL,KAAM,EAAK,UAAU,EAAG,GAAU,EAAqB,EAAK,UAAU,GACtE,qBACA,UAAW,CAAC,EAAS,EAAmB,OAAQ,EAAS,EAAmB,QAC5E,UAAW,aACX,eAAgB,CAAC,KAAM,OAhBX,sBAqBhB,KAAM,GAAe,uCAErB,WAAsC,EAAc,EAA+B,CACjF,GAAI,GAAQ,EAAK,MAAM;AAAA,GAEvB,SAAQ,EAAM,IAAI,GAAQ,CAExB,GAAI,EAAK,QAAQ,OAAQ,IAAI,WAAW,GAAG,MAAmB,CAC5D,KAAM,GAAS,EAAK,QAAQ,GAAG,IAAiB,GAAG,EAAgB,KACnE,UAAiB,EACV,EAET,MAAO,KAGF,EAAM,KAAK;AAAA,GAbX,oCAgBF,WAA2B,EAAc,EAAoD,CAClG,KAAM,GAAS,EAAU,GACzB,GAAI,CAAC,GAAU,CAAC,EAAM,OAEtB,KAAM,GAAQ,EAAK,UAAU,EAAG,GAAQ,MAAM;AAAA,GACxC,EAAe,EAAM,EAAM,OAAS,GAGpC,EAAQ,iBAAc,MAAM,GAClC,GAAI,CAAC,EAAO,OAEZ,KAAM,GAAa,EAAM,GACnB,EAAc,EAAM,GACpB,EAAS,EAAM,GACf,EAAgB,SAAS,EAAM,GAAI,IACnC,EAAc,QAAQ,EAAM,IAC5B,EAAkB,CAAC,MAAM,GAE/B,GAAI,GAAY,GADE,EAAkB,GAAG,EAAgB,KAAO,KAC9B,EAAc,OAAS,KAEnD,EAAiB,EAAK,QAAQ;AAAA,EAAM,GACpC,EAAiB,GACnB,GAAiB,EAAK,QAExB,KAAM,GAAc,EAAK,UAAU,EAAQ,GAkB3C,GAhBI,EAAY,WAAW,IACzB,GAAY,IAca,EAAa,QAAQ,EAAY,IAAI,OAAO,OAAS,GAAK,EAAY,OAAO,OAAS,EACzF,CACtB,GAAI,GAAqB,GAAG,IAAc,IACtC,EAAsB,EAAK,UAAU,GACzC,KAAM,GAA2B,EAAmB,OAEpD,GAAI,GAAiB,CAAC,KAAM,MAC5B,KAAM,IAAkB,SACxB,GAAI,GAAa,EAAK,UAAU,EAAG,GAAU,EAAqB,EAElE,MAAI,IAAmB,CAAC,EAAK,UAAU,GAAQ,MAAM,KACnD,GAAsB,EAA6B,EAAK,UAAU,GAAS,EAAgB,GAC3F,GAAsB,EACtB,EAAiB,CAAC,EAAQ,EAAS,EAAmB,QACtD,EAAa,EAAK,UAAU,EAAG,GAAU,GAGpC,CACL,KAAM,EACN,qBACA,UAAW,CAAC,EAAS,EAA0B,EAAS,GACxD,UAAW,aACX,sBAEG,CAEL,KAAM,GAAsB,EAAS;AAAA,EAAK,IAAa,OACvD,MAAO,CACL,mBAAoB,GACpB,KAAM,EAAK,UAAU,EAAG,GAAuB,EAAK,UAAU,GAC9D,UAAW,CAAC,EAAqB,GACjC,UAAW,SACX,eAAgB,CAAC,KAAM,QAzEb,yBA8ET,WAAgB,EAAc,EAA2B,EAA6C,CAE3G,KAAM,GAAiB,EAAU,IAAM,EACjC,EAAe,EAAU,IAAM,EACrC,GAAI,EAAU,KAAO,MAAQ,IAAmB,EAAc,OAE9D,KAAM,GAAc,EAAK,UAAU,EAAG,GAAgB,YAAY;AAAA,GAAQ,EACpE,EAA4B,EAAK,QAAQ;AAAA,EAAM,EAAe,GAC9D,EAAY,EAA4B,EAAI,EAA4B,EAAK,OAAS,EACtF,EAAgB,EAAK,UAAU,EAAa,GAAW,MAAM;AAAA,GAEnE,GAAI,GAAe,GACf,EAAqB,EACrB,EAAmB,EACvB,KAAM,GAAiC,GACvC,SAAW,KAAQ,GAAe,CAChC,KAAM,GAAQ,EAAK,MAAM,QACzB,GAAI,EAAO,CACT,GAAI,GAAc,EAAM,GACxB,KAAM,GAAW,EAAK,UAAU,EAAY,QAC5C,GAAI,EAAW,CACb,KAAM,GAAa,EAAY,OAC/B,EAAc,EAAY,MAAM,EAAG,IAGnC,EAAqB,EAAe,EAAqB,EAAY,OAAS,EAC9E,EAAe,GACf,GAAoB,EAAY,OAAS,MAEzC,IAAe,KACf,EAAqB,EACrB,GAAoB,EAEtB,EAAqB,KAAK,EAAc,IAI5C,KAAM,GAAc,EAAqB,KAAK;AAAA,GACxC,EAAU,EAAK,UAAU,EAAG,GAAe,EAAc,EAAK,UAAU,GACxE,EAA2B,CAC/B,KAAK,IAAI,EAAa,EAAiB,GACvC,EAAe,GAEjB,MAAO,CACL,KAAM,EACN,UAAW,EACX,mBAAoB,EACpB,UAAW,aACX,eAAgB,CAAC,EAAa,IAhDlB,cAoDhB,YAAsB,EAAW,CAE/B,KAAM,GAAU,EAAM,OAClB,EAAQ,qBAAuB,WACjC,EAAQ,aAAe,EAAQ,eAE/B,EAAQ,eAAiB,EAAQ,aAN5B,qBAUT,WAAwB,EAAoB,CAI1C,GAHI,SAAS,iBAAiB,2BAA2B,SAAW,GAE/C,EAAU,QAAqB,qBAClC,OAElB,KAAM,GAAa,EAAU,iBAAmC,oCAC1D,EAAQ,EAAW,OACnB,EAAY,MAAM,KAAK,GAAY,OAAO,GAAY,EAAS,SAAS,OACxE,EAAqB,SAAS,iBAAiB,gDACrD,SAAW,KAAY,GACrB,EAAS,aAAa,iBAAkB,OAAO,IAC/C,EAAS,aAAa,aAAc,OAAO,IAZtC,uB,gDCriBF,iBAAsB,EAAwC,CAEnE,KAAM,GAAgB,SADU,cAAmC,wBAC9B,QAAQ,UAAU,IACjD,EAAU,EAAc,cAA2B,WACnD,EAAgB,EAAQ,cAA2B,kBACnD,EAAU,EAAQ,cAA2B,8BAC/C,EAAQ,cAAc,EAAQ,UAAU,IAAI,GAAG,EAAQ,aAAa,MAAM,MAC1E,EAAQ,aAAa,EAAc,UAAU,IAAI,GAAG,EAAQ,YAAY,MAAM,MAE9E,EAAQ,MACV,EAAc,aAAa,aAAc,EAAQ,OACxC,EAAQ,YACjB,EAAc,aAAa,kBAAmB,EAAQ,YAGxD,SAAS,KAAK,OAAO,GAErB,KAAM,GAAU,KAAM,GAAQ,QAC9B,SAAQ,SACR,EAAc,QAAQ,GAEtB,EAAQ,iBAAiB,SAAU,IAAM,CACnC,EAAQ,aAAa,SACzB,C,GAAA,KAAK,EAAe,iBACpB,EAAQ,YAGH,EA3Ba,e,kECTf,iBACL,EACA,EACA,EAC2B,CAC3B,KAAM,GAAU,GAAI,SAAQ,EAAK,GACjC,EAAQ,QAAQ,OAAO,mBAAoB,kBAC3C,KAAM,GAAW,KAAM,MAAK,MAAM,GAClC,GAAI,EAAS,OAAS,KAAO,EAAS,QAAU,IAC9C,KAAM,IAAI,OAAM,QAAQ,EAAS,SAAS,EAAS,YAAc,MAEnE,cAA4B,QAA0B,GAAW,GAC1D,QAAU,EAAU,KAAM,GAAS,QAZtB,iCAef,WAAmB,EAAkB,EAAuB,EAAsB,IAAyB,CAChH,MAAQ,oBAAoB,EAAiC,CAC3D,KAAM,GAAU,GAAI,SAAQ,EAAK,GACjC,EAAQ,QAAQ,OAAO,mBAAoB,kBAC3C,KAAM,GAAW,KAAM,MAAK,MAAM,GAClC,GAAI,EAAS,OAAS,KAAO,EAAS,QAAU,IAC9C,KAAM,IAAI,OAAM,QAAQ,EAAS,SAAS,EAAS,YAAc,MAGnE,GAAI,EAAS,SAAW,IAAK,MAAO,GACpC,GAAI,EAAS,SAAW,IACtB,YAAM,IAAI,SAAQ,GAAW,WAAW,EAAS,IAC1C,EAAK,EAAO,KAErB,KAAM,IAAI,OAAM,cAAc,EAAS,8CAbjC,QAcL,GAfW,kB,oHCVhB,SAAG,QAAS,2BAA4B,eAAgB,EAAO,CAE7D,KAAM,GAAO,EADQ,cACD,KACpB,EAAM,iBACN,GAAI,GACJ,GAAI,CACF,EAAW,KAAM,OAAM,EAAK,OAAQ,CAClC,OAAQ,EAAK,OACb,KAAM,GAAI,UAAS,GACnB,QAAS,CACP,OAAQ,mBACR,mBAAoB,2BAMtB,GAAY,CAAC,EAAS,IACxB,YAIJ,WAAc,EAAqB,EAAc,EAA8B,CAC7E,MAAO,GAAO,cACZ,GAAI,aAAY,EAAM,CACpB,QAAS,GACT,gBAJG,YAgBF,WAAuB,EAAuB,EAAoB,CACnE,GACF,GAAoB,EAAM,GAC1B,QAAyB,IAEvB,EAAK,EAAM,SAAU,KACvB,EAAK,SANO,qBAYhB,WAA6B,EAAuB,EAAmB,CACrE,GAAI,CAAE,aAAgB,kBAAkB,KAAM,IAAI,WAAU,yDAC5D,GAAI,CAAE,aAAqB,cAAc,KAAM,IAAI,WAAU,qDAC7D,GAAI,EAAU,OAAS,SAAU,KAAM,IAAI,WAAU,iDACrD,GAAI,CAAC,GAAQ,IAAS,EAAU,KAAM,KAAM,IAAI,OAAM,2DAJ/C,2BAUF,WAAqB,EAAkB,EAAyB,CACrE,GAAI,MAAO,IAAU,UACnB,GAAI,YAAiB,kBACnB,EAAM,QAAU,MAEhB,MAAM,IAAI,WAAU,mDAEjB,CACL,GAAI,EAAM,OAAS,WACjB,KAAM,IAAI,WAAU,yCAEpB,EAAM,MAAQ,EAGlB,EAAK,EAAO,SAAU,IAdR,mBAkBT,WAAwB,EAAuB,EAAiC,CACrF,SAAW,KAAQ,GAAQ,CACzB,KAAM,GAAQ,EAAO,GACf,EAAU,EAAK,SAAS,UAAU,GAEpC,aAAmB,mBAEZ,YAAmB,uBAC5B,GAAQ,MAAQ,IARN,sBAcT,WAAqB,EAAwB,CAClD,GAAI,CAAE,aAAmB,cACvB,MAAO,GAGT,KAAM,GAAO,EAAQ,SAAS,cACxB,EAAQ,GAAQ,aAAa,SAAW,IAAI,cAClD,MACE,KAAS,UACT,IAAS,YACR,IAAS,SAAW,IAAS,UAAY,IAAS,SACnD,EAAQ,kBAXI,mBAehB,WAAkC,EAAqC,CAErE,MAAO,IAAI,iBAAgB,GAFpB,gCAMF,WAAoC,EAAiB,EAA4B,CACtF,KAAM,GAAkB,GAAI,iBAAgB,EAAW,QACjD,EAAyB,EAAyB,GACxD,SAAW,CAAC,EAAK,IAAU,GACzB,EAAgB,OAAO,EAAK,GAE9B,MAAO,GAAgB,WANT,kCAUT,WAAmB,EAA+B,CACvD,MAAO,GAAyB,GAAI,UAAS,IAAO,WADtC,kB,mEC1HT,WAAyB,EAAoB,EAAyB,GAAgB,CAC3F,MACE,GAAe,IACf,EAAS,EAAW,IACpB,EAAa,IACb,EAAc,GALF,uBAST,WAAwB,EAA6B,CAC1D,SAAW,KAAS,GAAU,iBAAiB,mBAC7C,GAAI,aAAiB,mBAAoB,YAAiB,uBACpD,EAAsB,GACxB,MAAO,GAIb,MAAO,GARO,sBAWhB,WAA+B,EAAwD,CACrF,GAAI,YAAiB,mBAAqB,GAAM,OAAS,YAAc,EAAM,OAAS,UACpF,GAAI,EAAM,UAAY,EAAM,eAAgB,MAAO,WAE/C,EAAM,QAAU,EAAM,aAAc,MAAO,GAEjD,MAAO,GANA,6BAST,GAAI,GAEG,iBAAiC,EAAkB,EAAkC,CAC1F,EAAuB,EACvB,GAAI,CACF,KAAM,aAEN,EAAuB,MALL,yBAStB,WAA0B,EAAoC,CAC5D,MAAI,aAAgC,SAC3B,EACE,GAAa,EAAU,eAAiB,EAAU,cAAc,cAClE,EAAU,cAAc,cAE1B,KANA,wBAST,GAAI,GAEJ,SAAS,iBAAiB,UAAW,SAAU,EAAc,CAC3D,EAAsB,EAAM,SAG9B,WAAkB,EAAoB,EAA0C,CAC9E,KAAM,GAAgB,EAAiB,GAEvC,MADI,KAAkB,MAClB,GAA0B,IAAkB,EAAkB,GAIzC,IAAkB,GAAa,SAAY,IAMtC,EAAU,SAAS,IAAkB,CAAC,EAAoB,GACtD,GAIhC,YAA+B,UAC/B,EAAU,SAAS,IACnB,CAAC,CAAC,EAAoB,QAAQ,2BApBzB,gBAwBT,KAAM,GAA+B,kBAErC,WAA6B,EAAiC,CA1F9D,MA2FE,GAAI,YAAyB,KAAsB,MAAO,GAE1D,KAAM,GAAiB,YAAyB,oBAAqB,YAAyB,mBACxF,EAAmB,KAAc,gBAAd,cAA6B,UAAU,SAAS,kBACzE,GAAI,GAAkB,EACpB,MAAO,GAGT,GAAI,CAAE,aAA+B,UAAU,MAAO,GACtD,KAAM,GAAyB,EAAc,QAAQ,GACrD,GAAI,CAAC,EAAwB,MAAO,GACpC,KAAM,GAA0B,EAAoB,QAAQ,GAC5D,MAAO,KAA2B,EAb3B,2BAgBT,WAAsB,EAA6B,CACjD,MAAO,GAAU,QAAQ,mBADlB,oBAIT,WAAuB,EAA6B,CAClD,MAAO,KAAU,QAAQ,cAAgB,EAAU,cAAc,cAD1D,sB,wCCzGF,WAAmC,EAA8B,CACtE,KAAM,GAAS,CAAC,GAAG,EAAS,iBAAkC,+BAA+B,IAAI,GAAQ,EAAK,SAE9G,GAAI,EAAO,OAAS,EAClB,KAAM,IAAI,OAAM,8CAElB,MAAO,GANO,iCAchB,eAA4B,MAAM,CAGhC,YAAY,EAAiB,EAAoB,CAC/C,MAAM,GAAG,cAAoB,EAAS,UACtC,KAAK,SAAW,GALpB,qBASO,WAAqC,EAAkB,EAAoB,EAAY,GAAO,CACnG,KAAM,GAAc,EAAS,QAAQ,IAAI,iBAAmB,GAC5D,GAAI,CAAC,GAAa,CAAC,EAAY,WAAW,aACxC,KAAM,IAAI,GAAc,6CAA6C,IAAe,GAGtF,GAAI,GAAa,CAAE,GAAY,WAAW,cAAgB,EAAY,WAAW,qBAC/E,KAAM,IAAI,GAAc,iEAAiE,IAAe,GAG1G,KAAM,GAAgB,EAAS,QAAQ,IAAI,eAC3C,GAAK,GACkD,GAC5C,CAAC,EAAO,SAAS,GAC1B,KAAM,IAAI,GAAc,2CAA4C,OAFpE,MAAM,IAAI,GAAc,4BAA6B,GAZzC,oC,kECVhB,GAAI,GAAc,GAClB,KAAM,GAAsD,GAAI,KAEhE,WAAqB,EAAmB,CACtC,KAAM,GAAU,EAAM,OACtB,GAAI,YAAmB,cAAe,EAAQ,WAAa,KAAK,cAC9D,SAAW,KAAS,GAAY,QAAQ,GACtC,EAAM,KAAK,KAAK,KAAM,GAJnB,mBASF,WAAiB,EAAkB,EAAkC,CACrE,GACH,GAAc,GAGd,SAAS,iBAAiB,QAAS,EAAa,KAElD,EAAY,IAAI,EAAU,GAEtB,SAAS,wBAAyB,cAAe,SAAS,cAAc,QAAQ,IAClF,EAAG,SAAS,eAVA,eAcT,WACL,EACA,EACA,EACA,CACA,WAAqB,EAAc,CACjC,KAAM,GAAgB,EAAM,cACxB,CAAC,GACL,GAAc,oBAAoB,EAAW,GAC7C,EAAc,oBAAoB,OAAQ,IAJ5C,mBAOA,EAAQ,EAAU,SAAU,EAAO,CACjC,EAAM,iBAAiB,EAAW,GAClC,EAAM,iBAAiB,OAAQ,KAdnB,aAkBT,WAAiB,EAAkB,EAA6B,CACrE,WAAqB,EAAc,CACjC,KAAM,CAAC,iBAAiB,EACpB,CAAC,GAEL,GAAc,oBAAoB,QAAS,GAC3C,EAAc,oBAAoB,OAAQ,IAL5C,mBAQA,EAAQ,EAAU,SAAU,EAAO,CACjC,EAAM,iBAAiB,QAAS,GAChC,EAAM,iBAAiB,OAAQ,KAXnB,gB,yCCzCT,WAAkC,EAA8C,CACrF,KAAM,GAAO,EAAO,QAAQ,QAC5B,GAAI,CAAE,aAAgB,kBACpB,OAGF,GAAI,GAAQ,EAA+B,GAE3C,GAAI,EAAO,KAAM,CACf,KAAM,GAAe,EAAO,QAAQ,sBAAwB,SAAW,GACjE,EAAQ,EAAO,OAAS,EACzB,GACH,GAAQ,SAAS,cAAc,SAC/B,EAAM,KAAO,SACb,EAAM,UAAU,IAAI,0BACpB,EAAK,QAAQ,IAEf,EAAM,KAAO,EAAO,KACpB,EAAM,MAAQ,MACL,IACT,EAAM,SApBM,gCAwBT,WAAwC,EAAgD,CAC7F,KAAM,GAAQ,EAAK,cAAc,gCACjC,MAAO,aAAiB,kBAAmB,EAAQ,KAFrC,uC,iCCtChB,OAAkB,CAChB,SAAU,CACR,MAAO,MAGT,SAAU,EAIV,YAAa,EAIb,OAAQ,EAIR,KAAM,CACJ,MAAO,SAGL,SAAS,CACX,MAAO,IAtBX,mBA0Be,WACb,EACA,EAAU,CAAC,sBAAuB,IAClC,EAAS,OACT,CACA,GAAI,GACJ,GAAI,CACF,EAAU,EAAO,SAEjB,EAAU,GAAI,GAGhB,KAAM,CAAC,yBAAyB,EAGhC,WAAiB,EAA4B,CAC3C,GAAI,CACF,MAAO,GAAQ,QAAQ,SAGvB,MAAO,OALX,eAUA,WAAiB,EAAa,EAAe,CAC3C,GAAI,CACF,EAAQ,QAAQ,EAAK,SACd,EADc,CAErB,GAAI,GAAyB,EAAM,QAAQ,cAAc,SAAS,SAAU,KAAM,IAJtF,eASA,WAAoB,EAAa,CAC/B,GAAI,CACF,EAAQ,WAAW,WAFvB,yBAOO,CAAC,UAAS,UAAS,cAzCJ,oB,sEC5BxB,WAA4B,EAAyC,CACnE,MAAO,IAAI,SAAQ,GAAW,CAC5B,EAAS,iBAAiB,gBAAiB,EAAS,CAAC,KAAM,OAFtD,0BAMT,WAAwB,EAAkB,CACxC,KAAM,GAAQ,SAAS,cAAc,cACjC,CAAC,GAEL,GAAM,UAAU,OAAO,UAAW,SAE9B,EAAS,EAAM,UAAU,IAAI,WAC5B,EAAM,UAAU,IAAI,UAPlB,sBAUT,WAAgC,EAAuB,CACrD,KAAM,GAAY,SAAS,cAAc,iCACrC,GAAW,EAAU,aAAa,UAAW,GAF1C,8BAQT,kBAA2B,CACzB,KAAM,GAAO,SAAS,cAA+B,uBAC/C,EAAS,KAAM,QAAO,CAAC,QAAS,QAA0B,SAAU,EAAK,MAAO,YAAa,cAEnG,GAAI,GAAM,KAEV,KAAM,GAAgB,OAAO,SAoB7B,GAjBA,EAAS,YAAc,SAAU,EAA+C,CAC1E,EAAK,MACP,GAAM,GACN,EAAe,IAEf,GAAM,GACN,EAAe,GACf,EAAuB,EAAK,eAC5B,OAAO,SAIT,EAAS,YAAc,MAGzB,KAAM,GAAmB,GAErB,CAAC,EACH,KAAM,IAAI,OAAM,uBA3BL,iBAmCf,SAAQ,yBAA0B,SAAU,EAAI,CAC9C,GAAI,OAAO,QAAU,OAAO,OAAO,SAAS,YAAa,CACvD,KAAM,GAAQ,EAAG,aAAa,cACxB,EAAgB,EAAG,aAAa,uBAEtC,OAAO,OAAO,SAAS,YAAY,CACjC,QACA,kBAEF,OAAO,YACF,CACL,KAAM,GAAW,EAAG,aAAa,qBAC7B,GAAU,QAAO,SAAS,KAAO,MAIzC,WAAqB,EAAqC,CACxD,GAAI,CAAE,aAAsB,kBAAkB,MAAO,GAErD,KAAM,GAAgB,SAAS,EAAW,SAG1C,MAAO,IAFS,QAAO,UAAY,IAEtB,EANN,mBAWT,kBAAkD,CAChD,KAAM,GAAa,SAAS,cAAc,yBACpC,EAAY,SAAS,cAAc,iCAGzC,GADI,CAAE,aAAsB,mBACxB,CAAC,EAAY,GAAY,MAAO,GAEpC,KAAM,GAAM,EAAW,KAGvB,MADwB,MAAM,MADP,OAAM,EAAK,CAAC,QAAS,CAAC,OAAQ,mBAAoB,mBAAoB,qBACtD,OAT1B,sBAaf,GAAI,GAAwC,KAE5C,YAAgC,CAC9B,EAAkB,KADX,4BAQM,kBAAkB,CAG1B,KAFa,MAGX,IACH,GAAkB,IAEf,KAAK,GAEL,MAAM,IAGX,KAAM,IAZoB,mC,oDC9GvB,OAAmB,CACxB,YAAY,EAAqB,CAC/B,KAAK,OAAS,GACd,KAAK,YAAc,IAAM,CACvB,IACA,KAAK,OAAS,KALb,oBAgBA,WACL,EACA,EACA,EACA,EAAmC,CAAC,QAAS,IAC/B,CACd,SAAO,iBAAiB,EAAW,EAAQ,GACpC,GAAI,GAAa,IAAM,CAC5B,EAAO,oBAAoB,EAAW,EAAQ,KARlC,iBAiBT,cAAoB,EAA6C,CACtE,MAAO,IAAI,GAAa,IAAM,CAC5B,SAAW,KAAgB,GACzB,EAAa,gBAHH","file":"3932-xxxxxxxxxxxx.js","sourcesContent":["// Global handler for uncaught AJAX errors.\n//\n// Only enabled by default on new style `data-remote` requests.\n\n// eslint-disable-next-line no-restricted-imports\nimport {on} from 'delegated-events'\n\nexport function showGlobalError() {\n  const ajaxErrorMessage = document.getElementById('ajax-error-message')\n  if (ajaxErrorMessage) {\n    ajaxErrorMessage.hidden = false\n  }\n}\n\nexport function hideGlobalError() {\n  const ajaxErrorMessage = document.getElementById('ajax-error-message')\n  if (ajaxErrorMessage) {\n    ajaxErrorMessage.hidden = true\n  }\n}\n\non('deprecatedAjaxError', '[data-remote]', function (event) {\n  const detail = (event as CustomEvent).detail\n  const {error, text} = detail\n\n  if (event.currentTarget !== event.target) {\n    return\n  }\n  if (error === 'abort' || error === 'canceled') {\n    return\n  }\n\n  if (/<html/.test(text)) {\n    showGlobalError()\n    event.stopImmediatePropagation()\n  } else {\n    setTimeout(function () {\n      if (event.defaultPrevented) {\n        return\n      }\n      showGlobalError()\n    }, 0)\n  }\n})\n\n// Clear any errors when the request is tried again\non('deprecatedAjaxSend', '[data-remote]', function () {\n  hideGlobalError()\n})\n\n// \"Dismiss\" button\non('click', '.js-ajax-error-dismiss', function () {\n  hideGlobalError()\n})\n","import {eventToHotkeyString} from '@github/hotkey'\n\n// Returns false if a user has explicitly disabled character key shortcuts.\nexport const areCharacterKeyShortcutsEnabled = () => {\n  const keyboardShortcutsPreference = document.querySelector<HTMLMetaElement>(\n    'meta[name=keyboard-shortcuts-preference]'\n  )\n  if (keyboardShortcutsPreference) {\n    return keyboardShortcutsPreference.content === 'all'\n  }\n  return true\n}\n\n// Character-key shortcuts are implemented only with lowercase characters (\"g\", \"g f\"), uppercase characters (\"Shift+a\", \"A\"),\n// symbols (\"Alt+g\"), and punctuation (\"?\", \"!\", \"/\").\n//\n// Returns true if string is NOT what we define as a character key shortcut.\nexport const isNonCharacterKeyShortcut = (hotkey: string) => {\n  return /Enter|Arrow|Escape|Meta|Control|Esc/.test(hotkey) || (hotkey.includes('Alt') && hotkey.includes('Shift'))\n}\n\n// Returns false if a user settings has character key shortcut disabled and keyboard event corresponds to a character key shortcut.\nexport const isShortcutAllowed = (event: KeyboardEvent) => {\n  const hotkey = eventToHotkeyString(event)\n  if (areCharacterKeyShortcutsEnabled()) {\n    return true\n  }\n  return isNonCharacterKeyShortcut(hotkey)\n}\n","// ### Example Markup\n//\n//   <div class=\"js-task-list-container\">\n//     <task-lists disabled sortable>\n//       <div class=\"js-comment-body\">\n//         <ul class=\"contains-task-list\">\n//           <li class=\"task-list-item\">\n//             <input type=\"checkbox\" class=\"task-list-item-checkbox\" disabled>\n//             text\n//           </li>\n//         </ul>\n//       </div>\n//     </task-lists>\n//     <form class=\"js-comment-update\">\n//       <textarea class=\"js-task-list-field\">- [ ] text</textarea>\n//     </form>\n//   </div>\n//\n// ### Specification\n//\n// TaskLists MUST be contained in a `(div).js-task-list-container`.\n//\n// TaskList Items SHOULD be an a list (`UL`/`OL`) element.\n//\n// Task list items MUST match `(input).task-list-item-checkbox` and MUST be\n// `disabled` by default.\n//\n// TaskLists MUST have a `(textarea).js-task-list-field` form element whose\n// `value` attribute is the source (Markdown) to be updated. The source MUST\n// follow the syntax guidelines.\n//\n// ### NOTE\n//\n// Task list checkboxes are rendered as disabled by default because rendered\n// user content is cached without regard for the viewer.\n\nimport {compose, fromEvent} from '../subscription'\n// eslint-disable-next-line no-restricted-imports\nimport {fire, on} from 'delegated-events'\n\nimport TaskListsElement from '@github/task-lists-element'\n// eslint-disable-next-line no-restricted-imports\nimport {observe} from 'selector-observer'\nimport {remoteForm} from '@github/remote-form'\nimport {requestSubmit} from '../form'\n\ntype Position = [number, number]\n\ninterface CheckPayload {\n  operation: 'check'\n  position: Position\n  checked: boolean\n}\n\ninterface MovePayload {\n  operation: 'move'\n  src: Position\n  dst: Position\n}\n\n// Enable task lists with persistence fields. Otherwise, the viewer lacks\n// permission to update the comment so task lists remain disabled.\nobserve('.js-task-list-container .js-task-list-field', function (el) {\n  const container = el.closest<HTMLElement>('.js-task-list-container')!\n  enableTaskList(container)\n  updateProgress(container)\n})\n\non('task-lists-move', 'task-lists', function (event) {\n  const {src, dst} = event.detail\n  const container = event.currentTarget.closest<HTMLElement>('.js-task-list-container')!\n  saveTaskList(container, 'reordered', {operation: 'move', src, dst})\n})\n\non('task-lists-check', 'task-lists', function (event) {\n  const {position, checked} = event.detail\n  const container = event.currentTarget.closest<HTMLElement>('.js-task-list-container')!\n  saveTaskList(container, `checked:${checked ? 1 : 0}`, {operation: 'check', position, checked})\n})\n\nexport function enableTaskList(container: Element) {\n  if (container.querySelector('.js-task-list-field')) {\n    const taskLists = container.querySelectorAll('task-lists')\n    for (const el of taskLists) {\n      if (el instanceof TaskListsElement) {\n        el.disabled = false\n        const buttons = el.querySelectorAll('button')\n        for (const button of buttons) {\n          button.disabled = false\n        }\n      }\n    }\n  }\n}\n\nexport function disableTaskList(container: Element) {\n  for (const el of container.querySelectorAll('task-lists')) {\n    if (el instanceof TaskListsElement) {\n      el.disabled = true\n\n      const buttons = el.querySelectorAll('button')\n      for (const button of buttons) {\n        button.disabled = true\n      }\n    }\n  }\n}\n\n// Persist task list source changes.\n//\n// Adds a hidden tracking input to the form to trigger server-side\n// instrumentation.\nfunction saveTaskList(container: Element, track: string, payload: CheckPayload | MovePayload) {\n  const form = container.querySelector<HTMLFormElement>('.js-comment-update')!\n\n  disableTaskList(container)\n  updateProgress(container)\n\n  const previousTracking = form.elements.namedItem('task_list_track')\n  if (previousTracking instanceof Element) previousTracking.remove()\n\n  const previousOperation = form.elements.namedItem('task_list_operation')\n  if (previousOperation instanceof Element) previousOperation.remove()\n\n  const tracking = document.createElement('input')\n  tracking.setAttribute('type', 'hidden')\n  tracking.setAttribute('name', 'task_list_track')\n  tracking.setAttribute('value', track)\n  form.appendChild(tracking)\n\n  const operation = document.createElement('input')\n  operation.setAttribute('type', 'hidden')\n  operation.setAttribute('name', 'task_list_operation')\n  operation.setAttribute('value', JSON.stringify(payload))\n  form.appendChild(operation)\n\n  if (!form.elements.namedItem('task_list_key')) {\n    const field = form.querySelector('.js-task-list-field')!\n    const name = field.getAttribute('name')!\n    const value = name.split('[')[0]\n    const input = document.createElement('input')\n    input.setAttribute('type', 'hidden')\n    input.setAttribute('name', 'task_list_key')\n    input.setAttribute('value', value)\n    form.appendChild(input)\n  }\n\n  // If the user has ran into a stale error and is now re-submitting, hide it\n  container.classList.remove('is-comment-stale')\n\n  requestSubmit(form)\n}\n\nremoteForm('.js-task-list-container .js-comment-update', async function (form, wants) {\n  const container = form.closest('.js-task-list-container')!\n  const tracking = form.elements.namedItem('task_list_track')\n  if (tracking instanceof Element) tracking.remove()\n\n  const operation = form.elements.namedItem('task_list_operation')\n  if (operation instanceof Element) operation.remove()\n\n  let response\n  try {\n    response = await wants.json()\n  } catch (error) {\n    let data\n    try {\n      data = JSON.parse(error.response.text)\n    } catch (e) {\n      // Do nothing\n    }\n\n    if (data && data.stale) {\n      const commentField = container.querySelector<HTMLTextAreaElement>('.js-task-list-field')!\n\n      // Prevent the stale value of this field from being persisted (and, eventually, erroneously\n      // restored) if the page is refreshed. We will undo this (and restore the session-resumable\n      // behaviour) if the user clicks the 'Cancel' button to discard the stale edits in this field.\n      commentField.classList.add('session-resumable-canceled')\n      commentField.classList.remove('js-session-resumable')\n    } else if (error.response.status === 422) {\n      // Do nothing\n    } else {\n      window.location.reload()\n    }\n  }\n\n  if (response) {\n    if (operation) {\n      // Store reordered Markdown source in textarea.\n      if (response.json.source) {\n        container.querySelector<HTMLTextAreaElement>('.js-task-list-field')!.value = response.json.source\n      }\n    }\n    enableTaskList(container)\n    requestAnimationFrame(() => updateProgress(container))\n  }\n})\n\n// This flag specifies whether `beforeinput` handler is called before `input` event\n// This logic is needed because Chrome (Version 86.0.4240.198) has a bug with event.inputType == 'insertText' && event.data == null in textarea\n// But Firefox does not support `beforeinput` yet (as of 9th December 2020)\nlet handleAutocomplete = false\n\n// This flag is used to track if a text composition system (as the helper for JP kanji symbols)\n// has popped up on the screen or not.\n// This is needed because the custom tabbing behavior implemented here interferes with the system element\nlet isIMEVisible = false\n\n// This flag is used to track if the document.execCommand functionality is available\n// This is prefered to use the native execCommand because it allow the use of the undo/redo functionality\nlet canUseExecCommand: boolean | null = null\n\n// This handler will set the handleAutocomplete flag so that all browsers except Firefox can handle the event correctly in autoCompleteOnInput\nfunction tryAutoCompleteOnBeforeInput(ev: Event) {\n  const event = ev as InputEvent\n\n  const isNewLine = event.inputType === 'insertLineBreak'\n  if (!isNewLine) {\n    handleAutocomplete = false\n  } else {\n    handleAutocomplete = true\n  }\n}\n\n// This handler will try autocomplete the text in textarea in all browsers\nfunction autoCompleteOnInput(ev: Event) {\n  const event = ev as InputEvent\n\n  // in Firefox this check will always pass\n  if (!handleAutocomplete) {\n    // this block will be called only in Firefox\n    // when `beforeinput` support is added to Firefox, this whole check can be removed\n    const isNewLine = event.inputType === 'insertLineBreak'\n    if (!isNewLine) return\n  }\n\n  const element = event.target as HTMLInputElement\n  listAutocomplete(element)\n  handleAutocomplete = false\n}\n\nfunction listAutocomplete(element: HTMLInputElement) {\n  const result = autocompletedList(element.value, [element.selectionStart, element.selectionEnd])\n  if (result === undefined) return\n\n  updateElementText(element, result)\n}\n\nfunction updateElementText(element: HTMLInputElement, updatedText: UpdatedText) {\n  if (canUseExecCommand === null || canUseExecCommand === true) {\n    element.contentEditable = 'true'\n    try {\n      handleAutocomplete = false // disable autocomplete due to recursion from insert text event\n      let value = undefined\n      if (updatedText.commandId === Command.insertText) {\n        value = updatedText.autocompletePrefix\n        // check if a specific part of the text should be overwritten\n        if (updatedText.writeSelection[0] !== null && updatedText.writeSelection[1] !== null) {\n          element.selectionStart = updatedText.writeSelection[0]\n          element.selectionEnd = updatedText.writeSelection[1]\n        }\n      } else {\n        // set the selection to delete the current row\n        element.selectionStart = updatedText.selection[0]\n      }\n      canUseExecCommand = document.execCommand(updatedText.commandId, false, value)\n    } catch (error) {\n      canUseExecCommand = false\n    }\n    element.contentEditable = 'false'\n  }\n\n  if (!canUseExecCommand) {\n    try {\n      document.execCommand('ms-beginUndoUnit')\n    } catch (e) {\n      // Do nothing.\n    }\n    element.value = updatedText.text\n    try {\n      document.execCommand('ms-endUndoUnit')\n    } catch (e) {\n      // Do nothing.\n    }\n    element.dispatchEvent(new CustomEvent('input', {bubbles: true, cancelable: true}))\n  }\n\n  if (updatedText.selection[0] != null && updatedText.selection[1] != null) {\n    element.selectionStart = updatedText.selection[0]\n    element.selectionEnd = updatedText.selection[1]\n  }\n}\n\nfunction handleShiftEnter(ev: Event) {\n  // TODO: Refactor to use data-hotkey\n  /* eslint eslint-comments/no-use: off */\n  /* eslint-disable no-restricted-syntax */\n  if (isIMEVisible) {\n    return\n  }\n\n  const event = ev as KeyboardEvent\n\n  if (event.key === 'Enter' && event.shiftKey && !event.metaKey) {\n    const element = event.target as HTMLInputElement\n\n    const result = addSoftNewline(element.value, [element.selectionStart, element.selectionEnd])\n    if (result === undefined) return\n\n    updateElementText(element, result)\n\n    event.preventDefault()\n    // Trigger size-to-fit (see github/github#15696)\n    fire(element, 'change')\n  }\n  /* eslint-enable no-restricted-syntax */\n}\n\nfunction onCompositionStart() {\n  isIMEVisible = true\n}\n\nfunction onCompositionEnd() {\n  isIMEVisible = false\n}\n\nfunction updateIndentation(ev: Event) {\n  // TODO: Refactor to use data-hotkey\n  /* eslint eslint-comments/no-use: off */\n  /* eslint-disable no-restricted-syntax */\n  if (isIMEVisible) {\n    return\n  }\n\n  const event = ev as KeyboardEvent\n  if (event.key === 'Escape') {\n    deselectText(ev)\n    return\n  }\n\n  if (event.key !== 'Tab') return\n\n  const element = event.target as HTMLInputElement\n\n  const result = indent(element.value, [element.selectionStart, element.selectionEnd], event.shiftKey)\n  if (result === undefined) return\n\n  event.preventDefault()\n\n  updateElementText(element, result)\n}\n\nobserve('.js-task-list-field', {\n  subscribe: el =>\n    compose(\n      fromEvent(el, 'keydown', updateIndentation),\n      fromEvent(el, 'keydown', handleShiftEnter),\n      fromEvent(el, 'beforeinput', tryAutoCompleteOnBeforeInput),\n      fromEvent(el, 'input', autoCompleteOnInput),\n      fromEvent(el, 'compositionstart', onCompositionStart),\n      fromEvent(el, 'compositionend', onCompositionEnd)\n    )\n})\n\n// subset of https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand#commands\nenum Command {\n  insertText = 'insertText',\n  delete = 'delete'\n}\n\ntype UpdatedText = {\n  text: string\n  autocompletePrefix: string\n  selection: SelectionRange\n  writeSelection: SelectionRange\n  commandId: Command\n}\n\ntype SelectionRange = [number | null, number | null]\n\nconst INDENTATION_RE = /^(\\s*)?/\nexport function addSoftNewline(text: string, selection: SelectionRange): UpdatedText | undefined {\n  const offset = selection[0]\n  if (!offset || !text) return undefined\n\n  const lines = text.substring(0, offset).split('\\n')\n  const currentLine = lines[lines.length - 1]\n  const match = currentLine?.match(INDENTATION_RE)\n  if (!match) return undefined\n\n  const indentation = match[1] || ''\n  const autocompletePrefix = `\\n${indentation}`\n  return {\n    text: text.substring(0, offset) + autocompletePrefix + text.substring(offset),\n    autocompletePrefix,\n    selection: [offset + autocompletePrefix.length, offset + autocompletePrefix.length],\n    commandId: Command.insertText,\n    writeSelection: [null, null]\n  }\n}\n\n// matches '- ', '* ', '12. ', '- [ ]', '- [x]', `* [ ] `, `* [x] `, '12. [ ] ', '12. [x] '\nconst TASK_LIST_RE = /^(\\s*)([*-]|(\\d+)\\.)\\s(\\[[\\sx]\\]\\s)?/\n\nfunction updateRemainingNumberBullets(text: string, currentNumber: number): string {\n  let lines = text.split('\\n')\n\n  lines = lines.map(line => {\n    // regexp to check if string starts with number\n    if (line.replace(/^\\s+/, '').startsWith(`${currentNumber}.`)) {\n      const result = line.replace(`${currentNumber}`, `${currentNumber + 1}`)\n      currentNumber += 1\n      return result\n    }\n    return line\n  })\n\n  return lines.join('\\n')\n}\n\nexport function autocompletedList(text: string, selection: SelectionRange): UpdatedText | undefined {\n  const offset = selection[0]\n  if (!offset || !text) return undefined\n\n  const lines = text.substring(0, offset).split('\\n')\n  const previousLine = lines[lines.length - 2]\n\n  // Check for task list existence\n  const match = previousLine?.match(TASK_LIST_RE)\n  if (!match) return undefined\n\n  const listPrefix = match[0]\n  const indentation = match[1]\n  const bullet = match[2]\n  const numericBullet = parseInt(match[3], 10)\n  const hasCheckbox = Boolean(match[4])\n  const isNumericBullet = !isNaN(numericBullet)\n  const newBullet = isNumericBullet ? `${numericBullet + 1}.` : bullet\n  let newPrefix = `${newBullet} ${hasCheckbox ? '[ ] ' : ''}`\n\n  let currentLineEnd = text.indexOf('\\n', offset)\n  if (currentLineEnd < 0) {\n    currentLineEnd = text.length\n  }\n  const currentLine = text.substring(offset, currentLineEnd)\n  // do not append list item if already present\n  if (currentLine.startsWith(newPrefix)) {\n    newPrefix = ''\n  }\n  /*\n    Autocomplete list element on next line if current line has list element containing text.\n    or there's text on the line after the cursor (|):\n    ```\n    - | some text\n    ```\n    becomes:\n    ```\n    -\n    - | some text\n    ```\n   */\n  const shouldAutocomplete = previousLine.replace(listPrefix, '').trim().length > 0 || currentLine.trim().length > 0\n  if (shouldAutocomplete) {\n    let autocompletePrefix = `${indentation}${newPrefix}`\n    let autocompletePostfix = text.substring(offset)\n    const autocompletePrefixLength = autocompletePrefix.length\n\n    let writeSelection = [null, null] as SelectionRange\n    const whiteSpaceRegex = /^\\s*$/g\n    let resultText = text.substring(0, offset) + autocompletePrefix + autocompletePostfix\n\n    if (isNumericBullet && !text.substring(offset).match(whiteSpaceRegex)) {\n      autocompletePostfix = updateRemainingNumberBullets(text.substring(offset), numericBullet + 1)\n      autocompletePrefix += autocompletePostfix\n      writeSelection = [offset, offset + autocompletePrefix.length] as SelectionRange\n      resultText = text.substring(0, offset) + autocompletePrefix\n    }\n\n    return {\n      text: resultText,\n      autocompletePrefix,\n      selection: [offset + autocompletePrefixLength, offset + autocompletePrefixLength],\n      commandId: Command.insertText,\n      writeSelection\n    }\n  } else {\n    // This case clears the autocompleted list element if user hits an enter without adding any text to it.\n    const offsetWithoutPrefix = offset - `\\n${listPrefix}`.length\n    return {\n      autocompletePrefix: '',\n      text: text.substring(0, offsetWithoutPrefix) + text.substring(offset),\n      selection: [offsetWithoutPrefix, offsetWithoutPrefix],\n      commandId: Command.delete,\n      writeSelection: [null, null]\n    }\n  }\n}\n\nexport function indent(text: string, selection: SelectionRange, substract: boolean): UpdatedText | undefined {\n  // Perform indentation manipulations only when more than one character was selected.\n  const selectionStart = selection[0] || 0\n  const selectionEnd = selection[1] || selectionStart\n  if (selection[0] === null || selectionStart === selectionEnd) return undefined\n\n  const startOffset = text.substring(0, selectionStart).lastIndexOf('\\n') + 1\n  const endOffsetPreNormalization = text.indexOf('\\n', selectionEnd - 1)\n  const endOffset = endOffsetPreNormalization > 0 ? endOffsetPreNormalization : text.length - 1\n  const selectedLines = text.substring(startOffset, endOffset).split('\\n')\n\n  let startUpdated = false\n  let selectionStartDiff = 0\n  let selectionEndDiff = 0\n  const updatedSelectedLines: string[] = []\n  for (const line of selectedLines) {\n    const match = line.match(/^\\s*/)\n    if (match) {\n      let indentation = match[0]\n      const lineText = line.substring(indentation.length)\n      if (substract) {\n        const prevLength = indentation.length\n        indentation = indentation.slice(0, -2)\n\n        // Update selectionStart for first line only.\n        selectionStartDiff = startUpdated ? selectionStartDiff : indentation.length - prevLength\n        startUpdated = true\n        selectionEndDiff += indentation.length - prevLength\n      } else {\n        indentation += '  '\n        selectionStartDiff = 2\n        selectionEndDiff += 2\n      }\n      updatedSelectedLines.push(indentation + lineText)\n    }\n  }\n\n  const linesString = updatedSelectedLines.join('\\n')\n  const newText = text.substring(0, startOffset) + linesString + text.substring(endOffset)\n  const newRange: SelectionRange = [\n    Math.max(startOffset, selectionStart + selectionStartDiff),\n    selectionEnd + selectionEndDiff\n  ]\n  return {\n    text: newText,\n    selection: newRange,\n    autocompletePrefix: linesString,\n    commandId: Command.insertText,\n    writeSelection: [startOffset, endOffset]\n  }\n}\n\nfunction deselectText(ev: Event) {\n  const event = ev as KeyboardEvent\n  const element = event.target as HTMLInputElement\n  if (element.selectionDirection === 'backward') {\n    element.selectionEnd = element.selectionStart\n  } else {\n    element.selectionStart = element.selectionEnd\n  }\n}\n\nfunction updateProgress(container: Element) {\n  if (document.querySelectorAll('tracked-issues-progress').length === 0) return\n\n  const isInTimeline = container.closest<HTMLElement>('.js-timeline-item')\n  if (isInTimeline) return\n\n  const checkboxes = container.querySelectorAll<HTMLInputElement>('.js-comment-body [type=checkbox]')\n  const total = checkboxes.length\n  const completed = Array.from(checkboxes).filter(checkbox => checkbox.checked).length\n  const progressComponents = document.querySelectorAll('tracked-issues-progress[data-type=checklist]')\n  for (const progress of progressComponents) {\n    progress.setAttribute('data-completed', String(completed))\n    progress.setAttribute('data-total', String(total))\n  }\n}\n","// eslint-disable-next-line no-restricted-imports\nimport {fire} from 'delegated-events'\n\ntype Options = {\n  content: DocumentFragment | Promise<DocumentFragment> | Node\n  dialogClass?: string\n  detailsClass?: string\n  labelledBy?: string | null\n  label?: string | null\n}\n\n// Open the site-wide Details Dialog element.\nexport async function dialog(options: Options): Promise<HTMLElement> {\n  const dialogTemplate = document.querySelector<HTMLTemplateElement>('#site-details-dialog')!\n  const clonedDetails = dialogTemplate.content.cloneNode(true) as Element\n  const details = clonedDetails.querySelector<HTMLElement>('details')!\n  const detailsDialog = details.querySelector<HTMLElement>('details-dialog')!\n  const spinner = details.querySelector<HTMLElement>('.js-details-dialog-spinner')!\n  if (options.detailsClass) details.classList.add(...options.detailsClass.split(' '))\n  if (options.dialogClass) detailsDialog.classList.add(...options.dialogClass.split(' '))\n\n  if (options.label) {\n    detailsDialog.setAttribute('aria-label', options.label)\n  } else if (options.labelledBy) {\n    detailsDialog.setAttribute('aria-labelledby', options.labelledBy)\n  }\n\n  document.body.append(clonedDetails)\n\n  const content = await options.content\n  spinner.remove()\n  detailsDialog.prepend(content)\n\n  details.addEventListener('toggle', () => {\n    if (details.hasAttribute('open')) return\n    fire(detailsDialog, 'dialog:remove')\n    details.remove()\n  })\n\n  return detailsDialog\n}\n","import {getDocumentHtmlSafeNonces, verifyResponseHtmlSafeNonce} from './html-safe'\nimport {parseHTML} from './parse-html'\n\nexport async function fetchSafeDocumentFragment(\n  document: Document,\n  url: RequestInfo,\n  options?: RequestInit\n): Promise<DocumentFragment> {\n  const request = new Request(url, options)\n  request.headers.append('X-Requested-With', 'XMLHttpRequest')\n  const response = await self.fetch(request)\n  if (response.status < 200 || response.status >= 300) {\n    throw new Error(`HTTP ${response.status}${response.statusText || ''}`)\n  }\n  verifyResponseHtmlSafeNonce(getDocumentHtmlSafeNonces(document), response)\n  return parseHTML(document, await response.text())\n}\n\nexport function fetchPoll(url: RequestInfo, options?: RequestInit, timeBetweenRequests = 1000): Promise<Response> {\n  return (async function poll(wait: number): Promise<Response> {\n    const request = new Request(url, options)\n    request.headers.append('X-Requested-With', 'XMLHttpRequest')\n    const response = await self.fetch(request)\n    if (response.status < 200 || response.status >= 300) {\n      throw new Error(`HTTP ${response.status}${response.statusText || ''}`)\n    }\n\n    if (response.status === 200) return response\n    if (response.status === 202) {\n      await new Promise(resolve => setTimeout(resolve, wait))\n      return poll(wait * 1.5)\n    }\n    throw new Error(`Unexpected ${response.status} response status from poll endpoint`)\n  })(timeBetweenRequests)\n}\n","// eslint-disable-next-line no-restricted-imports\nimport {on} from 'delegated-events'\nimport {persistSubmitButtonValue} from './remote-submit'\nimport {showGlobalError} from './behaviors/ajax-error'\n\ntype TextField = HTMLInputElement | HTMLTextAreaElement\ntype Button = HTMLInputElement | HTMLButtonElement\n\non('click', '.js-remote-submit-button', async function (event) {\n  const button = event.currentTarget as HTMLButtonElement\n  const form = button.form as HTMLFormElement\n  event.preventDefault()\n  let response\n  try {\n    response = await fetch(form.action, {\n      method: form.method,\n      body: new FormData(form),\n      headers: {\n        Accept: 'application/json',\n        'X-Requested-With': 'XMLHttpRequest'\n      }\n    })\n  } catch {\n    // Ignore network errors\n  }\n  if (response && !response.ok) {\n    showGlobalError()\n  }\n})\n\nfunction fire(target: HTMLElement, name: string, cancelable: boolean): boolean {\n  return target.dispatchEvent(\n    new CustomEvent(name, {\n      bubbles: true,\n      cancelable\n    })\n  )\n}\n\n// Submit a form while ensuring that `submit` event is also triggered.\n//\n// Calling native `form.submit()` method immediately submits the form without triggering the `submit` event.\n// As a result, code that wants to hook into form submits would never execute.\n//\n// This method first triggers the `submit` event and, if that event wasn't `preventDefault`d, submits the\n// form natively.\nexport function requestSubmit(form: HTMLFormElement, submitter?: Button) {\n  if (submitter) {\n    checkButtonValidity(form, submitter)\n    persistSubmitButtonValue(submitter)\n  }\n  if (fire(form, 'submit', true)) {\n    form.submit()\n  }\n}\n\n// Check submitter validity for form.requestSubmit compatibility.\n// See https://html.spec.whatwg.org/#dom-form-requestsubmit.\nfunction checkButtonValidity(form: HTMLFormElement, submitter: Button) {\n  if (!(form instanceof HTMLFormElement)) throw new TypeError('The specified element is not of type HTMLFormElement.')\n  if (!(submitter instanceof HTMLElement)) throw new TypeError('The specified element is not of type HTMLElement.')\n  if (submitter.type !== 'submit') throw new TypeError('The specified element is not a submit button.')\n  if (!form || form !== submitter.form) throw new Error('The specified element is not owned by the form element.')\n}\n\n// Set a form field value while ensuring that `change` event is also triggered.\n//\n// Having the `change` event fire is important for various behaviors to react, such as form validation.\nexport function changeValue(input: TextField, value: string | boolean) {\n  if (typeof value === 'boolean') {\n    if (input instanceof HTMLInputElement) {\n      input.checked = value\n    } else {\n      throw new TypeError('only checkboxes can be set to boolean value')\n    }\n  } else {\n    if (input.type === 'checkbox') {\n      throw new TypeError(\"checkbox can't be set to string value\")\n    } else {\n      input.value = value\n    }\n  }\n  fire(input, 'change', false)\n}\n\n// Fill multiple form fields by item name.\nexport function fillFormValues(form: HTMLFormElement, fields: {[key: string]: string}) {\n  for (const name in fields) {\n    const value = fields[name]\n    const element = form.elements.namedItem(name)\n\n    if (element instanceof HTMLInputElement) {\n      element.value = value\n    } else if (element instanceof HTMLTextAreaElement) {\n      element.value = value\n    }\n  }\n}\n\n// Test if element is a form field.\nexport function isFormField(element: Node): boolean {\n  if (!(element instanceof HTMLElement)) {\n    return false\n  }\n\n  const name = element.nodeName.toLowerCase()\n  const type = (element.getAttribute('type') || '').toLowerCase()\n  return (\n    name === 'select' ||\n    name === 'textarea' ||\n    (name === 'input' && type !== 'submit' && type !== 'reset') ||\n    element.isContentEditable\n  )\n}\n\nfunction searchParamsFromFormData(formData: FormData): URLSearchParams {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return new URLSearchParams(formData as any)\n}\n\n// Get a `?` search string for a URL for a GET form, using its `action` attribute as well as its other fields.\nexport function combineGetFormSearchParams(formAction: URL, formData: FormData): string {\n  const allSearchParams = new URLSearchParams(formAction.search)\n  const searchParamsFromInputs = searchParamsFromFormData(formData)\n  for (const [key, value] of searchParamsFromInputs) {\n    allSearchParams.append(key, value)\n  }\n  return allSearchParams.toString()\n}\n\n// Serialize form data into string.\nexport function serialize(form: HTMLFormElement): string {\n  return searchParamsFromFormData(new FormData(form)).toString()\n}\n","import DetailsDialogElement from '@github/details-dialog-element'\nimport {isFormField} from './form'\n\n// Check if container has any user interactions that could be lost if replaced.\n//\n// container - An Element to check for user interactions.\n// ignoreFocusedContainer - A Boolean, `true` to skip the\n// focus check if the container is the focused element. Dirty field and\n// mousedown checks are still performed.\nexport function hasInteractions(container: Element, ignoreFocusedContainer = false): boolean {\n  return (\n    hasDirtyFields(container) ||\n    hasFocus(container, ignoreFocusedContainer) ||\n    hasMousedown(container) ||\n    markedAsDirty(container)\n  )\n}\n\nexport function hasDirtyFields(container: Element): boolean {\n  for (const field of container.querySelectorAll('input, textarea')) {\n    if (field instanceof HTMLInputElement || field instanceof HTMLTextAreaElement) {\n      if (formFieldValueChanged(field)) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\nfunction formFieldValueChanged(input: HTMLInputElement | HTMLTextAreaElement): boolean {\n  if (input instanceof HTMLInputElement && (input.type === 'checkbox' || input.type === 'radio')) {\n    if (input.checked !== input.defaultChecked) return true\n  } else {\n    if (input.value !== input.defaultValue) return true\n  }\n  return false\n}\n\nlet stubbedActiveElement: Element | null\n\nexport async function withActiveElement(element: Element, fn: () => unknown): Promise<void> {\n  stubbedActiveElement = element\n  try {\n    await fn()\n  } finally {\n    stubbedActiveElement = null\n  }\n}\n\nfunction getActiveElement(container: Element): Element | null {\n  if (stubbedActiveElement instanceof Element) {\n    return stubbedActiveElement\n  } else if (container && container.ownerDocument && container.ownerDocument.activeElement) {\n    return container.ownerDocument.activeElement\n  }\n  return null\n}\n\nlet latestMouseupTarget: EventTarget | null\n\ndocument.addEventListener('mouseup', function (event: Event) {\n  latestMouseupTarget = event.target\n})\n\nfunction hasFocus(container: Element, ignoreFocusedContainer: boolean): boolean {\n  const activeElement = getActiveElement(container)\n  if (activeElement === null) return false\n  if (ignoreFocusedContainer && activeElement === container) return false\n\n  // Updatable container hasFocus if one of the following is true:\n  // 1. Focus target is both a form field AND the update target\n  const formFieldFocused = activeElement === container && isFormField(activeElement)\n  if (formFieldFocused) return true\n  // 2. Focus target is relevent (ie not a UPDATABLE_INTERACTIVE_TARGET)\n  //\n  // We consider it safe to update content if the focused element is a button or a link, as\n  // both likely only trigger transient actions\n  const focusTargetIsRelevent = container.contains(activeElement) && !activeElementIsSafe(activeElement)\n  if (focusTargetIsRelevent) return true\n\n  // 3. The last clicked element is an open details summary\n  const interactingWithOpenDetails =\n    latestMouseupTarget instanceof Element &&\n    container.contains(latestMouseupTarget) &&\n    !!latestMouseupTarget.closest('details[open] > summary')\n  return interactingWithOpenDetails\n}\n\nconst UPDATABLE_INTERACTIVE_TARGET = 'a[href], button'\n\nfunction activeElementIsSafe(activeElement: Element): boolean {\n  if (activeElement instanceof DetailsDialogElement) return true\n\n  const isLinkOrButton = activeElement instanceof HTMLAnchorElement || activeElement instanceof HTMLButtonElement\n  const isInsideTaskItem = activeElement.parentElement?.classList.contains('task-list-item')\n  if (isLinkOrButton && isInsideTaskItem) {\n    return true\n  }\n\n  if (!(latestMouseupTarget instanceof Element)) return false\n  const updatableActiveElement = activeElement.closest(UPDATABLE_INTERACTIVE_TARGET)\n  if (!updatableActiveElement) return false\n  const updatableMouseupElement = latestMouseupTarget.closest(UPDATABLE_INTERACTIVE_TARGET)\n  return updatableActiveElement === updatableMouseupElement\n}\n\nfunction hasMousedown(container: Element): boolean {\n  return container.matches(':active:enabled')\n}\n\nfunction markedAsDirty(container: Element): boolean {\n  return container.closest('.is-dirty') || container.querySelector('.is-dirty') ? true : false\n}\n","//  Get document's HTML Safe nonce.\n//\n// Example:\n//\n//   <meta name=\"html-safe-nonce\" content=\"de43a1f355c711f7f705e4f971964391ac0c8e13\">\nexport function getDocumentHtmlSafeNonces(document: Document): string[] {\n  const nonces = [...document.querySelectorAll<HTMLMetaElement>('meta[name=html-safe-nonce]')].map(meta => meta.content)\n\n  if (nonces.length < 1) {\n    throw new Error('could not find html-safe-nonce on document')\n  }\n  return nonces\n}\n\ninterface Response {\n  headers: Headers\n  status: number\n}\n\nclass ResponseError extends Error {\n  response: Response\n\n  constructor(message: string, response: Response) {\n    super(`${message} for HTTP ${response.status}`)\n    this.response = response\n  }\n}\n\nexport function verifyResponseHtmlSafeNonce(nonces: string[], response: Response, allowJson = false) {\n  const contentType = response.headers.get('content-type') || ''\n  if (!allowJson && !contentType.startsWith('text/html')) {\n    throw new ResponseError(`expected response with text/html, but was ${contentType}`, response)\n  }\n\n  if (allowJson && !(contentType.startsWith('text/html') || contentType.startsWith('application/json'))) {\n    throw new ResponseError(`expected response with text/html or application/json, but was ${contentType}`, response)\n  }\n\n  const responseNonce = response.headers.get('x-html-safe')\n  if (!responseNonce) {\n    throw new ResponseError(`missing X-HTML-Safe nonce`, response)\n  } else if (!nonces.includes(responseNonce)) {\n    throw new ResponseError(`response X-HTML-Safe nonce did not match`, response)\n  }\n}\n","// React to elements receiving focus\n//\n// Often we need to apply some behavior to form elements when they start getting\n// interacted with. We could use `observe`, but that can be expensive if there\n// are many such elements on the page, and when we aren't actually interested in\n// those elements until they receive focus.\n//\n// This is a lightweight and preferred alternative to the family of methods\n// from `github/focused` module.\n//\n// Examples\n//\n//   onFocus('.js-widget', element => {\n//     // ...\n//   })\n\nimport SelectorSet from 'selector-set'\n\nlet initialized = false\nconst selectorSet: SelectorSet<(el: HTMLElement) => void> = new SelectorSet()\n\nfunction handleFocus(event: FocusEvent) {\n  const focused = event.target\n  if (focused instanceof HTMLElement && focused.nodeType !== Node.DOCUMENT_NODE) {\n    for (const match of selectorSet.matches(focused)) {\n      match.data.call(null, focused)\n    }\n  }\n}\n\nexport function onFocus(selector: string, fn: (el: HTMLElement) => unknown) {\n  if (!initialized) {\n    initialized = true\n    // We use the \"focus\" event in the capture phase because Firefox\n    // historically had a limitation with \"focusin\" not bubbling.\n    document.addEventListener('focus', handleFocus, true)\n  }\n  selectorSet.add(selector, fn)\n\n  if (document.activeElement instanceof HTMLElement && document.activeElement.matches(selector)) {\n    fn(document.activeElement)\n  }\n}\n\nexport function onKey(\n  eventType: 'keydown' | 'keypress' | 'keyup',\n  selector: string,\n  inputHandler: (event: KeyboardEvent) => unknown\n) {\n  function blurHandler(event: Event) {\n    const currentTarget = event.currentTarget as HTMLElement\n    if (!currentTarget) return\n    currentTarget.removeEventListener(eventType, inputHandler)\n    currentTarget.removeEventListener('blur', blurHandler)\n  }\n\n  onFocus(selector, function (field) {\n    field.addEventListener(eventType, inputHandler)\n    field.addEventListener('blur', blurHandler)\n  })\n}\n\nexport function onInput(selector: string, inputHandler: EventListener) {\n  function blurHandler(event: Event) {\n    const {currentTarget} = event\n    if (!currentTarget) return\n\n    currentTarget.removeEventListener('input', inputHandler)\n    currentTarget.removeEventListener('blur', blurHandler)\n  }\n\n  onFocus(selector, function (field) {\n    field.addEventListener('input', inputHandler)\n    field.addEventListener('blur', blurHandler)\n  })\n}\n","// Emulates submit button submission values by inserting a hidden input to the form.\n//\n// Submit events can be triggerd in the following ways:\n// - User clicks on a submit button.\n// - User press Enter when focusing on a form field; also known as \"implicit submission\".\n// - Programmatically via requestSubmit helper.\n//\n// On GitHub.com, the submission is either handled by the browser or remoteForm.\n//\n// For submissions triggered by user actions, the name and value of the clicked submit button (also known as\n// \"the submitter\") is passed along in the request, and can be programmatically retrieved with FormData.entries().\n//\n// However, this value will be lost in the following cases:\n// - 1. When the submitter button is disabled, most commonly by [data-disable-with].\n// - 2. When submitting via requestSubmit (from form.js), because the submission does not originated from a submitter.\n// - 3. When submitting with remoteForm, because FormData(form).entries() does not know about the submitter. In Safari\n// the submitter is known during the submission steps, but this behavior is not supported in any other browsers.\n//\n// @see {@link https://github.com/github/form-data-entries/pull/7}.\n//\n// For the exact workarounds, refer to ./form.js and ./remote.js.\nexport function persistSubmitButtonValue(button: HTMLButtonElement | HTMLInputElement) {\n  const form = button.closest('form')\n  if (!(form instanceof HTMLFormElement)) {\n    return\n  }\n\n  let input = findPersistedSubmitButtonValue(form)\n\n  if (button.name) {\n    const defaultValue = button.matches('input[type=submit]') ? 'Submit' : ''\n    const value = button.value || defaultValue\n    if (!input) {\n      input = document.createElement('input')\n      input.type = 'hidden'\n      input.classList.add('is-submit-button-value')\n      form.prepend(input)\n    }\n    input.name = button.name\n    input.value = value\n  } else if (input) {\n    input.remove()\n  }\n}\n\nexport function findPersistedSubmitButtonValue(form: HTMLFormElement): HTMLInputElement | null {\n  const input = form.querySelector('input.is-submit-button-value')\n  return input instanceof HTMLInputElement ? input : null\n}\n","// Safely access Storage items by wrapping a Storage instance\n// (localStorage or sessionStorage) with safe versions of its API\n// methods.  Callers may opt not to suppress quota errors thrown on\n// set in case they rely on recieving them.\n\n// An implementation of the Storage API that throws away all data.  Used in\n// cases when the requested Storage backend is not available.\nclass NoOpStorage {\n  getItem() {\n    return null\n  }\n\n  setItem() {\n    return undefined\n  }\n\n  removeItem() {\n    return undefined\n  }\n\n  clear() {\n    return undefined\n  }\n\n  key() {\n    return null\n  }\n\n  get length() {\n    return 0\n  }\n}\n\nexport default function safeStorage(\n  storageKey: 'sessionStorage' | 'localStorage',\n  options = {throwQuotaErrorsOnSet: false},\n  global = window\n) {\n  let storage: Storage\n  try {\n    storage = global[storageKey]\n  } catch {\n    storage = new NoOpStorage()\n  }\n\n  const {throwQuotaErrorsOnSet} = options\n\n  // Safely get storage item.\n  function getItem(key: string): string | null {\n    try {\n      return storage.getItem(key)\n    } catch (error) {\n      // Ignore browser private mode error.\n      return null\n    }\n  }\n\n  // Safely set storage item.\n  function setItem(key: string, value: string) {\n    try {\n      storage.setItem(key, value)\n    } catch (error) {\n      if (throwQuotaErrorsOnSet && error.message.toLowerCase().includes('quota')) throw error\n    }\n  }\n\n  // Safely remove storage item.\n  function removeItem(key: string) {\n    try {\n      storage.removeItem(key)\n    } catch (error) {\n      // Ignore browser private mode error.\n    }\n  }\n  return {getItem, setItem, removeItem}\n}\n","import {dialog} from './details-dialog'\nimport {fetchSafeDocumentFragment} from './fetch'\n// eslint-disable-next-line no-restricted-imports\nimport {observe} from 'selector-observer'\n\nfunction waitForDialogClose(dialogEl: HTMLElement): Promise<unknown> {\n  return new Promise(resolve => {\n    dialogEl.addEventListener('dialog:remove', resolve, {once: true})\n  })\n}\n\nfunction setModalStatus(success: boolean) {\n  const modal = document.querySelector('.sso-modal')\n  if (!modal) return\n\n  modal.classList.remove('success', 'error')\n\n  if (success) modal.classList.add('success')\n  else modal.classList.add('error')\n}\n\nfunction updateExpiresAroundTag(expiresAround: string) {\n  const expiryTag = document.querySelector('meta[name=sso-expires-around]')\n  if (expiryTag) expiryTag.setAttribute('content', expiresAround)\n}\n\n// Asks the user to perform single sign-on for the current organization. SSO\n// take place in a new window so we'll need to set up a way for the other window\n// to tell us when SSO is complete and whether or not it was successful.\nasync function ssoPrompt() {\n  const link = document.querySelector<HTMLLinkElement>('link[rel=sso-modal]')!\n  const prompt = await dialog({content: fetchSafeDocumentFragment(document, link.href), dialogClass: 'sso-modal'})\n\n  let sso = null\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, compat/compat\n  const external: any = window.external\n\n  // Expose callback method for the SSO window to invoke with its status when complete.\n  external.ssoComplete = function (data: {error: boolean; expiresAround: string}) {\n    if (data.error) {\n      sso = false\n      setModalStatus(sso)\n    } else {\n      sso = true\n      setModalStatus(sso)\n      updateExpiresAroundTag(data.expiresAround)\n      window.focus()\n    }\n\n    // Remove the external function now that it's served its purpose\n    external.ssoComplete = null\n  }\n\n  await waitForDialogClose(prompt)\n\n  if (!sso) {\n    throw new Error('sso prompt canceled')\n  }\n}\n\n// Watch for modal complete elements. This is shown as the final step of the\n// single sign-on process that happens in a separate window. Once we see this\n// we know SSO is complete and we can try to tell the original window what the\n// status is before closing the SSO window.\nobserve('.js-sso-modal-complete', function (el) {\n  if (window.opener && window.opener.external.ssoComplete) {\n    const error = el.getAttribute('data-error')\n    const expiresAround = el.getAttribute('data-expires-around')\n\n    window.opener.external.ssoComplete({\n      error,\n      expiresAround\n    })\n    window.close()\n  } else {\n    const fallback = el.getAttribute('data-fallback-url')\n    if (fallback) window.location.href = fallback\n  }\n})\n\nfunction expiresSoon(expiresTag: Element | null): boolean {\n  if (!(expiresTag instanceof HTMLMetaElement)) return true\n\n  const expiresAround = parseInt(expiresTag.content)\n  const now = new Date().getTime() / 1000\n\n  return now > expiresAround\n}\n\n// Remotely checks the single-sign on status for the current page. If the link tags are\n// not present in the <head>, the current page is not enforced and the status is considered good.\nasync function fetchSsoStatus(): Promise<boolean> {\n  const sessionTag = document.querySelector('link[rel=sso-session]')\n  const expiryTag = document.querySelector('meta[name=sso-expires-around]')\n\n  if (!(sessionTag instanceof HTMLLinkElement)) return true // No SSO enforcement head tags. SSO not enforced.\n  if (!expiresSoon(expiryTag)) return true // Don't bother checking unless we're nearing SSO session expiry\n\n  const url = sessionTag.href\n  const response = await fetch(url, {headers: {Accept: 'application/json', 'X-Requested-With': 'XMLHttpRequest'}})\n  const result: boolean = await response.json()\n  return result\n}\n\nlet activeSsoPrompt: Promise<void> | null = null\n\nfunction clearActiveSsoPrompt() {\n  activeSsoPrompt = null\n}\n\n// Checks to see if the user has a valid single sign-on session for the current\n// page. If not and the page is enforced, it blocks the callback until the user\n// renews their SSO session.\n/* eslint-disable-next-line import/no-anonymous-default-export */\nexport default async function () {\n  const sso = await fetchSsoStatus()\n\n  if (!sso) {\n    if (!activeSsoPrompt) {\n      activeSsoPrompt = ssoPrompt()\n        /* eslint-disable-next-line github/no-then */\n        .then(clearActiveSsoPrompt)\n        /* eslint-disable-next-line github/no-then */\n        .catch(clearActiveSsoPrompt)\n    }\n\n    await activeSsoPrompt\n  }\n}\n","// TODO: Research replacing this module with a composable observable library.\n// The scope of this module simply returns a finalized subscription object.\n\n// Lightweight TC39 observable Subscription.\nexport class Subscription {\n  constructor(cleanup: () => void) {\n    this.closed = false\n    this.unsubscribe = () => {\n      cleanup()\n      this.closed = true\n    }\n  }\n\n  // A boolean value indicating whether the subscription is closed.\n  closed: boolean\n  // Cancels the subscription.\n  unsubscribe: () => void\n}\n\n// Create a Subscription from an event.\nexport function fromEvent(\n  target: EventTarget,\n  eventName: string,\n  onNext: EventListenerOrEventListenerObject,\n  options: AddEventListenerOptions = {capture: false}\n): Subscription {\n  target.addEventListener(eventName, onNext, options)\n  return new Subscription(() => {\n    target.removeEventListener(eventName, onNext, options)\n  })\n}\n\n// Combine several subscriptions into a single subscription.\n//\n// subscriptions - A list of subscriptions to combine.\n//\n// Returns a single, combined, subscription.\nexport function compose(...subscriptions: Subscription[]): Subscription {\n  return new Subscription(() => {\n    for (const subscription of subscriptions) {\n      subscription.unsubscribe()\n    }\n  })\n}\n"],"sourceRoot":""}