{"version":3,"sources":["app/assets/modules/github/behaviors/pjax.ts","app/assets/modules/github/behaviors/pjax/head.ts","app/assets/modules/github/document-ready.ts","app/assets/modules/github/features.ts","app/assets/modules/github/fragment-target.ts","app/assets/modules/github/history.ts","app/assets/modules/github/parse-html.ts","app/assets/modules/github/proxy-site-detection.ts","app/assets/modules/github/stats.ts"],"names":[],"mappings":"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","file":"3682-xxxxxxxxxxxx.js","sourcesContent":["// pjax behavior\n//\n// Pjaxifies any links with data-pjax or inside a container with\n// data-pjax.\n//\n// The container must be annotated with data-pjax-container and\n// have an ID.\n//\n//   <div id=\"my-container\" data-pjax-container>\n//\n//     <a href=\"/foo\" data-pjax>Foo</a>\n//\n//     <ul data-pjax>\n//       <li><a href=\"/bar\">Bar</a></li>\n//       <li><a href=\"/baz\">Baz</a></li>\n//     </ul>\n//\n//  </div>\n//\n//  <ul data-pjax=\"#my-container\">\n//    <li><a href=\"/bar\">Bar</a></li>\n//    <li><a href=\"/baz\">Baz</a></li>\n//  </ul>\n//\n\nimport {pushState, replaceState} from '../history'\nimport {replaceCachedElements, replaceTransientTags} from '../behaviors/pjax/head'\n\nimport {findFragmentTarget} from '../fragment-target'\nimport {isFeatureEnabled} from '../features'\nimport {parseHTML} from '../parse-html'\nimport {sendStats} from '../stats'\n\ndeclare global {\n  interface Document {\n    addEventListener(\n      type: 'pjax:start',\n      listener: (this: Document, ev: CustomEvent<{url?: string}>) => unknown,\n      options?: boolean | AddEventListenerOptions\n    ): void\n    addEventListener(\n      type: 'pjax:beforeReplace',\n      listener: (\n        this: Document,\n        ev: CustomEvent<{contents?: Array<Node | null>; state: State; previousState: State}>\n      ) => unknown,\n      options?: boolean | AddEventListenerOptions\n    ): void\n    addEventListener(\n      type: 'pjax:hardLoad',\n      listener: (this: Document, ev: CustomEvent<{reason?: string}>) => unknown,\n      options?: boolean | AddEventListenerOptions\n    ): void\n  }\n\n  interface Window {\n    addEventListener(\n      type: 'pjax:beforeReplace',\n      listener: (\n        this: Document,\n        ev: CustomEvent<{contents?: Array<Node | null>; state: State; previousState: State}>\n      ) => unknown,\n      options?: boolean | AddEventListenerOptions\n    ): void\n  }\n}\n\nexport interface PjaxOptions {\n  id?: number\n  url: string\n  container: Element\n  type?: string\n  push?: boolean\n  replace?: boolean\n  scrollTo?: number | false\n  dataType?: string\n  fragment?: string\n  data?: FormData\n  requestUrl?: string\n  target?: HTMLElement\n}\n\nconst maxCacheLength = 20\n\ntype State = {\n  id: number\n  url: string\n  title: string\n  container: string | null\n  fragment?: string\n}\n\nlet currentState: State | null\nlet previousController: AbortController | null = null\n\nfunction dispatch(target: Element, name: string, detail?: unknown): boolean {\n  return target.dispatchEvent(\n    new CustomEvent(name, {\n      bubbles: true,\n      cancelable: true,\n      detail\n    })\n  )\n}\n\n// Loads a URL with ajax, puts the response body inside a container,\n// then pushState()'s the loaded URL.\nexport default async function pjaxRequest(opts: PjaxOptions) {\n  const options = {\n    push: true,\n    replace: false,\n    type: 'GET',\n    dataType: 'html',\n    scrollTo: 0,\n    ...opts\n  }\n\n  options.requestUrl = options.url!\n  const url = parseURL(options.url)\n  const hash = url.hash\n\n  const context = options.container as HTMLElement\n  const contextSelector = getContainerSelector(context)\n\n  // Initialize currentState for the initial page load. Assume we're\n  // using the container and options of the link we're loading for the\n  // back button to the initial page. This ensures good back button\n  // behavior.\n  if (!currentState) {\n    currentState = {\n      id: uniqueId(),\n      url: window.location.href,\n      title: document.title,\n      container: contextSelector,\n      fragment: options.fragment\n    }\n    replaceState(currentState, currentState.title, currentState.url)\n  }\n\n  previousController?.abort()\n  const {signal} = (previousController = new AbortController())\n\n  if (options.push === true && options.replace !== true) {\n    // Cache current container element before replacing it\n    cachePush(currentState.id, cloneContents(context))\n\n    pushState(null, '', options.requestUrl)\n  }\n\n  dispatch(context, 'pjax:start', {url: options.url})\n  dispatch(context, 'pjax:send')\n\n  let response = undefined\n\n  const versions = findAllVersions()\n  try {\n    response = await fetch(options.url, {\n      signal,\n      method: options.type,\n      body: options.data,\n      headers: {\n        Accept: 'text/html',\n        'X-PJAX': 'true',\n        'X-PJAX-Container': contextSelector,\n        'X-Requested-With': 'XMLHttpRequest',\n        'X-PJAX-VERSION': versions.pjax ?? '',\n        'X-PJAX-CSP-VERSION': versions.csp ?? '',\n        'X-PJAX-CSS-VERSION': versions.css ?? '',\n        'X-PJAX-JS-VERSION': versions.js ?? ''\n      }\n    })\n  } catch (e) {\n    response = undefined\n  }\n\n  if (!response || !response.ok) {\n    const allowed = dispatch(context, 'pjax:error')\n\n    if (options.type === 'GET' && allowed) {\n      // Prefer X-PJAX-URL header if it was set, otherwise fallback to\n      // using the original requested url.\n      const serverUrl = response && response.headers.get('X-PJAX-URL')\n      const responseUrl = serverUrl ? parseURL(serverUrl).href : options.requestUrl\n\n      sendStats({pjaxFailureReason: 'response_error', requestUrl: options.requestUrl})\n      locationReplace(responseUrl)\n    }\n\n    dispatch(context, 'pjax:complete')\n    dispatch(context, 'pjax:end')\n    return\n  }\n\n  const previousState = currentState\n  const currentVersion = findVersion()\n  const latestVersion = response.headers.get('X-PJAX-Version')\n  const data = await response.text()\n\n  const container = extractContainer(data, response, options)\n  const {contents} = container\n\n  const containerUrl = parseURL(container.url)\n  if (hash) {\n    containerUrl.hash = hash\n    container.url = containerUrl.href\n  }\n\n  // If there is a layout version mismatch, hard load the new url\n  if (currentVersion && latestVersion && currentVersion !== latestVersion) {\n    dispatch(context, 'pjax:hardLoad', {reason: 'version_mismatch'})\n    sendStats({pjaxFailureReason: 'version_mismatch', requestUrl: options.requestUrl})\n\n    locationReplace(container.url)\n    return\n  }\n\n  // If the new response is missing a body, hard load the page\n  if (!contents) {\n    dispatch(context, 'pjax:hardLoad', {reason: 'missing_response_body'})\n    sendStats({pjaxFailureReason: 'missing_response_body', requestUrl: options.requestUrl})\n    locationReplace(container.url)\n    return\n  }\n\n  currentState = {\n    id: options.id != null ? options.id : uniqueId(),\n    url: container.url,\n    title: container.title,\n    container: contextSelector,\n    fragment: options.fragment\n  }\n\n  if (options.push === true || options.replace === true) {\n    replaceState(currentState, container.title, container.url)\n  }\n\n  // Only blur the focus if the focused element is within the container.\n  const activeElement = document.activeElement\n  const blurFocus = options.container != null && options.container.contains(activeElement)\n\n  // Clear out any focused controls before inserting new page contents.\n  if (activeElement instanceof HTMLElement && blurFocus) {\n    try {\n      // eslint-disable-next-line github/no-blur\n      activeElement.blur()\n    } catch (e) {\n      // nothing\n    }\n  }\n\n  if (container.title) document.title = container.title\n\n  dispatch(context, 'pjax:beforeReplace', {\n    contents,\n    state: currentState,\n    previousState\n  })\n\n  replaceWithNodes(context, contents)\n  replaceCachedElements()\n  replaceTransientTags()\n\n  // FF bug: Won't autofocus fields that are inserted via JS.\n  // This behavior is incorrect. So if theres no current focus, autofocus\n  // the last field.\n  //\n  // http://www.w3.org/html/wg/drafts/html/master/forms.html\n  const autofocusEl = context.querySelector<HTMLElement>('input[autofocus], textarea[autofocus]')\n  if (autofocusEl && document.activeElement !== autofocusEl) {\n    autofocusEl.focus()\n  }\n\n  if (container.scripts) {\n    executeScriptTags(container.scripts)\n  }\n\n  if (container.stylesheets) {\n    injectStyleTags(container.stylesheets)\n  }\n\n  let scrollTo = options.scrollTo\n\n  // Ensure browser scrolls to the element referenced by the URL anchor\n  if (hash) {\n    const target = findFragmentTarget(document, hash)\n    if (target) {\n      const targetRect = target.getBoundingClientRect()\n      scrollTo = targetRect.top + window.pageYOffset\n    }\n  }\n\n  if (typeof scrollTo === 'number') {\n    window.scrollTo(window.pageXOffset, scrollTo)\n  }\n\n  dispatch(context, 'pjax:success')\n  dispatch(context, 'pjax:complete')\n  dispatch(context, 'pjax:end')\n}\n\n// Hard replace current state with url.\n//\n// Work for around WebKit\n//   https://bugs.webkit.org/show_bug.cgi?id=93506\nfunction locationReplace(url: string) {\n  if (currentState) {\n    replaceState(null, '', currentState.url)\n  }\n  window.location.replace(url)\n}\n\nlet initialPop = true\nconst initialURL: string = window.location.href\nconst initialState: State | null = window.history.state\n\n// Initialize currentState if possible\n// Happens when reloading a page and coming forward from a different\n// session history.\nif (initialState && initialState.container) {\n  currentState = initialState\n}\n\n// Non-webkit browsers don't fire an initial popstate event\nif ('state' in window.history) {\n  initialPop = false\n}\n\n// popstate handler takes care of the back and forward buttons\n//\n// You probably shouldn't use pjax on pages with other pushState\n// stuff yet.\nfunction onPjaxPopstate(event: PopStateEvent) {\n  if (isFeatureEnabled('PJAX_DISABLED') || isFeatureEnabled('TURBO')) return\n\n  // Hitting back or forward should override any pending PJAX request.\n  if (!initialPop) {\n    previousController?.abort()\n  }\n\n  const previousState = currentState\n  const state: State | null = event.state\n  let direction: Direction = null\n\n  if (state && state.container) {\n    // When coming forward from a separate history session, will get an\n    // initial pop with a state we are already at. Skip reloading the current\n    // page.\n    if (initialPop && initialURL === state.url) return\n\n    if (previousState) {\n      // If popping back to the same state, just skip.\n      // Could be clicking back from hashchange rather than a pushState.\n      if (previousState.id === state.id) return\n\n      // Since state IDs always increase, we can deduce the navigation direction\n      direction = previousState.id < state.id ? 'forward' : 'back'\n    }\n\n    const [containerSelector, contents, cachedAt] = cacheMapping[state.id] || []\n    const container = document.querySelector(containerSelector || state.container)\n\n    if (container instanceof HTMLElement) {\n      if (previousState) {\n        // Cache current container before replacement and inform the\n        // cache which direction the history shifted.\n        cachePop(direction, previousState.id, cloneContents(container))\n      }\n\n      dispatch(container, 'pjax:popstate', {state, direction, cachedAt})\n\n      const options: PjaxOptions = {\n        id: state.id,\n        url: state.url,\n        container,\n        push: false,\n        fragment: state.fragment || '',\n        scrollTo: false\n      }\n\n      if (contents) {\n        dispatch(container, 'pjax:start')\n\n        currentState = state\n        if (state.title) document.title = state.title\n        dispatch(container, 'pjax:beforeReplace', {contents, state, previousState})\n\n        replaceWithNodes(container, contents)\n        replaceCachedElements()\n        replaceTransientTags()\n        dispatch(container, 'pjax:end')\n      } else {\n        pjaxRequest(options)\n      }\n\n      // Force reflow/relayout before the browser tries to restore the\n      // scroll position.\n      container.offsetHeight\n    } else {\n      // No pjax container is an error on the source page, report using the previous state's url\n      sendStats({pjaxFailureReason: 'no_container', requestUrl: previousState?.url})\n      locationReplace(location.href)\n    }\n  }\n  initialPop = false\n}\n\n// Generate unique id for state object.\n//\n// Use a timestamp instead of a counter since ids should still be\n// unique across page loads.\nfunction uniqueId(): number {\n  return new Date().getTime()\n}\n\nfunction cloneContents(container: Element): CacheItem {\n  const cloned = container.cloneNode(true)\n  const contextSelector = getContainerSelector(container)\n  return [contextSelector, Array.from(cloned.childNodes), Date.now()]\n}\n\nfunction parseURL(url: string): HTMLAnchorElement {\n  const a = document.createElement('a')\n  a.href = url\n  return a\n}\n\nfunction getContainerSelector(container: Element): string {\n  if (container.id) {\n    return `#${container.id}`\n  } else {\n    throw new Error('pjax container has no id')\n  }\n}\n\nfunction findAll<T extends Element>(nodes: Node[], selector: string, klass: new () => T): T[] {\n  let matches: T[] = []\n  for (const node of nodes) {\n    if (node instanceof Element) {\n      if (node instanceof klass && node.matches(selector)) {\n        matches.push(node)\n      }\n      matches = matches.concat(Array.from(node.querySelectorAll(selector)))\n    }\n  }\n  return matches\n}\n\n// Clear the container and append all the given nodes to it\nfunction replaceWithNodes(container: Element, nodes: Node[]) {\n  container.innerHTML = ''\n  for (const node of nodes) {\n    // A node may be null if a pjax:beforeReplace listener nulls them out\n    // directly from the array emitted with the event\n    if (node != null) {\n      container.appendChild(node)\n    }\n  }\n}\n\nfunction resolveUrl(response: Response, fallbackUrl: string) {\n  // Prefer X-PJAX-URL header if it was set, otherwise fallback to\n  // using the original requested url.\n  const serverUrl = response.headers.get('X-PJAX-URL')\n  return serverUrl ? parseURL(serverUrl).href : fallbackUrl\n}\n\ntype extractedContainer = {\n  url: string\n  title: string\n  contents?: Node[]\n  scripts?: HTMLScriptElement[]\n  stylesheets?: HTMLLinkElement[]\n}\n\n// Extracts container and metadata from response.\n//\n// 1. Extracts X-PJAX-URL header if set\n// 2. Extracts inline <title> tags\n// 3. Builds response Element and extracts fragment if set\nfunction extractContainer(data: string, response: Response, options: PjaxOptions): extractedContainer {\n  const obj: extractedContainer = {\n    url: resolveUrl(response, options.requestUrl!),\n    title: ''\n  }\n\n  const fullDocument = /<html/i.test(data)\n\n  // Return fast if response is of a type other than HTML\n  const contentType = (response.headers.get('Content-Type') || '').split(';', 1)[0].trim()\n  if (contentType !== 'text/html') {\n    return obj\n  }\n\n  let head\n  let body\n\n  // Attempt to parse response html into elements\n  if (fullDocument) {\n    const headMatch = data.match(/<head[^>]*>([\\s\\S.]*)<\\/head>/i)\n    const bodyMatch = data.match(/<body[^>]*>([\\s\\S.]*)<\\/body>/i)\n    head = headMatch ? Array.from(parseHTML(document, headMatch[0]).childNodes) : []\n    body = bodyMatch ? Array.from(parseHTML(document, bodyMatch[0]).childNodes) : []\n  } else {\n    head = body = Array.from(parseHTML(document, data).childNodes)\n  }\n\n  // If response data is empty, return fast\n  if (body.length === 0) return obj\n\n  // If there's a <title> tag in the header, use it as\n  // the page's title.\n  const titles = findAll(head, 'title', HTMLTitleElement)\n  obj.title = titles.length > 0 ? titles[titles.length - 1].textContent || '' : ''\n\n  let fragment\n  if (options.fragment) {\n    // If they specified a fragment, look for it in the response\n    // and pull it out.\n    if (options.fragment === 'body') {\n      fragment = body\n    } else {\n      const matchingFragments = findAll(body, options.fragment, Element)\n      // Use first fragment if multiple matches\n      fragment = matchingFragments.length > 0 ? [matchingFragments[0]] : []\n    }\n\n    if (fragment.length) {\n      if (options.fragment === 'body') {\n        obj.contents = fragment\n      } else {\n        obj.contents = fragment.flatMap(node => Array.from(node.childNodes))\n      }\n\n      // If there's no title, look for data-title and title attributes\n      // on the fragment\n      if (!obj.title) {\n        const firstNode = fragment[0]\n        if (firstNode instanceof Element) {\n          obj.title = firstNode.getAttribute('title') || firstNode.getAttribute('data-title') || ''\n        }\n      }\n    }\n  } else if (!fullDocument) {\n    obj.contents = body\n  }\n\n  // Clean up any <title> tags\n  if (obj.contents) {\n    // Remove any parent title elements\n    obj.contents = obj.contents.filter(function (node) {\n      if (node instanceof Element) {\n        return !node.matches('title')\n      }\n      return true\n    })\n\n    // Then scrub any titles from their descendants\n    for (const node of obj.contents) {\n      if (node instanceof Element) {\n        for (const title of node.querySelectorAll('title')) {\n          title.remove()\n        }\n      }\n    }\n\n    // Gather all script[src] elements\n    const scripts = findAll(obj.contents, 'script[src]', HTMLScriptElement)\n    for (const script of scripts) {\n      script.remove()\n    }\n    obj.scripts = scripts\n    obj.contents = obj.contents.filter(node => scripts.indexOf(node as HTMLScriptElement) === -1)\n\n    // Gather all stylesheet elements\n    const stylesheets = findAll(obj.contents, 'link[rel=stylesheet]', HTMLLinkElement)\n    for (const stylesheet of stylesheets) {\n      stylesheet.remove()\n    }\n    obj.stylesheets = stylesheets\n    obj.contents = obj.contents.filter(node => !stylesheets.includes(node as HTMLLinkElement))\n  }\n\n  // Trim any whitespace off the title\n  if (obj.title) obj.title = obj.title.trim()\n\n  return obj\n}\n\n// Load and execute scripts using standard script request.\nfunction executeScriptTags(scripts: HTMLScriptElement[]) {\n  const existingScripts = document.querySelectorAll<HTMLScriptElement>('script[src]')\n\n  for (const script of scripts) {\n    const {src} = script\n    if (Array.from(existingScripts).some(s => s.src === src)) {\n      continue\n    }\n\n    const newScript = document.createElement('script')\n    const type = script.getAttribute('type')\n    if (type) newScript.type = type\n\n    const integrity = script.getAttribute('integrity')\n    if (integrity) {\n      newScript.integrity = integrity\n      newScript.crossOrigin = 'anonymous'\n    }\n\n    newScript.src = src\n    if (document.head) {\n      document.head.appendChild(newScript)\n    }\n  }\n}\n\n// Inject `link` elements that don't exist in the current document into the\n// documents <head>.\nfunction injectStyleTags(stylesheets: HTMLLinkElement[]) {\n  const existingStylesheets = document.querySelectorAll<HTMLLinkElement>('link[rel=stylesheet]')\n\n  for (const stylesheet of stylesheets) {\n    if (Array.from(existingStylesheets).some(s => s.href === stylesheet.href)) {\n      continue\n    }\n\n    if (document.head) {\n      document.head.appendChild(stylesheet)\n    }\n  }\n}\n\ntype CacheItem = [string, Node[], number]\n\n// History DOM caching class.\nconst cacheMapping: {[key: number]: CacheItem} = {}\nconst cacheForwardStack: number[] = []\nconst cacheBackStack: number[] = []\n\n// Push previous state id and container contents into the history\n// cache. Should be called in conjunction with `pushState` to save the\n// previous container contents.\nfunction cachePush(id: number, value: CacheItem) {\n  cacheMapping[id] = value\n  cacheBackStack.push(id)\n\n  // Remove all entries in forward history stack after pushing a new page.\n  trimCacheStack(cacheForwardStack, 0)\n\n  // Trim back history stack to max cache length.\n  trimCacheStack(cacheBackStack, maxCacheLength)\n}\n\ntype Direction = 'forward' | 'back' | null\n\n// Shifts cache from directional history cache. Should be\n// called on `popstate` with the previous state id and container\n// contents.\nfunction cachePop(direction: Direction, id: number, value: CacheItem) {\n  let pushStack\n  let popStack\n  cacheMapping[id] = value\n\n  if (direction === 'forward') {\n    pushStack = cacheBackStack\n    popStack = cacheForwardStack\n  } else {\n    pushStack = cacheForwardStack\n    popStack = cacheBackStack\n  }\n\n  pushStack.push(id)\n  const poppedId = popStack.pop()\n  if (poppedId) delete cacheMapping[poppedId]\n\n  // Trim whichever stack we just pushed to to max cache length.\n  trimCacheStack(pushStack, maxCacheLength)\n}\n\n// Trim a cache stack (either cacheBackStack or cacheForwardStack) to be no\n// longer than the specified length, deleting cached DOM elements as necessary.\n//\n// stack  - Array of state IDs\n// length - Maximum length to trim to\nfunction trimCacheStack(stack: number[], length: number) {\n  while (stack.length > length) {\n    const id = stack.shift()\n    if (id == null) return\n    delete cacheMapping[id]\n  }\n}\n\ninterface PjaxVersions {\n  pjax: string | null\n  csp: string | null\n  css: string | null\n  js: string | null\n}\n\n// Find version identifier for the initial page load.\nfunction findVersion(): string | null {\n  for (const meta of document.getElementsByTagName('meta')) {\n    const name = meta.getAttribute('http-equiv')\n    if (name && name.toUpperCase() === 'X-PJAX-VERSION') {\n      return meta.content\n    }\n  }\n  return null\n}\n\nfunction pjaxMeta(httpEquiv: string): string | null {\n  const meta = document.querySelector(`meta[http-equiv=\"${httpEquiv}\"]`) as HTMLMetaElement\n  return meta?.content ?? null\n}\n// Find version identifier for the initial page load.\nexport function findAllVersions(): PjaxVersions {\n  return {\n    pjax: pjaxMeta('X-PJAX-VERSION'),\n    csp: pjaxMeta('X-PJAX-CSP-VERSION'),\n    css: pjaxMeta('X-PJAX-CSS-VERSION'),\n    js: pjaxMeta('X-PJAX-JS-VERSION')\n  }\n}\n\nexport function getState(): State | null {\n  return currentState\n}\n\nwindow.addEventListener('popstate', onPjaxPopstate)\n","import {ready} from '../../document-ready'\n\nconst pjaxHeadCache: {[key: string]: Element[]} = {}\nconst pjaxReplaceCache: {[key: string]: Element[]} = {}\n\n;(async () => {\n  await ready\n  pjaxHeadCache[document.location.pathname] = Array.from(document.querySelectorAll('head [data-pjax-transient]'))\n  pjaxReplaceCache[document.location.pathname] = Array.from(document.querySelectorAll('[data-pjax-replace]'))\n})()\n\n// Extract special elements that are not to be inserted in the DOM verbatim.\ndocument.addEventListener('pjax:beforeReplace', function (event: Event) {\n  const contents = (event as CustomEvent).detail.contents || []\n  const container = event.target as Element\n  for (let i = 0; i < contents.length; i++) {\n    const elem = contents[i]\n    if (elem instanceof Element) {\n      if (elem.id === 'pjax-head') {\n        pjaxHeadCache[document.location.pathname] = Array.from(elem.children)\n        contents[i] = null\n      } else if (elem.hasAttribute('data-pjax-replace')) {\n        if (!pjaxReplaceCache[document.location.pathname]) pjaxReplaceCache[document.location.pathname] = []\n        pjaxReplaceCache[document.location.pathname].push(elem)\n\n        // Only null out elements outside the container since the container will\n        // be cleared completely so any elements inside it can be inserted as\n        // normal\n        if (!container.querySelector(`#${elem.id}`)) {\n          contents[i] = null\n        }\n      }\n    }\n  }\n})\n\nexport function replaceCachedElements() {\n  const cached = pjaxReplaceCache[document.location.pathname]\n  if (!cached) return\n  for (const elem of cached) {\n    const pjaxReplace = document.querySelector(`#${elem.id}`)\n    if (pjaxReplace) pjaxReplace.replaceWith(elem)\n  }\n}\n\nexport function replaceTransientTags() {\n  const cached = pjaxHeadCache[document.location.pathname]\n  if (!cached) return\n  const head = document.head\n\n  for (const el of document.querySelectorAll('head [data-pjax-transient]')) {\n    el.remove()\n  }\n  for (const el of cached) {\n    if (!el.matches('title, script, link[rel=stylesheet]')) {\n      el.setAttribute('data-pjax-transient', '')\n      head.append(el)\n    } else if (el.matches('link[rel=stylesheet]')) {\n      head.append(el)\n    }\n  }\n}\n","// Check if document has passed interactive state.\n//\n// The document has finished loading and the document has been parsed but\n// sub-resources such as images, stylesheets and frames are still loading.\n// The state indicates that the DOMContentLoaded event has been fired.\nexport const ready: Promise<void> = (function () {\n  if (document.readyState === 'interactive' || document.readyState === 'complete') {\n    return Promise.resolve()\n  } else {\n    return new Promise<void>(resolve => {\n      document.addEventListener('DOMContentLoaded', () => {\n        resolve()\n      })\n    })\n  }\n})()\n\n// Check if document has passed loaded state.\n//\n// The document and all sub-resources have finished loading. The state\n// indicates that the load event has been fired.\nexport const loaded: Promise<unknown> = (function () {\n  if (document.readyState === 'complete') {\n    return Promise.resolve()\n  } else {\n    return new Promise(resolve => {\n      window.addEventListener('load', resolve)\n    })\n  }\n})()\n","import memoize from '@github/memoize'\n\nconst features = memoize(enabledFeatures)\n\nfunction enabledFeatures(): string[] {\n  return (document.head?.querySelector<HTMLMetaElement>('meta[name=\"enabled-features\"]')?.content || '').split(',')\n}\n\nconst isFeatureEnabled = memoize(isEnabled)\n\nfunction isEnabled(name: string): boolean {\n  return features().indexOf(name) !== -1\n}\n\nexport {isFeatureEnabled}\n","// Find element within document matching location hash.\nexport function findFragmentTarget(document: Document, hash: string = location.hash): Element | null {\n  return findElementByFragmentName(document, decodeFragmentValue(hash))\n}\n\n// Find element within document matching id or name.\nexport function findElementByFragmentName(document: Document, name: string): Element | null {\n  if (name === '') return null\n  return document.getElementById(name) || document.getElementsByName(name)[0]\n}\n\n// Decode location hash.\nexport function decodeFragmentValue(hash: string): string {\n  try {\n    return decodeURIComponent(hash.slice(1))\n  } catch {\n    return ''\n  }\n}\n","const sessionHistoryEntries: Array<{url: string; state: unknown}> = []\nlet sessionHistoryOffset = 0\nlet state: State\n\ntype State = {\n  _id: number\n}\n\n/*\n * Array of history entries.\n *\n * Example:\n * {\n *   0: {\n *     url: \"/\",\n *     state: { ... }.\n *   },\n *   1: {\n *     url: \"/github/github/issues/123\",\n *     state: { ... }.\n *   },\n *   2: {\n *     url: \"/github/github/issues/123#comment-4\",\n *     state: { ... }.\n *   }.\n *  }.\n */\n\nexport function getState(): State {\n  return state\n}\n\nfunction safeGetHistory() {\n  try {\n    // Clamp history.length to 0<->9007199254740991 (Number.MAX_SAFE_INTEGER isn't supported in IE)\n    return Math.min(Math.max(0, history.length) || 0, 9007199254740991)\n  } catch (e) {\n    return 0\n  }\n}\n\nfunction initializeState(): State {\n  const newState = {_id: new Date().getTime(), ...history.state}\n  setState(newState)\n  return newState\n}\n\n// Current index into history entries stack.\nfunction position(): number {\n  return safeGetHistory() - 1 + sessionHistoryOffset\n}\n\nfunction setState(newState: State) {\n  state = newState\n\n  // Update entry at current position\n  const url = location.href\n  sessionHistoryEntries[position()] = {url, state}\n\n  // Trim entries to match history size\n  sessionHistoryEntries.length = safeGetHistory()\n\n  // Emit public statechange\n  window.dispatchEvent(new CustomEvent('statechange', {bubbles: false, cancelable: false}))\n}\n\n// Generate unique id for state object.\n//\n// Use a timestamp instead of a counter since ids should still be unique\n// across page loads.\nfunction uniqueId(): number {\n  return new Date().getTime()\n}\n\n// Indirection for history.pushState to support tracking URL changes.\n//\n// Would be great if there was a standard window.addEventListener('statechange') event.\nexport function pushState(oldState: State | null, title: string, url: string) {\n  // pushState drops any forward history entries\n  sessionHistoryOffset = 0\n  const newState = {_id: uniqueId(), ...oldState}\n  history.pushState(newState, title, url)\n  setState(newState)\n}\n\n// Indirection for history.replaceState to support tracking URL changes.\n//\n// Would be great if there was a standard window.addEventListener('statechange') event.\nexport function replaceState(oldState: Record<string, unknown> | null, title: string, url: string) {\n  const newState = {...getState(), ...oldState}\n  history.replaceState(newState, title, url)\n  setState(newState)\n}\n\n// Get URL that be navigated to with history.back().\nexport function getBackURL(): string | undefined {\n  const entry = sessionHistoryEntries[position() - 1]\n  if (entry) {\n    return entry.url\n  }\n}\n\n// Get URL that be navigated to with history.forward().\nexport function getForwardURL(): string | undefined {\n  const entry = sessionHistoryEntries[position() + 1]\n  if (entry) {\n    return entry.url\n  }\n}\n\nstate = initializeState()\n\nwindow.addEventListener(\n  'popstate',\n  function onPopstate(event: PopStateEvent) {\n    const currentState: State = event.state\n\n    if (!currentState || !currentState._id) {\n      // Unmanaged state in history entries\n      // Or could be a hashchange pop, ignore and let hashchange handle it\n      return\n    }\n\n    const id = currentState._id\n    if (id < (getState()._id || NaN)) {\n      sessionHistoryOffset--\n    } else {\n      sessionHistoryOffset++\n    }\n\n    setState(currentState)\n  },\n  true\n)\n\nwindow.addEventListener(\n  'hashchange',\n  function onHashchange() {\n    if (safeGetHistory() > sessionHistoryEntries.length) {\n      // Forward navigation\n      const newState = {_id: uniqueId()}\n      history.replaceState(newState, '', location.href)\n      setState(newState)\n    }\n  },\n  true\n)\n","export function parseHTML(document: Document, html: string): DocumentFragment {\n  const template = document.createElement('template')\n  template.innerHTML = html\n  return document.importNode(template.content, true)\n}\n","// Attempt to detect if GitHub is being proxied.\nexport default function detectProxySite(document: Document): boolean {\n  const hostname = document.head?.querySelector<HTMLMetaElement>('meta[name=\"expected-hostname\"]')?.content\n\n  // ignore proxy detection if no meta tag is configured\n  if (!hostname) {\n    return false\n  }\n\n  // account for trailing . in hostname.\n  const expected = hostname.replace(/\\.$/, '').split('.').slice(-2).join('.')\n  const actual = document.location.hostname.replace(/\\.$/, '').split('.').slice(-2).join('.')\n\n  return expected !== actual\n}\n","import detectProxySite from './proxy-site-detection'\nimport {loaded} from './document-ready'\n\nlet stats: PlatformBrowserStat[] = []\n\nexport function sendStats(stat: PlatformBrowserStat, flushImmediately = false): void {\n  if (stat.timestamp === undefined) stat.timestamp = new Date().getTime()\n  stat.loggedIn = isLoggedIn()\n  stat.bundler = 'webpack'\n  stats.push(stat)\n\n  if (flushImmediately) {\n    flushStats()\n  } else {\n    scheduleSendStats()\n  }\n}\n\nlet queued: number | null = null\n\nasync function scheduleSendStats() {\n  await loaded\n  if (queued == null) {\n    queued = window.requestIdleCallback(flushStats)\n  }\n}\n\nfunction flushStats() {\n  queued = null\n  if (!stats.length || detectProxySite(document)) {\n    return\n  }\n\n  const url = document.head?.querySelector<HTMLMetaElement>('meta[name=\"browser-stats-url\"]')?.content\n  if (!url) {\n    return\n  }\n\n  const data = JSON.stringify({stats})\n  try {\n    if (navigator.sendBeacon) {\n      navigator.sendBeacon(url, data)\n    }\n  } catch {\n    // Silently ignore errors: https://github.com/github/github/issues/178088#issuecomment-829936461\n  }\n  stats = []\n}\n\nfunction isLoggedIn(): boolean {\n  return !!document.head?.querySelector<HTMLMetaElement>('meta[name=\"user-login\"]')?.content\n}\n\n// Flush stats before users navigate away from the page\ndocument.addEventListener('pagehide', flushStats)\ndocument.addEventListener('visibilitychange', flushStats)\n"],"sourceRoot":""}