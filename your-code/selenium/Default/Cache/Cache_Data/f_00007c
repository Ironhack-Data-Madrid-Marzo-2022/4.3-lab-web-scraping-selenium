{"version":3,"sources":["app/assets/modules/github/behaviors/commenting/edit.ts","app/assets/modules/github/behaviors/html-validation.ts","app/assets/modules/github/updatable-content.ts"],"names":[],"mappings":"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","file":"5222-xxxxxxxxxxxx.js","sourcesContent":["// Commenting: Edit and delete buttons\n\n// eslint-disable-next-line no-restricted-imports\nimport {fire, on} from 'delegated-events'\nimport IncludeFragmentElement from '@github/include-fragment-element'\n\nimport {dialog} from '../../details-dialog'\nimport {fetchSafeDocumentFragment} from '../../fetch'\nimport {fromEvent} from '../../subscription'\nimport {hasDirtyFields} from '../../has-interactions'\n// eslint-disable-next-line no-restricted-imports\nimport {observe} from 'selector-observer'\nimport {remoteForm} from '@github/remote-form'\nimport {updateContent} from '../../updatable-content'\n\nlet bodyErrors: string[] = []\n\n// Preload the edit form fragment when the dropdown menu is loaded\nobserve('.js-comment-header-actions-deferred-include-fragment', {\n  subscribe: el =>\n    fromEvent(\n      el,\n      'loadstart',\n      () => {\n        const container = el.closest<HTMLElement>('.js-comment')!\n        loadEditFormDeferredIncludeFragment(container)\n      },\n      {capture: false, once: true}\n    )\n})\n\n// If the comment contains a task list we need to immediately load the edit form\n// because it's used to decide if the user can edit tasks in the list or not\nobserve('.js-comment .contains-task-list', {\n  add: el => {\n    const container = el.closest<HTMLElement>('.js-comment')!\n    loadEditFormDeferredIncludeFragment(container)\n  }\n})\n\n// Edit button\non('click', '.js-comment-edit-button', function (event) {\n  const container = event.currentTarget.closest<HTMLElement>('.js-comment')!\n  container.classList.add('is-comment-editing')\n\n  // Focus on the edit form when it is loaded\n  const editFormIncludeFragment = findEditFormDeferredIncludeFragment(container)\n  if (!editFormIncludeFragment) {\n    // Edit form is already loaded into the DOM so just focus on it\n    focusEditForm(container)\n  } else {\n    // If an <include-fragment> exists, wait till it's loaded before focusing\n    editFormIncludeFragment.addEventListener('include-fragment-replaced', () => focusEditForm(container), {once: true})\n  }\n\n  const dropdown = event.currentTarget.closest('.js-dropdown-details')\n  if (dropdown) {\n    dropdown.removeAttribute('open')\n  }\n})\n\nfunction focusEditForm(container: HTMLElement) {\n  container.querySelector<HTMLElement>('.js-write-tab')!.click()\n  const field = container.querySelector<HTMLElement>('.js-comment-field')!\n  ;(field as HTMLTextAreaElement).focus()\n  // Trigger size-to-fit (see #15696)\n  fire(field, 'change')\n}\n\nfunction findEditFormDeferredIncludeFragment(container: HTMLElement) {\n  return container.querySelector<IncludeFragmentElement>('.js-comment-edit-form-deferred-include-fragment')\n}\n\n// By default the edit form include fragment is set to `loading=lazy` to avoid triggering\n// loading on pageload, however sometimes we want to pre-emptively load it\nfunction loadEditFormDeferredIncludeFragment(container: HTMLElement) {\n  findEditFormDeferredIncludeFragment(container)?.setAttribute('loading', 'eager')\n}\n\n// Show minimize form button\non('click', '.js-comment-hide-button', function (event) {\n  const comment = event.currentTarget.closest<HTMLElement>('.js-comment')!\n  toggleMinimizeError(comment, false)\n  const minimizeForm = comment.querySelector('.js-minimize-comment')\n  /* eslint-disable-next-line github/no-d-none */\n  if (minimizeForm) minimizeForm.classList.remove('d-none')\n\n  const dropdown = event.currentTarget.closest('.js-dropdown-details')\n  if (dropdown) {\n    dropdown.removeAttribute('open')\n  }\n})\n\n// Hide minimize form button\non('click', '.js-comment-hide-minimize-form', function (event) {\n  const minimizeForm = event.currentTarget.closest<HTMLElement>('.js-minimize-comment')!\n  /* eslint-disable-next-line github/no-d-none */\n  minimizeForm.classList.add('d-none')\n})\n\n// Comment Cancel button\nexport function handleCommentCancelButtonClick(event: Event & {currentTarget: Element}) {\n  const form = event.currentTarget.closest<HTMLFormElement>('form')!\n  const confirmText = event.currentTarget.getAttribute('data-confirm-text')!\n  if (hasDirtyFields(form) && !confirm(confirmText)) {\n    return false\n  }\n\n  for (const field of form.querySelectorAll('input, textarea')) {\n    const fieldEl = field as HTMLInputElement | HTMLTextAreaElement\n    fieldEl.value = fieldEl.defaultValue\n\n    if (fieldEl.classList.contains('session-resumable-canceled')) {\n      fieldEl.classList.add('js-session-resumable')\n      fieldEl.classList.remove('session-resumable-canceled')\n    }\n  }\n\n  const comment = event.currentTarget.closest('.js-comment')\n  if (comment) {\n    comment.classList.remove('is-comment-editing')\n  }\n\n  return true\n}\non('click', '.js-comment-cancel-button', handleCommentCancelButtonClick)\n\n// Issue edit cancel\non('click', '.js-cancel-issue-edit', function (event) {\n  const container = event.currentTarget.closest<HTMLElement>('.js-details-container')!\n  container.querySelector<HTMLElement>('.js-comment-form-error')!.hidden = true\n})\n\n// Show loading state for updating, deleting, minimizing, and unminimizing\n// Add version so server can decide if we're working with fresh data\nremoteForm(\n  '.js-comment-delete, .js-comment .js-comment-update, .js-issue-update, .js-comment-minimize, .js-comment-unminimize',\n  function (form, wants, request) {\n    const comment = form.closest<HTMLElement>('.js-comment')!\n    comment.classList.add('is-comment-loading')\n    const bodyVersion = comment.getAttribute('data-body-version')\n    if (bodyVersion) {\n      request.headers.set('X-Body-Version', bodyVersion)\n    }\n  }\n)\n\n// Rejected updates that are stale freezes the form and shows an error.\n// See AbstractRepositoryController#render_stale_error for stale error response.\nremoteForm('.js-comment .js-comment-update', async function (form, wants) {\n  let response\n  const comment = form.closest<HTMLElement>('.js-comment')!\n  const updateError = comment.querySelector('.js-comment-update-error')\n  const bodyError = comment.querySelector('.js-comment-body-error')\n  if (updateError instanceof HTMLElement) {\n    updateError.hidden = true\n  }\n  if (bodyError instanceof HTMLElement) {\n    bodyError.hidden = true\n  }\n  bodyErrors = []\n\n  try {\n    response = await wants.json()\n  } catch (error) {\n    if (error.response.status === 422) {\n      const data = JSON.parse(error.response.text)\n\n      if (data.errors) {\n        if (updateError instanceof HTMLElement) {\n          // eslint-disable-next-line i18n-text/no-en\n          updateError.textContent = `There was an error posting your comment: ${data.errors.join(', ')}`\n          updateError.hidden = false\n        }\n        return\n      }\n    } else {\n      throw error\n    }\n  }\n\n  if (!response) return\n  const data = response.json\n\n  if (data.errors && data.errors.length > 0) {\n    bodyErrors = data.errors\n    showBodyErrors(bodyError as HTMLElement)\n  }\n\n  const commentBody = comment.querySelector('.js-comment-body')\n  if (commentBody && data.body) {\n    commentBody.innerHTML = data.body\n  }\n\n  comment.setAttribute('data-body-version', data.newBodyVersion)\n  const bodyVersionInput = comment.querySelector('.js-body-version')\n  if (bodyVersionInput instanceof HTMLInputElement) {\n    bodyVersionInput.value = data.newBodyVersion\n  }\n\n  const discussionPoll = comment.querySelector('.js-discussion-poll')\n  if (discussionPoll && data.poll) {\n    discussionPoll.innerHTML = data.poll\n  }\n\n  for (const field of comment.querySelectorAll('input, textarea')) {\n    const fieldEl = field as HTMLInputElement | HTMLTextAreaElement\n    fieldEl.defaultValue = fieldEl.value\n  }\n\n  // If the comment was previously stale, remove the warning as it is now fresh\n  comment.classList.remove('is-comment-stale', 'is-comment-editing')\n\n  const edits = comment.querySelector('.js-comment-edit-history')\n  if (edits) {\n    const html = await fetchSafeDocumentFragment(document, data.editUrl)\n    edits.innerHTML = ''\n    edits.append(html)\n  }\n})\n\n// this block will show the error block if there were errors on body modification\nobserve('.js-comment-body-error', {\n  add: el => {\n    if (bodyErrors && bodyErrors.length > 0) {\n      showBodyErrors(el as HTMLElement)\n    }\n  }\n})\n\nfunction showBodyErrors(el: HTMLElement) {\n  const ol = el.querySelector('ol')\n  if (ol) {\n    ol.innerHTML = ''\n    const items = bodyErrors.map(e => {\n      const li = document.createElement('li')\n      li.textContent = e\n      return li\n    })\n    for (const li of items) {\n      ol.appendChild(li)\n    }\n  }\n  el.hidden = false\n}\n\n// Hide loading state for updating, deleting, minimizing, and unminimizing\nremoteForm(\n  '.js-comment .js-comment-delete, .js-comment .js-comment-update, .js-comment-minimize, .js-comment-unminimize',\n  async function (form, wants) {\n    const comment = form.closest<HTMLElement>('.js-comment')!\n    try {\n      await wants.text()\n    } catch (error) {\n      if (error.response.status === 422) {\n        let data\n        try {\n          data = JSON.parse(error.response.text)\n        } catch (e) {\n          // Do nothing\n        }\n\n        if (data && data.stale) comment.classList.add('is-comment-stale')\n      } else {\n        throw error\n      }\n    }\n\n    comment.classList.remove('is-comment-loading')\n  }\n)\n\nfunction toggleMinimizeError(comment: HTMLElement, errored: boolean) {\n  const minimizeError = comment.querySelector<HTMLElement>('.js-comment-show-on-error')\n  if (minimizeError) {\n    minimizeError.hidden = !errored\n  }\n  const minimizeForm = comment.querySelector<HTMLElement>('.js-comment-hide-on-error')\n  if (minimizeForm) {\n    minimizeForm.hidden = errored\n  }\n}\n\nremoteForm('.js-timeline-comment-unminimize, .js-timeline-comment-minimize', async function (form, wants) {\n  const comment = form.closest<HTMLElement>('.js-minimize-container')!\n  try {\n    const response = await wants.html()\n    comment.replaceWith(response.html)\n  } catch (error) {\n    toggleMinimizeError(comment, true)\n  }\n})\n\nremoteForm('.js-discussion-comment-unminimize, .js-discussion-comment-minimize', async function (form, wants) {\n  const comment = form.closest<HTMLElement>('.js-discussion-comment')!\n  const minimizeError = comment.querySelector<HTMLElement>('.js-discussion-comment-error')\n  if (minimizeError) {\n    minimizeError.hidden = true\n  }\n\n  try {\n    const response = await wants.html()\n    comment.replaceWith(response.html)\n  } catch (error) {\n    if (error.response.status >= 400 && error.response.status < 500) {\n      if (error.response.html) {\n        const errorMessage = error.response.html.querySelector('.js-discussion-comment')!.getAttribute('data-error')!\n        if (minimizeError instanceof HTMLElement) {\n          minimizeError.textContent = errorMessage\n          minimizeError.hidden = false\n        }\n      }\n    } else {\n      throw error\n    }\n  }\n})\n\n// Remove comment if deleted successfully\nremoteForm('.js-comment-delete', async function (form, wants) {\n  await wants.json()\n  let container = form.closest('.js-comment-delete-container')\n\n  if (!container) {\n    container = form.closest('.js-comment-container') || form.closest('.js-line-comments')\n\n    if (container && container.querySelectorAll('.js-comment').length !== 1) {\n      container = form.closest<HTMLElement>('.js-comment')!\n    }\n  }\n\n  container!.remove()\n})\n\n// Update issue/PR/discussion title if successful\nremoteForm('.js-issue-update', async function (form, wants) {\n  const container = form.closest<HTMLElement>('.js-details-container')!\n  const errorDisplay = container.querySelector<HTMLElement>('.js-comment-form-error')!\n\n  let response\n  try {\n    response = await wants.json()\n  } catch (error) {\n    // eslint-disable-next-line i18n-text/no-en\n    errorDisplay.textContent = error.response?.json?.errors?.[0] || 'Something went wrong. Please try again.'\n    errorDisplay.hidden = false\n  }\n\n  if (!response) return\n\n  container.classList.remove('open')\n  errorDisplay.hidden = true\n  const data = response.json\n  if (data.issue_title != null) {\n    container.querySelector<HTMLElement>('.js-issue-title')!.textContent = data.issue_title\n    const issuesContainer = container.closest('.js-issues-results')\n    if (issuesContainer) {\n      if (issuesContainer.querySelector('.js-merge-pr.is-merging')) {\n        const mergeField = issuesContainer.querySelector('.js-merge-pull-request textarea')\n        if (mergeField instanceof HTMLTextAreaElement && mergeField.value === mergeField.defaultValue) {\n          mergeField.value = mergeField.defaultValue = data.issue_title\n        }\n      } else if (issuesContainer.querySelector('.js-merge-pr.is-squashing')) {\n        const mergeField = issuesContainer.querySelector('.js-merge-pull-request .js-merge-title')\n        if (mergeField instanceof HTMLInputElement && mergeField.value === mergeField.defaultValue) {\n          mergeField.value = mergeField.defaultValue = data.default_squash_commit_title\n        }\n      }\n\n      const mergeButton = issuesContainer.querySelector('button[value=merge]')\n      if (mergeButton) {\n        mergeButton.setAttribute('data-input-message-value', data.issue_title)\n      }\n\n      const squashInput = issuesContainer.querySelector('button[value=squash]')\n      if (squashInput) {\n        squashInput.setAttribute('data-input-title-value', data.default_squash_commit_title)\n      }\n    }\n  }\n  document.title = data.page_title\n  for (const field of form.elements) {\n    if (field instanceof HTMLInputElement || field instanceof HTMLTextAreaElement) {\n      field.defaultValue = field.value\n    }\n  }\n})\n\n// Hide comment if minimized successfully\nremoteForm('.js-comment-minimize', async function (form, wants) {\n  await wants.json()\n  const comment = form.closest<HTMLElement>('.js-comment')!\n\n  const minimizeForm = comment.querySelector('.js-minimize-comment')\n\n  if (minimizeForm && minimizeForm.classList.contains('js-update-minimized-content')) {\n    const submitButton = form.querySelector<HTMLInputElement | HTMLButtonElement>(\n      'input[type=submit], button[type=submit]'\n    )\n\n    if (submitButton) {\n      submitButton.classList.add('disabled')\n    }\n    const updatableCommentContainer = comment.closest<HTMLElement>('.js-comment-container')\n    if (updatableCommentContainer) {\n      await updateContent(updatableCommentContainer)\n    }\n  } else {\n    /* eslint-disable-next-line github/no-d-none */\n    if (minimizeForm) minimizeForm.classList.add('d-none')\n    const unminimizedComment = form.closest<HTMLElement>('.unminimized-comment')!\n    /* eslint-disable-next-line github/no-d-none */\n    unminimizedComment.classList.add('d-none')\n    unminimizedComment.classList.remove('js-comment')\n\n    const commentGroup = form.closest<HTMLElement>('.js-minimizable-comment-group')!\n    const minimizedComment = commentGroup.querySelector('.minimized-comment')\n    /* eslint-disable-next-line github/no-d-none */\n    if (minimizedComment) minimizedComment.classList.remove('d-none')\n    if (minimizedComment) minimizedComment.classList.add('js-comment')\n  }\n})\n\n// Show comment if unminimized successfully\nremoteForm('.js-comment-unminimize', async function (form, wants) {\n  await wants.json()\n  const commentGroup = form.closest<HTMLElement>('.js-minimizable-comment-group')!\n  const unminimizedComment = commentGroup.querySelector('.unminimized-comment')\n  const minimizedComment = commentGroup.querySelector('.minimized-comment')\n\n  if (unminimizedComment) {\n    /* eslint-disable-next-line github/no-d-none */\n    unminimizedComment.classList.remove('d-none')\n    unminimizedComment.classList.add('js-comment')\n\n    /* eslint-disable-next-line github/no-d-none */\n    if (minimizedComment) minimizedComment.classList.add('d-none')\n    if (minimizedComment) minimizedComment.classList.remove('js-comment')\n  } else {\n    // if the unminimizedComment is not present at this point,\n    // try to fetch it from the server\n    if (minimizedComment) {\n      const actionForm = minimizedComment.querySelector('.timeline-comment-actions')\n      // hide form while waiting for updated content\n      /* eslint-disable-next-line github/no-d-none */\n      if (actionForm) actionForm.classList.add('d-none')\n      minimizedComment.classList.remove('js-comment')\n    }\n\n    const updatableCommentContainer = commentGroup.closest<HTMLElement>('.js-comment-container')!\n    await updateContent(updatableCommentContainer)\n  }\n})\n\non(\n  'details-menu-select',\n  '.js-comment-edit-history-menu',\n  event => {\n    const url = (event as CustomEvent).detail.relatedTarget.getAttribute('data-edit-history-url')\n    if (!url) return\n    // Prevent menu from closing\n    event.preventDefault()\n    const content = fetchSafeDocumentFragment(document, url)\n    dialog({content, dialogClass: 'Box-overlay--wide'})\n  },\n  {capture: true}\n)\n","import {onFocus, onInput} from '../onfocus'\n// eslint-disable-next-line no-restricted-imports\nimport {observe} from 'selector-observer'\n// eslint-disable-next-line no-restricted-imports\nimport {on} from 'delegated-events'\n\nconst supportedFields = [\n  'input[pattern]',\n  'input[required]',\n  'textarea[required]',\n  'input[data-required-change]',\n  'textarea[data-required-change]',\n  'input[data-required-value]',\n  'textarea[data-required-value]'\n].join(',')\n\ntype Field = HTMLInputElement | HTMLTextAreaElement\n\nfunction checkValidityForRequiredValueField(field: Field) {\n  const requiredValue = field.getAttribute('data-required-value')!\n  const prefix = field.getAttribute('data-required-value-prefix')\n\n  if (field.value === requiredValue) {\n    field.setCustomValidity('')\n  } else {\n    let message = requiredValue\n    if (prefix) {\n      message = prefix + message\n    }\n    field.setCustomValidity(message)\n  }\n}\n\nonInput('[data-required-value]', function (event) {\n  const field = event.currentTarget as Field\n  checkValidityForRequiredValueField(field)\n})\n\non('change', '[data-required-value]', function (event) {\n  const field = event.currentTarget as Field\n  checkValidityForRequiredValueField(field)\n\n  // We need to call validate since we don't fire a `change` event on the form\n  // when session-resume dumps the text back into the field.\n  validate(field.form!)\n})\n\nonInput('[data-required-trimmed]', function (event) {\n  const field = event.currentTarget as Field\n  if (field.value.trim() === '') {\n    field.setCustomValidity(field.getAttribute('data-required-trimmed')!)\n  } else {\n    field.setCustomValidity('')\n  }\n})\n\non('change', '[data-required-trimmed]', function (event) {\n  const field = event.currentTarget as Field\n  if (field.value.trim() === '') {\n    field.setCustomValidity(field.getAttribute('data-required-trimmed')!)\n  } else {\n    field.setCustomValidity('')\n  }\n\n  // We need to call validate since we don't fire a `change` event on the form\n  // when session-resume dumps the text back into the field.\n  validate(field.form!)\n})\n\n// Observe required fields and validate form when their validation state\n// changes.\nonFocus(supportedFields, field => {\n  let previousValid = (field as Field).checkValidity()\n  function inputHandler() {\n    const currentValid = (field as Field).checkValidity()\n    if (currentValid !== previousValid && (field as Field).form) {\n      validate((field as Field).form!)\n    }\n    previousValid = currentValid\n  }\n\n  field.addEventListener('input', inputHandler)\n  field.addEventListener('blur', function blurHandler() {\n    field.removeEventListener('input', inputHandler)\n    field.removeEventListener('blur', blurHandler)\n  })\n})\n\nconst installedForms = new WeakMap()\n\n// Install validation handlers on a form.\nfunction installHandlers(form: HTMLFormElement) {\n  if (installedForms.get(form)) return\n  form.addEventListener('change', () => validate(form))\n  installedForms.set(form, true)\n}\n\n// Validate a form or input.\nexport function validate(form: HTMLInputElement | HTMLFormElement) {\n  const validity = form.checkValidity()\n  for (const button of form.querySelectorAll<HTMLButtonElement>('button[data-disable-invalid]')) {\n    button.disabled = !validity\n  }\n}\n\nobserve('button[data-disable-invalid]', {\n  constructor: HTMLButtonElement,\n  initialize(button) {\n    const form = button.form\n    if (form) {\n      installHandlers(form)\n      button.disabled = !form.checkValidity()\n    }\n  }\n})\n\n// A custom attribute similar to `required`, but only passes validation once\n// the value of the field has changed from its initial value.\nobserve('input[data-required-change], textarea[data-required-change]', function (element) {\n  const field = element as Field\n  const radioInputDefault =\n    field.type === 'radio' && field.form ? (field.form.elements.namedItem(field.name) as RadioNodeList).value : null\n\n  // Custom Validity Event Handler.\n  function customValidity(event?: Event) {\n    const form = field.form!\n    if (event && field.type === 'radio' && form && radioInputDefault) {\n      for (const radio of form.elements.namedItem(field.name) as RadioNodeList) {\n        if (radio instanceof HTMLInputElement) {\n          radio.setCustomValidity(field.value === radioInputDefault ? 'unchanged' : '')\n        }\n      }\n    } else {\n      field.setCustomValidity(field.value === (radioInputDefault || field.defaultValue) ? 'unchanged' : '')\n    }\n  }\n\n  field.addEventListener('input', customValidity)\n  field.addEventListener('change', customValidity)\n  customValidity()\n\n  if (field.form) {\n    validate(field.form)\n  }\n})\n\ndocument.addEventListener('reset', function (event: Event) {\n  if (event.target instanceof HTMLFormElement) {\n    const form = event.target\n    setTimeout(() => validate(form))\n  }\n})\n","import {hasInteractions} from './has-interactions'\n// eslint-disable-next-line no-restricted-imports\nimport {observe} from 'selector-observer'\nimport {parseHTML} from './parse-html'\nimport {preserveAnchorNodePosition} from 'scroll-anchoring'\nimport {replaceState} from './history'\n\nconst pendingRequests = new WeakMap<HTMLElement, AbortController>()\nconst staleRecords: {[key: string]: string} = {}\n\n// Wrapper around `window.location.reload()` that forceably cleans out the\n// `staleRecords` state associated with the entry at the top of the history\n// stack before reloading.\nexport function reload() {\n  for (const key of Object.keys(staleRecords)) {\n    delete staleRecords[key]\n  }\n  const stateObject = history.state || {}\n  stateObject.staleRecords = staleRecords\n  replaceState(stateObject, '', location.href)\n  window.location.reload()\n}\n\n// Associates the `staleRecords` object, if it contains any entries, with the\n// entry at top of the history stack.\nexport function registerStaleRecords() {\n  if (Object.keys(staleRecords).length > 0) {\n    const stateObject = history.state || {}\n    stateObject.staleRecords = staleRecords\n    replaceState(stateObject, '', location.href)\n  }\n}\n\n// Fetch and replace container with its data-url.\n//\n// This replacement uses conservative checks to safely replace the element.\n// If a user is interacting with any element within the container, the\n// replacement will be aborted.\nexport async function updateContent(el: HTMLElement): Promise<void> {\n  if (pendingRequests.get(el)) return\n\n  const retainFocus = el.hasAttribute('data-retain-focus')\n  const url = el.getAttribute('data-url')\n  if (!url) throw new Error('could not get url')\n  const controller = new AbortController()\n  pendingRequests.set(el, controller)\n\n  try {\n    const response = await fetch(url, {\n      signal: controller.signal,\n      headers: {\n        Accept: 'text/html',\n        'X-Requested-With': 'XMLHttpRequest'\n      }\n    })\n    if (!response.ok) return\n    const data = await response.text()\n    if (hasInteractions(el, retainFocus)) {\n      // eslint-disable-next-line no-console\n      console.warn('Failed to update content with interactions', el)\n      return\n    }\n    staleRecords[url] = data\n    return replace(el, data, retainFocus)\n  } catch {\n    // Ignore failed request.\n  } finally {\n    pendingRequests.delete(el)\n  }\n}\n\n// Abort any in-flight replacements and replace element without any interaction checks.\nexport async function replaceContent(el: HTMLElement, data: string, wasStale = false): Promise<void> {\n  const controller = pendingRequests.get(el)\n  controller?.abort()\n\n  const updatable = el.closest('.js-updatable-content[data-url], .js-updatable-content [data-url]')\n  if (!wasStale && updatable && updatable === el) {\n    staleRecords[updatable.getAttribute('data-url') || ''] = data\n  }\n  return replace(el, data)\n}\n\nfunction replace(el: HTMLElement, data: string, retainFocus = false): Promise<void> {\n  return preserveAnchorNodePosition(document, () => {\n    const newContent = parseHTML(document, data.trim())\n    const elementToRefocus =\n      retainFocus && el.ownerDocument && el === el.ownerDocument.activeElement ? newContent.querySelector('*') : null\n\n    const detailsIds = Array.from(el.querySelectorAll('details[open][id]')).map(element => element.id)\n    if (el.tagName === 'DETAILS' && el.id && el.hasAttribute('open')) detailsIds.push(el.id)\n\n    // Check the elements we are about replace to see if we want to preserve the scroll position of any of them\n    for (const preserveElement of el.querySelectorAll('.js-updatable-content-preserve-scroll-position')) {\n      const id = preserveElement.getAttribute('data-updatable-content-scroll-position-id') || ''\n      heights.set(id, preserveElement.scrollTop)\n    }\n\n    for (const id of detailsIds) {\n      const details = newContent.querySelector(`#${id}`)\n      if (details) details.setAttribute('open', '')\n    }\n\n    el.replaceWith(newContent)\n    if (elementToRefocus instanceof HTMLElement) {\n      elementToRefocus.focus()\n    }\n  })\n}\n\nconst heights = new Map()\nobserve('.js-updatable-content-preserve-scroll-position', {\n  constructor: HTMLElement,\n  add(el) {\n    // When element is added to the DOM, check the map for the last scroll position we have on record for it.\n    const id = el.getAttribute('data-updatable-content-scroll-position-id')\n    if (!id) return\n    const height = heights.get(id)\n    if (height == null) return\n\n    el.scrollTop = height\n  }\n})\n"],"sourceRoot":""}