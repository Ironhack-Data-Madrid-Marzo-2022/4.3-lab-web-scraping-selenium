{"version":3,"sources":["app/assets/modules/github/aria-live.ts","app/assets/modules/github/behaviors/check-all.ts","app/assets/modules/github/perform-transition.ts","app/assets/modules/github/behaviors/details.ts","app/assets/modules/github/filter-list.ts","app/assets/modules/github/filter-sort-list.ts","app/assets/modules/github/substring-memory-filter-list.ts","app/assets/modules/github/behaviors/filterable.ts","app/assets/modules/github/behaviors/flash.ts","app/assets/modules/github/behaviors/hash-change.ts","app/assets/modules/github/behaviors/header.ts","app/assets/modules/github/behaviors/hotkey-map.ts","app/assets/modules/github/capture-keypresses.ts","app/assets/modules/github/behaviors/pjax/capture-keypresses.ts","app/assets/modules/github/behaviors/pjax/history-navigate.ts","app/assets/modules/github/behaviors/pjax/link-prefetch.ts","app/assets/modules/github/behaviors/pjax/utils.ts","app/assets/modules/github/behaviors/smooth-scroll-anchor.ts","app/assets/modules/github/behaviors/sticky.ts","app/assets/modules/github/dimensions.ts","app/assets/modules/github/eventloop-tasks.ts","app/assets/modules/github/iterables.ts","app/assets/modules/github/filter-sort.ts","app/assets/modules/github/fuzzy-filter.ts","app/assets/modules/github/throttled-input.ts","app/assets/modules/github/visible.ts"],"names":[],"mappings":"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","file":"3826-xxxxxxxxxxxx.js","sourcesContent":["import {ready} from './document-ready'\n\nlet container: HTMLElement | null = null\n\n;(async function () {\n  await ready\n  createNoticeContainer()\n})()\n\n// Announce an element's text to the screen reader.\nexport function announceFromElement(el: HTMLElement) {\n  announce(getTextContent(el))\n}\n\n// Announce message update to screen reader.\nexport function announce(message: string) {\n  if (!container) return\n  // Clear content first in case the new notice content is the same as the last\n  container.textContent = ''\n  container.textContent = message\n}\n\n// Get the global screen reader notice container.\nfunction createNoticeContainer() {\n  container = document.createElement('div')\n  container.setAttribute('aria-live', 'polite')\n  container.classList.add('sr-only')\n  document.body.append(container)\n}\n\n// Gets the trimmed text content of an element.\nfunction getTextContent(el: HTMLElement): string {\n  // innerText does not contain hidden text\n  /* eslint-disable-next-line github/no-innerText */\n  return (el.getAttribute('aria-label') || el.innerText || '').trim()\n}\n","// eslint-disable-next-line no-restricted-imports\nimport {observe} from 'selector-observer'\nimport subscribe from '@github/check-all'\n\nobserve('.js-check-all-container', {\n  constructor: HTMLElement,\n  subscribe\n})\n","// performTransition\n//\n// CSS3 transitions have some major pitfalls. First trying to transition\n// elements from `display:none` to `display:block.` And also dealing with\n// computed properties like `height:auto`.\n//\n// This helper attempts to deal with those issues while still defining\n// the transitions in pure css.\n//\n// Behaviors that intend to support these special case transitions\n// should call `performTransition` when they add or remove their state\n// classes.\n//\n// Any element that is performing a transition needs to be annotated\n// with the `js-transitionable` class name.\n//\n// @example\n//\n// <div class=\"js-transitionable collapse\">\n//   Slide down\n// </div>\n//\n// .collapse {\n//   display: none;\n//   position: relative;\n//   height: 0;\n//   overflow: hidden;\n//   @include transition(0.35s, height, ease);\n// }\n// .collapse.open {\n//   display: block;\n//   height: auto;\n// }\n//\n// performTransition document.querySelector('.collapse', () => {\n//   this.classList.add('open')\n// })\n\nconst supportsTransitions = 'ontransitionend' in window\n\n// DEPRECATED: PerformTransition is deprecated.\nexport default function performTransition(container: HTMLElement, cb: () => void) {\n  if (!supportsTransitions) {\n    cb()\n    return\n  }\n\n  const els = Array.from(container.querySelectorAll('.js-transitionable'))\n  if (container.classList.contains('js-transitionable')) els.push(container)\n\n  for (const el of els) {\n    const transitionHeight = isTransitioningHeight(el)\n    if (!(el instanceof HTMLElement)) continue\n\n    el.addEventListener(\n      'transitionend',\n      () => {\n        el.style.display = ''\n        el.style.visibility = ''\n\n        if (transitionHeight) {\n          withoutTransition(el, function () {\n            el.style.height = ''\n          })\n        }\n      },\n      {once: true}\n    )\n\n    el.style.boxSizing = 'content-box'\n    el.style.display = 'block'\n    el.style.visibility = 'visible'\n\n    if (transitionHeight) {\n      withoutTransition(el, function () {\n        el.style.height = getComputedStyle(el).height\n      })\n    }\n\n    // force reflow\n    el.offsetHeight\n  }\n\n  cb()\n\n  for (const el of els) {\n    if (!(el instanceof HTMLElement)) continue\n    if (isTransitioningHeight(el)) {\n      const currentHeight = getComputedStyle(el).height\n      el.style.boxSizing = ''\n      if (currentHeight === '0px') {\n        el.style.height = `${el.scrollHeight}px`\n      } else {\n        el.style.height = '0px'\n      }\n    }\n  }\n}\n\n// Detect if element is transitioning its height property.\nfunction isTransitioningHeight(el: Element) {\n  return getComputedStyle(el).transitionProperty === 'height'\n}\n\n// Apply style change callback w/o triggering a transition.\nfunction withoutTransition(el: HTMLElement, cb: () => void) {\n  el.style.transition = 'none'\n  cb()\n  el.offsetHeight\n  el.style.transition = ''\n}\n","/* eslint eslint-comments/no-use: off */\n/* eslint-disable github/no-then */\n\n/**\n * Details toggle.\n *\n * Use the details toggle to toggle content on the page. Similar to the\n * [HTML5 details element](https://www.w3.org/wiki/HTML/Elements/details).\n *\n * There are minimum two classes you will need to trigger the JS behavior.\n *\n * Apply the `.js-details-target` class to the element that will trigger\n * the toggle through a mouse click. For accessibility reasons, we recommend using a\n * `<button>` tag for this, but it can be applied to any element.\n *\n * A single `.js-details-container` class will be applied to a parent element that is wrapping\n * all the details components. The behavior will toggle an `Details--on` class on this element\n * which the CSS will use to show and hide the appropriate objects.\n *\n * There are default styling classes that will show and hide content for you. `.Details`\n * is a component that is built to show hidden content on open, and hide shown content\n * on close.\n *\n * The default state of the component is closed. Wrap the content and target with the `Details`\n * class. And apply `Details-content--hidden` to any element that you want *hidden* when closed\n * and *shown* when open.\n *\n * @example\n * ```html\n * <div class=\"Details js-details-container\">\n *   <button type=\"button\" class=\"js-details-target\" aria-expanded=\"false\">See more info</button>\n *   <div class=\"Details-content--hidden\">Hidden details</div>\n * </div>\n * ```\n *\n * Shown content\n *\n * If you have some content that you would like to be *shown* by default and\n * *hidden* when the details is `Details--on`. Then you can use the `Details-content--shown`\n * class.\n *\n * @example\n * ```html\n * <div class=\"Details js-details-container\">\n *   <button type=\"button\" class=\"js-details-target\" aria-expanded=\"false\" aria-label=\"Expand and collapse\">\n *     <%= octicon(\"chevron-down\", :class => \"Details-content--shown\") %>\n *     <%= octicon(\"chevron-up\", :class => \"Details-content--hidden\") %>\n *   </button>\n *   <div class=\"Details-content--shown\">Shown details</div>\n * </div>\n * ```\n */\n\nimport hashChange from './hash-change'\n// eslint-disable-next-line no-restricted-imports\nimport {on} from 'delegated-events'\nimport performTransition from '../perform-transition'\nimport {preservePosition} from 'scroll-anchoring'\n\nfunction findAndFocusByQuerySelector(container: HTMLElement, elements: string[]) {\n  elements.find(selector => {\n    const els = container.querySelectorAll<HTMLElement>(selector)\n    const element = els[els.length - 1]\n    if (element && document.activeElement !== element) {\n      element.focus()\n      return true // found\n    }\n  })\n}\n\nfunction restoreAutofocus(container: HTMLElement) {\n  findAndFocusByQuerySelector(container, ['.js-focus-on-dismiss', 'input[autofocus], textarea[autofocus]'])\n}\n\nfunction hideTooltip(target: HTMLElement) {\n  if (!target.classList.contains('tooltipped')) return\n  target.classList.remove('tooltipped')\n  target.addEventListener(\n    'mouseleave',\n    () => {\n      target.classList.add('tooltipped')\n      // eslint-disable-next-line github/no-blur\n      target.blur()\n    },\n    {once: true}\n  )\n}\n\nfunction groupMembers(group: string): Element[] {\n  return [...document.querySelectorAll('.js-details-container')].filter(\n    el => el.getAttribute('data-details-container-group') === group\n  )\n}\n\nfunction containerTargets(container: Element): Element[] {\n  return [...container.querySelectorAll('.js-details-target')].filter(\n    target => target.closest('.js-details-container') === container\n  )\n}\n\nfunction toggleGroup(container: Element, open: boolean): string | null {\n  const group = container.getAttribute('data-details-container-group')\n  if (!group) return null\n  preservePosition(container, () => {\n    for (const otherContainer of groupMembers(group)) {\n      if (otherContainer !== container) {\n        updateOpenState(otherContainer, open)\n      }\n    }\n  })\n  return group\n}\n\nfunction updateOpenState(container: Element, open: boolean) {\n  container.classList.toggle('open', open)\n  container.classList.toggle('Details--on', open)\n  for (const target of containerTargets(container)) {\n    target.setAttribute('aria-expanded', open.toString())\n  }\n}\n\nexport function toggleDetailsTarget(target: HTMLElement, opts?: {withGroup?: boolean; force?: boolean}) {\n  const containerSelector = target.getAttribute('data-details-container') || '.js-details-container'\n  const container = target.closest<HTMLElement>(containerSelector)!\n  const open = opts?.force ?? !container.classList.contains('open')\n  const withGroup = opts?.withGroup ?? false\n  performTransition(container, () => {\n    updateOpenState(container, open)\n    const group = withGroup ? toggleGroup(container, open) : null\n    Promise.resolve().then(() => {\n      restoreAutofocus(container)\n      hideTooltip(target)\n      container.dispatchEvent(\n        new CustomEvent('details:toggled', {\n          bubbles: true,\n          cancelable: false,\n          detail: {open}\n        })\n      )\n      if (group) {\n        container.dispatchEvent(\n          new CustomEvent('details:toggled-group', {\n            bubbles: true,\n            cancelable: false,\n            detail: {open, group}\n          })\n        )\n      }\n    })\n  })\n}\n\nexport function isDetailsTargetExpanded(target: HTMLElement): boolean {\n  const containerSelector = target.getAttribute('data-details-container') || '.js-details-container'\n  const container = target.closest<HTMLElement>(containerSelector)!\n  const classList = container.classList\n  return classList.contains('Details--on') || classList.contains('open')\n}\n\nfunction handleDetailsTargetClick(event: Event) {\n  const withGroup = (event as MouseEvent).altKey\n  const target = event.currentTarget as HTMLElement\n  toggleDetailsTarget(target, {withGroup})\n  event.preventDefault()\n}\non('click', '.js-details-target', handleDetailsTargetClick)\n\n// Expand collapsed outdated diff if anchor points to it\n//   /github/github/pull/123#discussion-diff-456\n//   /github/github/pull/123#discussion-r345\nhashChange(function ({target}) {\n  if (target) ensureExpanded(target)\n})\n\nexport function ensureExpanded(target: Element) {\n  let toCollapse = false\n  let node = target.parentElement\n  while (node) {\n    if (node.classList.contains('Details-content--shown')) {\n      toCollapse = true\n    }\n    if (node.classList.contains('js-details-container')) {\n      node.classList.toggle('open', !toCollapse)\n      node.classList.toggle('Details--on', !toCollapse)\n      toCollapse = false\n    }\n    node = node.parentElement\n  }\n}\n","type Predicate = (el: Element, query: string) => boolean | null\ntype Options = {limit?: number | null}\n\nexport function filterList(list: Element, query: string, isVisible: Predicate, options: Options = {}): number {\n  const limit = options.limit ?? Infinity\n  let visible = 0\n  for (const item of list.children) {\n    const show = isVisible(item, query)\n    if (show == null) {\n      // ignore\n    } else if (show && visible < limit) {\n      visible++\n      toggle(item as HTMLElement, true)\n    } else {\n      toggle(item as HTMLElement, false)\n    }\n  }\n  return visible\n}\n\nfunction toggle(el: HTMLElement, show: boolean) {\n  el.style.display = show ? '' : 'none'\n  el.hidden = !show\n}\n","import type {TextScore} from './fuzzy-filter'\nimport {compare} from './fuzzy-filter'\nimport {filterSort} from './filter-sort'\n\nconst originalOrder = new WeakMap<Element, HTMLElement[]>()\n\ninterface FilterOptions {\n  limit?: number | null\n  sortKey: (item: HTMLElement) => TextScore | null | undefined\n}\n\n// Filters and sorts list element items against a text query. For use with lists that\n// are already in the DOM, not with lists of results that are changed dynamically\n// via ajax.\n//\n// Returns Number of visible items.\nexport function filterSortList(list: Element, string: string, options: FilterOptions): number {\n  const query = string.toLowerCase()\n  const limit = options.limit\n\n  let allItems = originalOrder.get(list)\n  const checkedInputBeforeFilter = list.querySelector('input[type=\"radio\"]:checked')\n  const children = Array.from(list.children)\n  if (!allItems) {\n    allItems = Array.from(list.children) as HTMLElement[]\n    originalOrder.set(list, allItems)\n  }\n  for (const item of children) {\n    list.removeChild(item)\n    if (item instanceof HTMLElement) item.style.display = ''\n  }\n\n  const found = query ? filterSort(allItems, options.sortKey, compare) : allItems\n  const limited = limit == null ? found : found.slice(0, limit)\n  const visible = limited.length\n  const results = document.createDocumentFragment()\n  for (const item of limited) {\n    results.appendChild(item)\n  }\n\n  // This ensures that checked input before and after filtering is the same one\n  // See https://github.com/github/github/issues/88129#issuecomment-434839397\n  let inputStateReset = false\n  if (checkedInputBeforeFilter instanceof HTMLInputElement) {\n    for (const checkedInput of results.querySelectorAll('input[type=\"radio\"]:checked')) {\n      if (checkedInput instanceof HTMLInputElement && checkedInput.value !== checkedInputBeforeFilter.value) {\n        checkedInput.checked = false\n        inputStateReset = true\n      }\n    }\n  }\n\n  list.appendChild(results)\n\n  // Dispatch a change event after render for details-menu or any other code reacting to the input state\n  if (checkedInputBeforeFilter && inputStateReset) {\n    checkedInputBeforeFilter.dispatchEvent(new Event('change', {bubbles: true}))\n  }\n\n  // hide all dividers if query.length > 0\n  const dividers = list.querySelectorAll('.js-divider')\n  for (const divider of dividers) {\n    /* eslint-disable-next-line github/no-d-none */\n    divider.classList.toggle('d-none', Boolean(query && query.trim().length > 0))\n  }\n\n  return visible\n}\n","import verifySsoSession from './sso'\n\ninterface FilterOptions {\n  limit?: number | null\n}\n\n// Only login, name & selected are attributes required on both server side and payload rendered elements.\n// IE if we construct a user element from a .js-filterable-suggested-user HTMLElement.\ninterface User {\n  id?: string\n  type?: string\n  login: string\n  name: string\n  selected: boolean\n  disabled?: boolean\n  element?: HTMLElement\n  description?: string\n  avatar?: string\n  class?: string\n  suggestion?: boolean\n}\n\ninterface Data {\n  suggestions: User[]\n  users: User[]\n}\n\ninterface TypeAheadData {\n  lastSearchResult: Data\n  lastSearchText?: string\n  cachedSuggestions: User[]\n\n  // Used to cache a user ID to a pre-existing rendered element (if they exist in multiple search results).\n  // This is needed to persist their selected state across multiple searches.\n  // Key is user.id (as a string) to the rendered element\n  userResultCache: Map<string, HTMLElement>\n}\n\n// Used to abort any previous type-ahead request if not needed\nlet abortController = new AbortController()\n\nconst typeAheadCache = new WeakMap<Element, TypeAheadData>()\nconst cache = new WeakMap<Element, Data>()\nconst currentQueryForList = new WeakMap<Element, string>()\n\nasync function getData(\n  list: Element,\n  queryText: string,\n  typeAhead: boolean,\n  queryOnEmptyQueryString: boolean\n): Promise<Data> {\n  if (typeAhead && !typeAheadCache.has(list)) {\n    initializeTypeAheadCache(list)\n  }\n\n  const data = await fetchQueryIfNeeded(list, queryText, typeAhead, queryOnEmptyQueryString)\n  const hasPreRenderedData = list.hasAttribute('data-filterable-data-pre-rendered')\n\n  if (hasPreRenderedData) {\n    data.suggestions = getPreRenderedUsers(list, typeAhead)\n  }\n\n  return data\n}\n\nasync function fetchQueryIfNeeded(\n  list: Element,\n  queryText: string,\n  typeAhead: boolean,\n  queryOnEmptyQueryString: boolean\n): Promise<Data> {\n  const url = new URL(list.getAttribute('data-filterable-src') || '', window.location.origin)\n  if (url.pathname === '/') throw new Error('could not get data-filterable-src')\n\n  if (typeAhead) {\n    const typeAheadData = typeAheadCache.get(list)!\n    const trimmedText = queryText.trim()\n    if (typeAheadData.lastSearchText === trimmedText) return typeAheadData.lastSearchResult\n    const isInitialLoad = typeAheadData.lastSearchText === undefined\n    typeAheadData.lastSearchText = trimmedText\n\n    const inputId = list.getAttribute('data-filterable-for') || ''\n    const inputElement = document.getElementById(inputId)\n\n    // Abort any old requests (if any)\n    abortController.abort()\n    if (trimmedText === '' && !queryOnEmptyQueryString) {\n      typeAheadData.lastSearchResult = {suggestions: [], users: []}\n    } else {\n      // Abort controller needs to be re-created, there exists one per abort.\n      abortController = new AbortController()\n      const requestHeaders = {\n        headers: {Accept: 'application/json', 'X-Requested-With': 'XMLHttpRequest'},\n        signal: abortController.signal\n      }\n\n      const params = url.searchParams || new URLSearchParams()\n      params.set('q', queryText)\n      params.set('typeAhead', 'true')\n      url.search = params.toString()\n\n      if (!isInitialLoad) {\n        inputElement?.classList.add('is-loading')\n      }\n\n      const response = await fetch(url.toString(), requestHeaders)\n      typeAheadData.lastSearchResult = await response.json()\n    }\n\n    inputElement?.classList.remove('is-loading')\n    return typeAheadData.lastSearchResult\n  } else {\n    const requestHeaders = {headers: {Accept: 'application/json', 'X-Requested-With': 'XMLHttpRequest'}}\n    const response = await fetch(url.toString(), requestHeaders)\n    return await response.json()\n  }\n}\n\n// This function will try to find any server side rendered users through the tag `.js-filterable-suggested-user`\n// If any are found, they will be added to the API returned data.\n// This users are distinct from the 'suggestions' currently returned through the reviewers API call.\nfunction getPreRenderedUsers(list: Element, typeAhead: boolean): User[] {\n  const data = []\n  // Add all server rendered users to the `suggestions` list (if any).\n  const suggestedUsers = list.querySelectorAll<HTMLElement>('.js-filterable-suggested-user')\n\n  // If the list has been refreshed, or first time loaded, this will be non-zero, and therefore we clear the array and re-add the new items\n  if (suggestedUsers.length > 0) {\n    // Read the server-side rendered elements that need to be added to suggestions.\n    // This is a work-around to allow the server-side rendered elements to work with the filtering.\n    for (const suggestedUser of list.querySelectorAll<HTMLElement>('.js-filterable-suggested-user')) {\n      suggestedUser.classList.remove('js-filterable-suggested-user')\n\n      // Deconstruct the element into a <User> object\n      data.push({\n        name: suggestedUser.querySelector('.js-description')!.textContent!,\n        login: suggestedUser.querySelector('.js-username')!.textContent!,\n        selected: suggestedUser.getAttribute('aria-checked') === 'true',\n        element: suggestedUser,\n        suggestion: true\n      })\n    }\n  }\n\n  // If the list has been refreshed, or first time loaded, this will be non-zero, and therefore we clear the array and re-add the new items\n  if (typeAhead) {\n    const typeAheadData = typeAheadCache.get(list)!\n    if (suggestedUsers.length > 0) {\n      typeAheadData.cachedSuggestions = data\n      typeAheadData.userResultCache.clear()\n    }\n\n    return typeAheadData.cachedSuggestions\n  }\n\n  return data\n}\n\nfunction initializeTypeAheadCache(list: Element) {\n  typeAheadCache.set(list, {\n    lastSearchResult: {suggestions: [], users: []},\n    cachedSuggestions: [],\n    userResultCache: new Map<string, HTMLElement>()\n  })\n}\n\n// This is like `substringFilterList`, but instead of filtering down direct\n// children of a DOM element, obtain most data from a JSON payload and search\n// within that instead, only generating actual DOM elements when they are\n// \"revealed\" by matching the search term. Similarly, remove elements from the\n// DOM when they don't match a search term and they're not selected.\n//\n// Also, because elements might already exist in the DOM because of their\n// pre-selected state, merge those elements with the data coming from JSON.\nexport async function substringMemoryFilterList(\n  list: Element,\n  queryText: string,\n  options: FilterOptions\n): Promise<number> {\n  currentQueryForList.set(list, queryText)\n\n  await verifySsoSession()\n\n  const showSuggestionsHeaderOnLoad = list.hasAttribute('data-filterable-show-suggestion-header')\n  const typeAhead = list.hasAttribute('data-filterable-type-ahead')\n  const queryOnEmptyQueryString = list.hasAttribute('data-filterable-type-ahead-query-on-empty')\n\n  let data = cache.get(list)\n\n  if (!data) {\n    try {\n      data = await getData(list, queryText, typeAhead, queryOnEmptyQueryString)\n      if (!typeAhead) cache.set(list, data)\n    } catch (error) {\n      if (error.name === 'AbortError') {\n        // A stale type-ahead request was aborted\n        return -1\n      } else {\n        throw error\n      }\n    }\n  }\n\n  // This logic only exists when type-ahead is disabled\n  if (!typeAhead && currentQueryForList.get(list) !== queryText) {\n    return -1\n  }\n\n  const limit = options.limit\n  const template = list.querySelector<HTMLTemplateElement>('template')!\n\n  // an index of items already rendered into DOM due to being preselected\n  const existingElements: {[key: string]: HTMLInputElement} = {}\n  for (const existing of list.querySelectorAll<HTMLInputElement>('input[type=hidden]')) {\n    existingElements[`${existing.name}${existing.value}`] = existing\n  }\n\n  // remove all non-selected items after the template element\n  let cutoffPoint = template.nextElementSibling\n  while (cutoffPoint) {\n    const el = cutoffPoint\n    cutoffPoint = el.nextElementSibling\n    if (\n      el instanceof HTMLElement &&\n      (typeAhead || el.getAttribute('aria-checked') === 'true' || el.classList.contains('select-menu-divider'))\n    ) {\n      el.hidden = true\n    } else {\n      el.remove()\n    }\n  }\n\n  let visible = 0\n\n  const queryTextEmpty = queryText.trim() === ''\n  const items = document.createDocumentFragment()\n  const suggestionsDivider = list.querySelector<HTMLElement>('.js-divider-suggestions')\n  const restDivider = list.querySelector<HTMLElement>('.js-divider-rest')\n  const typeAheadData = typeAheadCache.get(list)\n\n  function addItem(user: User) {\n    const containsQueryText = `${user.login} ${user.name}`.toLowerCase().trim().includes(queryText)\n    const matching = !(limit != null && visible >= limit) && containsQueryText\n    const shouldGenerate = matching || user.selected || user.suggestion\n    if (shouldGenerate) {\n      const item = createReviewerItem(user, template, existingElements, typeAheadData)\n      item.hidden = !matching\n      if (matching) visible++\n      items.appendChild(item)\n    }\n  }\n\n  let anyVisibleNonSelectedSuggestions = false\n\n  // We show suggestions header if we\n  // 1) Actually have suggestions, or\n  // 2) If we still want to show suggestions title (declared by the attribute), but don't ever have any suggestions\n  // (ie data.suggestions is undefined), the criteria simply becomes whether or not there is any query text.\n  if (suggestionsDivider && (data.suggestions?.length > 0 || (showSuggestionsHeaderOnLoad && data.users.length > 0))) {\n    const suggestions = data.suggestions ?? []\n    const selectedSuggestions = suggestions.filter(u => u.selected)\n    const nonSelectedSuggestions = suggestions.filter(u => !u.selected)\n\n    for (const u of selectedSuggestions) {\n      addItem(u)\n    }\n\n    // Put the suggestions after the already assigned users\n    items.appendChild(suggestionsDivider)\n    const preSuggestionsVisibleCount = visible\n    for (const u of nonSelectedSuggestions) {\n      addItem(u)\n    }\n    anyVisibleNonSelectedSuggestions = visible > preSuggestionsVisibleCount\n\n    suggestionsDivider.hidden = !anyVisibleNonSelectedSuggestions || (typeAhead && !queryTextEmpty)\n\n    // Special case where we want to force show the suggestions header even without suggestions in the payload.\n    if (showSuggestionsHeaderOnLoad && data.users.length > 0) {\n      suggestionsDivider.hidden = !queryTextEmpty\n    }\n  }\n\n  if (restDivider) {\n    items.appendChild(restDivider)\n  }\n\n  const preUsersVisibleCount = visible\n  for (const u of data.users) {\n    addItem(u)\n  }\n\n  if (restDivider) {\n    restDivider.hidden = preUsersVisibleCount === visible || !anyVisibleNonSelectedSuggestions\n  }\n\n  list.append(items)\n  return visible\n}\n\nfunction createReviewerItem(\n  user: User,\n  template: HTMLTemplateElement,\n  existingElements: Record<string, HTMLElement>,\n  typeAheadData: TypeAheadData | undefined\n): HTMLElement {\n  if (user.element != null) {\n    return user.element\n  }\n\n  if (typeAheadData?.userResultCache.has(user.id!)) {\n    return typeAheadData.userResultCache.get(user.id!)!\n  }\n\n  const li = template.content.cloneNode(true) as HTMLElement\n  const input = li.querySelector<HTMLInputElement>('input[type=checkbox], input[type=radio]')!\n\n  if (user.type) {\n    input.name = `reviewer_${user.type}_ids[]`\n  }\n  input.value = user.id!\n\n  const inputKey = `${input.name}${user.id}`\n  let selected = user.selected\n  if (existingElements[inputKey]) {\n    selected = true\n    existingElements[inputKey].remove()\n    delete existingElements[inputKey]\n  }\n\n  const item = li.querySelector<HTMLElement>('[role^=menuitem]')!\n  if (selected) {\n    item.setAttribute('aria-checked', 'true')\n    input.checked = true\n  }\n\n  if (user.disabled) {\n    item.setAttribute('aria-disabled', 'true')\n  }\n\n  const login = li.querySelector('.js-username')\n  if (login) login.textContent = user.login\n  const fullName = li.querySelector('.js-description')\n  if (fullName) fullName.textContent = user.name\n  const description = li.querySelector('.js-extended-description')\n  if (description) {\n    if (user.description) {\n      description.textContent = user.description\n    } else {\n      description.remove()\n    }\n  }\n  const avatar = li.querySelector<HTMLImageElement>('.js-avatar')!\n  avatar.className = `${avatar.className} ${user.class}`\n  avatar.src = user.avatar!\n\n  user.element = item\n\n  typeAheadData?.userResultCache.set(user.id!, item)\n\n  return user.element\n}\n","// Filterable Behavior\n//\n// Automatically filters and sorts a list of items against a text field.\n//\n// Markup\n//\n// * js-filterable-field  - Set on field to enable filtering.\n// * data-filterable-for  - Set to ID of input field to bind too.\n// * data-filterable-type - Filtering type. Either \"prefix\", \"substring\", or \"fuzzy\". Defaults to \"prefix\"\n//\n// <input id=\"file-filter-field\" class=\"js-filterable-field\" autocomplete=\"off\">\n//\n// <ul data-filterable-for=\"file-filter-field\" data-filterable-type=\"fuzzy\">\n//   <li>Foo</li>\n//   <li>Bar</li>\n//   <li>Baz</li>\n// </ul>\n//\n//\n// Events\n//\n// filterable:change\n//\n// * **Bubbles** Yes\n// * **Cancelable** No\n// * **Target** List container Element\n// * **Context info**\n//   * relatedTarget - Input field Element\n//\n// $('ul').on('filterable:change', function() {\n//   console.log('order changed')\n// })\n//\n\nimport {addThrottledInputEventListener, removeThrottledInputEventListener} from '../throttled-input'\n// eslint-disable-next-line no-restricted-imports\nimport {fire, on} from 'delegated-events'\nimport {announce} from '../aria-live'\nimport {filterList} from '../filter-list'\nimport {filterSortList} from '../filter-sort-list'\nimport {fuzzyScore} from '../fuzzy-filter'\nimport {microtask} from '../eventloop-tasks'\n// eslint-disable-next-line no-restricted-imports\nimport {observe} from 'selector-observer'\nimport {substringMemoryFilterList} from '../substring-memory-filter-list'\n\nobserve('.js-filterable-field', {\n  constructor: HTMLInputElement,\n  initialize(field) {\n    if (!field.autocomplete) {\n      field.autocomplete = 'off'\n    }\n\n    // A null value will default to whatever is specified within `throttled-input.ts`\n    const throttleWaitInMs = field.hasAttribute('type-ahead') ? 200 : null\n    let value = field.value\n\n    async function onInputChange(input: HTMLInputElement | HTMLTextAreaElement) {\n      if (value === input.value) return\n      value = input.value\n      await microtask()\n      fire(input, 'filterable:change')\n    }\n\n    async function onFocus() {\n      value = field.value\n      await microtask()\n      fire(field, 'filterable:change')\n    }\n\n    return {\n      add(el) {\n        el.addEventListener('focus', onFocus)\n        addThrottledInputEventListener(el, onInputChange, {wait: throttleWaitInMs})\n        if (document.activeElement === el) onFocus()\n      },\n      remove(el) {\n        el.removeEventListener('focus', onFocus)\n        removeThrottledInputEventListener(el, onInputChange)\n      }\n    }\n  }\n})\n\n// Trigger 'filterable:change' on an input after any\n// direct val() calls\non('filterable:change', '.js-filterable-field', async function (event: Event) {\n  const target = event.currentTarget as HTMLInputElement\n  const queryString = target.value.trim().toLowerCase()\n  const filterable = document.querySelectorAll(`[data-filterable-for=\"${target.id}\"]`)\n  for (const list of filterable) {\n    const visible = await filter(list, queryString)\n    if (visible === -1) return\n    if (document.activeElement && target === document.activeElement) {\n      announce(`${visible} results found.`)\n    }\n\n    list.dispatchEvent(\n      new CustomEvent('filterable:change', {\n        bubbles: true,\n        cancelable: false,\n        detail: {\n          inputField: target\n        }\n      })\n    )\n  }\n})\n\nfunction defaultText(content: Element): string {\n  return content.hasAttribute('data-filter-value')\n    ? content.getAttribute('data-filter-value')!.toLowerCase().trim()\n    : content.textContent!.toLowerCase().trim()\n}\n\nasync function filter(list: Element, queryString: string): Promise<number> {\n  const limit = parseInt(list.getAttribute('data-filterable-limit')!, 10) || null\n\n  let visible = 0\n  switch (list.getAttribute('data-filterable-type')) {\n    case 'fuzzy': {\n      const searchQuery = queryString.toLowerCase()\n      const sortKey = (item: HTMLElement) => {\n        const text = defaultText(item)\n        const score = fuzzyScore(text, searchQuery)\n        return score > 0 ? {score, text} : null\n      }\n      visible = filterSortList(list, queryString, {limit, sortKey})\n      break\n    }\n    case 'substring':\n      visible = filterList(list, queryString.toLowerCase(), substring, {limit})\n      break\n    case 'substring-memory':\n      visible = await substringMemoryFilterList(list, queryString, {limit})\n      break\n    default:\n      visible = filterList(list, queryString.toLowerCase(), prefix, {limit})\n      break\n  }\n\n  list.classList.toggle('filterable-active', queryString.length > 0)\n  list.classList.toggle('filterable-empty', visible === 0)\n\n  return visible\n}\n\nfunction prefix(el: Element, queryString: string): boolean {\n  return el.textContent!.toLowerCase().trim().startsWith(queryString)\n}\n\n// Does the text of the given element match the given query string?\n//\n// Note: you can add a `data-skip-substring-filter` attribute to exclude an\n// element from substring filtering.\n//\n// Returns Boolean or null, if element cannot be filtered\nfunction substring(el: Element, queryString: string): boolean | null {\n  if (el.hasAttribute('data-skip-substring-filter')) return null\n  if (el.classList.contains('select-menu-no-results')) return null\n  const target = el.querySelector('[data-filterable-item-text]') || el\n  return target.textContent!.toLowerCase().trim().includes(queryString)\n}\n\n// Toggle new create new item form when filter doesn't match any existing items\non('filterable:change', 'details-menu .select-menu-list', function (event) {\n  const list = event.currentTarget\n  const form = list.querySelector('.js-new-item-form')\n\n  if (form) {\n    toggleForm(list, form, event.detail.inputField.value)\n  }\n})\n\nfunction toggleForm(list: Element, form: Element, filterText: string) {\n  const show = filterText.length > 0 && !itemExists(list, filterText)\n  list.classList.toggle('is-showing-new-item-form', show)\n\n  if (!show) return\n\n  form.querySelector<HTMLElement>('.js-new-item-name')!.textContent = filterText\n\n  const item = form.querySelector('.js-new-item-value')\n  if (item instanceof HTMLInputElement || item instanceof HTMLButtonElement) {\n    item.value = filterText\n  }\n}\n\n// Detect if filtered item is already present in the list.\n//\n// container  - filterable list element\n// filterText - String value of filter field\n//\n// Returns true if item already exists, otherwise false.\nfunction itemExists(container: Element, filterText: string): boolean {\n  for (const item of container.querySelectorAll('[data-menu-button-text]')) {\n    const text = (item as HTMLElement).textContent!.toLowerCase().trim()\n    if (text === filterText.toLowerCase()) {\n      return true\n    }\n  }\n  return false\n}\n\n// Hoist empty class to parent for styling.\nobserve('tab-container .select-menu-list .filterable-empty, details-menu .select-menu-list .filterable-empty', {\n  add(el) {\n    const list = el.closest<HTMLElement>('.select-menu-list')!\n    list.classList.add('filterable-empty')\n  },\n  remove(el) {\n    const list = el.closest<HTMLElement>('.select-menu-list')!\n    list.classList.remove('filterable-empty')\n  }\n})\n","// Flash\n//\n// Fades out and removes flash element from the page on close.\n//\n// Markup\n//\n//     <div class=\"flash-messages\">\n//       <div class=\"flash\">\n//         <%= octicon('x', :class => 'flash-close js-flash-close') %>\n//         Flash Message\n//       </div>\n//     </div>\n//\n\n// eslint-disable-next-line no-restricted-imports\nimport {on} from 'delegated-events'\n\non('click', '.js-flash-close', function (event) {\n  const container = event.currentTarget.closest('.flash-messages')\n\n  const flash = event.currentTarget.closest('.flash')\n  flash!.remove()\n\n  if (container && !container.querySelector('.flash')) {\n    container.remove()\n  }\n})\n","// Variant on the native `hashchange` event with extra features:\n//\n// * Guarantees that handlers run on DOMContentLoaded, or immediately if page has\n//   already loaded;\n// * If the anchor references an element by id, the `data.target` property of the\n//   argument passed to handlers will be a reference to that DOM element.\n//\n// Each handler will be invoked with a `data` object containing properties:\n//\n// * `oldURL` - String URL prior to the hash change, or `null` on initial page load;\n// * `newURL` - String URL after hash change, or current page URL;\n// * `target` - DOM element whose id matches the anchor value, or `null`.\n//\n// Examples\n//\n// ```js\n// // Redirect old anchor issue urls\n// hashChange((data) => {\n//   const m = data.newURL.match(/\\/issues#issue\\/(\\d+)$/)\n//   if (m) window.location = data.newURL.replace(/\\/?#issue\\/.+/, \"/#{m[1]}\")\n// })\n//\n// // Ensure that the referenced comment's parent container is visible\n// hashChange((data) => {\n//   const container = data.target && data.target.closest('.js-comments-container')\n//   if (container) container.classList.remove('d-none')\n// })\n// ```\n\nimport {ready} from '../document-ready'\n\nconst handlers: HashChangeListener[] = []\nlet ran = 0\n\ntype HashChangeListener = (opts: {oldURL: string | null; newURL: string; target?: Element | null}) => unknown\n\nexport default function hashChange(handler: HashChangeListener) {\n  ;(async function () {\n    handlers.push(handler)\n    await ready\n    runRemainingHandlers()\n  })()\n}\n\nhashChange.clear = () => {\n  handlers.length = ran = 0\n}\n\nfunction runRemainingHandlers() {\n  const index = ran\n  ran = handlers.length\n  runHandlers(handlers.slice(index), null, window.location.href)\n}\n\nfunction runHandlers(handlersToRun: HashChangeListener[], oldURL: string | null, newURL: string) {\n  const id = window.location.hash.slice(1)\n  const target = id ? document.getElementById(id) : null\n  const data = {oldURL, newURL, target}\n\n  for (const fn of handlersToRun) {\n    fn.call(null, data)\n  }\n}\n\n// Track ieOldURL manually to work around an open IE bug where the hashchange\n// event does not have oldURL or newURL attributes. See\n// https://connect.microsoft.com/IE/feedback/details/828283/implement-hashchangeevent-oldurl-and-newurl\nlet ieOldURL = window.location.href\nwindow.addEventListener('popstate', function () {\n  ieOldURL = window.location.href\n})\n\nwindow.addEventListener('hashchange', function (event) {\n  const newURL = window.location.href\n  try {\n    runHandlers(handlers, event.oldURL || ieOldURL, newURL)\n  } finally {\n    ieOldURL = newURL\n  }\n})\n\nlet pjaxOldURL: string | null = null\ndocument.addEventListener('pjax:start', function () {\n  pjaxOldURL = window.location.href\n})\n\ndocument.addEventListener('pjax:end', function () {\n  runHandlers(handlers, pjaxOldURL, window.location.href)\n})\n","// eslint-disable-next-line no-restricted-imports\nimport {on} from 'delegated-events'\n\non('click', '.js-skip-to-content', function (event) {\n  const startOfContent = document.getElementById('start-of-content')\n  if (startOfContent) {\n    const nextElement = startOfContent.nextElementSibling\n    if (nextElement instanceof HTMLElement) {\n      nextElement.setAttribute('tabindex', '-1')\n      nextElement.setAttribute('data-skipped-to-content', '1')\n      nextElement.focus()\n    }\n  }\n  event.preventDefault()\n})\n\nexport function hasSkippedToContent() {\n  let skippedToContent = false\n  const startOfContent = document.getElementById('start-of-content')\n\n  if (startOfContent) {\n    const nextElement = startOfContent.nextElementSibling\n\n    if (nextElement instanceof HTMLElement) {\n      skippedToContent = nextElement.getAttribute('data-skipped-to-content') === '1'\n\n      if (skippedToContent) {\n        nextElement.removeAttribute('data-skipped-to-content')\n      }\n\n      return skippedToContent\n    }\n  }\n}\n\nconst touchDevice = 'ontouchstart' in document\n\nfunction compatibleDesktop() {\n  return window.innerWidth > 1012\n}\n\nfor (const headerMenu of document.querySelectorAll('.HeaderMenu-details')) {\n  // On desktop and mobile, ensure that other menus are closed when one opens.\n  headerMenu.addEventListener('toggle', onMenuToggle)\n  if (!touchDevice) {\n    // We can't use `mouseenter` because of Safari bug (v12.0.1).\n    headerMenu.addEventListener('mouseover', onMenuHover)\n    headerMenu.addEventListener('mouseleave', onMenuHover)\n    // On desktop, because the menus are automatically closed on hover, disable\n    // manually collapsing menus to prevent accidental interactions.\n\n    // This is currently commented out due to a bug where dropdown links are not clickable. Awaiting a possible work around\n    // headerMenu.addEventListener('click', disableMenuManualClose)\n  }\n}\n\nlet togglingInProgress = false\n\nfunction onMenuToggle(event: Event) {\n  if (togglingInProgress) return\n  togglingInProgress = true\n\n  for (const headerMenu of document.querySelectorAll('.HeaderMenu-details')) {\n    if (headerMenu === event.currentTarget) continue\n    headerMenu.removeAttribute('open')\n  }\n\n  setTimeout(() => (togglingInProgress = false))\n}\n\nfunction onMenuHover(event: Event) {\n  const {currentTarget} = event\n  if (!(currentTarget instanceof HTMLElement) || !compatibleDesktop()) {\n    return\n  }\n  if (event.type === 'mouseover' && event instanceof MouseEvent) {\n    if (\n      event.target instanceof Node &&\n      event.relatedTarget instanceof Node &&\n      currentTarget.contains(event.target) &&\n      !currentTarget.contains(event.relatedTarget)\n    ) {\n      currentTarget.setAttribute('open', '')\n    }\n  } else {\n    currentTarget.removeAttribute('open')\n  }\n}\n","// Hotkey Behavior\n//\n// See https://github.com/github/hotkey\n\nimport {areCharacterKeyShortcutsEnabled, isNonCharacterKeyShortcut} from './keyboard-shortcuts-helper'\nimport {install, uninstall} from '@github/hotkey'\n// eslint-disable-next-line no-restricted-imports\nimport {observe} from 'selector-observer'\n\n// Disable character key shortcuts based on user preference\nobserve('[data-hotkey]', {\n  constructor: HTMLElement,\n  add(element) {\n    if (areCharacterKeyShortcutsEnabled()) {\n      install(element)\n    } else {\n      const shortcut = element.getAttribute('data-hotkey')\n      if (shortcut) {\n        const validShortcuts = filterOutCharacterKeyShortcuts(shortcut)\n        if (validShortcuts.length > 0) {\n          element.setAttribute('data-hotkey', validShortcuts)\n          install(element)\n        }\n      }\n    }\n  },\n  remove(element) {\n    uninstall(element)\n  }\n})\n\n// This function keeps non-character key shortcuts and filters out character key shortcuts.\n// See `isNonCharacterKeyShortcut` for more information.\nexport default function filterOutCharacterKeyShortcuts(string: string) {\n  const shortcuts = string.split(',')\n  return shortcuts\n    .filter((s: string) => {\n      return isNonCharacterKeyShortcut(s)\n    })\n    .join(',')\n}\n","// Create an hidden textarea to capture users input.\n//\n// Useful for catching key input while a page is transitioning.\nexport default function captureKeypresses(document: Document): () => string {\n  const textarea = document.createElement('textarea')\n  textarea.style.position = 'fixed'\n  textarea.style.top = '0'\n  textarea.style.left = '0'\n  textarea.style.opacity = '0'\n\n  document.body.appendChild(textarea)\n\n  textarea.focus()\n\n  return () => {\n    // eslint-disable-next-line github/no-blur\n    textarea.blur()\n    textarea.remove()\n    return textarea.value\n  }\n}\n","import captureKeypresses from '../../capture-keypresses'\nimport {changeValue} from '../../form'\n// eslint-disable-next-line no-restricted-imports\nimport {on} from 'delegated-events'\n\nlet capturing: (() => string | boolean) | null = null\n\non('pjax:click', '.js-pjax-capture-input', function () {\n  capturing = captureKeypresses(document)\n})\n\non('pjax:end', '#js-repo-pjax-container', function () {\n  if (capturing) {\n    const value = capturing()\n    const input = document.querySelector('.js-pjax-restore-captured-input')\n    if (input instanceof HTMLInputElement && value) {\n      changeValue(input, value)\n    }\n    capturing = null\n  }\n})\n","// History back link\n//\n// Links tagged with \"js-pjax-history-navigate\" classname gain the behavior of popping the\n// last item from the browser history stack if the link's href matches the URL of\n// the last history item. This behavior is suitable for links whose purpose it so\n// bring users back to the previous page.\n\nimport {getBackURL, getForwardURL} from '../../history'\n// eslint-disable-next-line no-restricted-imports\nimport {on} from 'delegated-events'\n\non('pjax:click', '.js-pjax-history-navigate', function (event) {\n  if (!(event.currentTarget instanceof HTMLAnchorElement)) return\n  if (event.currentTarget.href === getBackURL()) {\n    history.back()\n    event.detail.relatedEvent.preventDefault()\n    event.preventDefault()\n  } else if (event.currentTarget.href === getForwardURL()) {\n    history.forward()\n    event.detail.relatedEvent.preventDefault()\n    event.preventDefault()\n  }\n})\n","// pjax: <link rel=\"pjax-prefetch\" href=\"/foo/bar/1\">\n//\n// Also see Resource Hints <link rel=prefetch>\n//   https://w3c.github.io/resource-hints/\n\nimport {detectContainer} from './utils'\n// eslint-disable-next-line no-restricted-imports\nimport {observe} from 'selector-observer'\n\nfunction getContainerSelector(container: Element): string {\n  if (container.id) {\n    return `#${container.id}`\n  } else {\n    throw new Error('pjax container has no id')\n  }\n}\n\n// Fetch target as pjax. Returns response without inserting anything.\nfunction pjaxFetch(\n  target: HTMLAnchorElement | HTMLLinkElement,\n  options: {\n    headers?: {[key: string]: string}\n  }\n): Promise<Response> {\n  const container = detectContainer(target)!\n  const contextSelector = getContainerSelector(container)\n\n  const url = new URL(target.href, window.location.origin)\n  const params = new URLSearchParams(url.search.slice(1))\n\n  url.search = params.toString()\n\n  return fetch(url.href, {\n    headers: Object.assign(\n      {\n        Accept: 'text/html',\n        'X-PJAX': 'true',\n        'X-PJAX-Container': contextSelector,\n        'X-Requested-With': 'XMLHttpRequest'\n      },\n      options && options.headers\n    )\n  })\n}\n\nobserve('[data-pjax-container] link[rel=pjax-prefetch]', {\n  constructor: HTMLLinkElement,\n  initialize(link) {\n    pjaxFetch(link, {\n      headers: {Purpose: 'prefetch'}\n    })\n  }\n})\n","export function preserveScrollTo(element: Element) {\n  if (element.getAttribute('data-pjax-preserve-scroll') != null) {\n    return false\n  } else {\n    return 0\n  }\n}\n\nexport function detectContainer(target: Element): Element | null {\n  let el: Element | null = target\n  while (el) {\n    const selector = el.getAttribute('data-pjax')\n    if (selector && selector !== 'true') {\n      return document.querySelector(selector)\n    }\n    el = el.parentElement && el.parentElement.closest('[data-pjax]')\n  }\n\n  return target.closest('[data-pjax-container]')\n}\n","/**\n * Smooth scrolling anchor.\n *\n * Have an in-page anchor link and want the page to smoothly scroll to its destination? Look no further.\n *\n * Apply the `.js-smoothscroll-anchor` on the anchor tag to trigger smooth scrolling.\n *\n * This will override the default behavior of jumping the page to the element targeted by the hash in the `href`\n * and instead smoothly scroll to it. No additional CSS is required.\n *\n * @deprecated Replace this behavior with `scroll-behavior: smooth;`\n *   https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior.\n *\n * @example\n * ```html\n * <a href=\"#some-id\" class=\"js-smoothscroll-anchor\">Scroll to #some-id</a>\n * <div id=\"some-id\" style=\"margin-top: 300px;\">\n *   <h3>Scroll to me</h3>\n * </div>\n * ```\n */\n\nimport {findFragmentTarget} from '../fragment-target'\n// eslint-disable-next-line no-restricted-imports\nimport {on} from 'delegated-events'\n\non('click', '.js-smoothscroll-anchor', function (event) {\n  const anchor = event.currentTarget\n  if (!(anchor instanceof HTMLAnchorElement)) return\n\n  const target = findFragmentTarget(document, anchor.hash)\n  if (!target) return\n\n  target.scrollIntoView({behavior: 'smooth'})\n  event.preventDefault()\n})\n","// `position: sticky` behavior that works with the notification shelf\n//\n// This module provides three pieces of functionality:\n//\n// - A JavaScript polyfill for `position: sticky` for legacy html which hasn't been upgraded to\n//   use `position: sticky` or cannot yet  because the layout doesn't work with `position: sticky`\n// - Augments `position: sticky` elements to add an `.is-stuck` class to elements when they are stuck\n//   requires `.js-position-sticky` to be added to the stuck element\n// - Ensures that any sticky headers that are on the same page as the notifications shelf sit below it\n//   vertically, rather than hidden underneath the shelf\n// - Provides a `.js-notification-shelf-top-offset` class, that will offset the `top` value of the\n//   element it is attached to, to ensure it sits below the notification header if it exists\n//   (see `.gh-header-shadow` for example usage)\n//\n// Usage:\n//\n// Legacy:\n//\n//    <div class=\"js-sticky js-sticky-offset-scroll top-0\">My sticky content</div>\n//\n// Modern:\n//\n//    <div class=\"js-sticky js-position-sticky top-0\" style=\"position: sticky\">My sticky content</div>\n//\n// Aligning another element to sit below the notification shelf\n//\n//    <div class=\"js-notification-shelf-top-offset\" style=\"position: fixed; top: 60px; left: 0; right: 0;\">...</div>\n\nimport {hasSkippedToContent} from './header'\nimport {loaded} from '../document-ready'\n// eslint-disable-next-line no-restricted-imports\nimport {observe} from 'selector-observer'\n\n// Have we set up the handlers already?\nlet listening = false\n\n// The current pixel height of the notification shelf\n// zero if the shelf is not rendered\nlet notificationShelfHeight = 0\n\ninterface StickySet {\n  element: HTMLElement\n  placeholder: HTMLElement | null\n  offsetParent: Element | null\n  top: number\n}\n\nconst stickySets: StickySet[] = []\n\nfunction manageObservers() {\n  if (stickySets.length) {\n    addObservers()\n  } else {\n    removeObservers()\n  }\n}\n\nfunction addObservers() {\n  if (!listening) {\n    /* eslint-disable-next-line github/prefer-observers */\n    window.addEventListener('resize', checkElementsForStickingHandler)\n    /* eslint-disable-next-line github/prefer-observers */\n    document.addEventListener('scroll', checkElementsForStickingHandler)\n    listening = true\n  }\n}\n\nfunction removeObservers() {\n  window.removeEventListener('resize', checkElementsForStickingHandler)\n  document.removeEventListener('scroll', checkElementsForStickingHandler)\n  listening = false\n}\n\nexport function forceStickyRelayout() {\n  checkElementsForSticking(true)\n}\n\nfunction checkElementsForStickingHandler() {\n  checkElementsForSticking()\n}\n\nfunction checkElementsForSticking(force = false) {\n  for (const set of stickySets) {\n    if (set.element.offsetHeight > 0) {\n      // element isn't hidden\n      const {element, placeholder, top} = set\n      const elementBox = element.getBoundingClientRect()\n\n      if (placeholder) {\n        const placeholderBox = placeholder.getBoundingClientRect()\n\n        if (element.classList.contains('is-stuck')) {\n          if (placeholderBox.top > withShelfOffset(element, top)) {\n            unpinSet(set)\n          } else {\n            updatePinnedSet(set)\n          }\n        } else {\n          if (elementBox.top <= withShelfOffset(element, top)) {\n            pinSet(set)\n          } else if (force) {\n            updatePinnedSet(set)\n          }\n        }\n      } else {\n        // Ideally we'd write this more naturally, as:\n        //\n        //      if (elementBox.top <= withShelfOffset(element, top)) {\n        //\n        // however, at some zoom levels (eg. 175% in Chrome v98, but not at 150%\n        // or 200%) `elementBox.top` may evaluate to an imprecise non-integer\n        // value, like 60.000003814697266 instead of the expected 60 pixels,\n        // causing the comparison to incorrectly fail.\n        //\n        // So, we reframe the comparison in terms of a \"fuzz factor\"\n        // corresponding to a small sub-pixel quantity.\n        const fuzzFactor = 0.1\n        if (elementBox.top - withShelfOffset(element, top) < fuzzFactor) {\n          pinSet(set)\n        } else {\n          unpinSet(set)\n        }\n      }\n    }\n  }\n}\n\n// Determine if the browser has support for `position: sticky`.\nfunction browserHasSticky(el: HTMLElement): boolean {\n  const {position} = window.getComputedStyle(el)\n  return /sticky/.test(position)\n}\n\n// Pin an element.\nfunction pinSet({element, placeholder, top}: StickySet) {\n  if (placeholder) {\n    const elementBox = element.getBoundingClientRect()\n\n    setTopImportant(element, withShelfOffset(element, top))\n    element.style.left = `${elementBox.left}px`\n    element.style.width = `${elementBox.width}px`\n    element.style.marginTop = '0'\n    element.style.position = 'fixed'\n    placeholder.style.display = 'block'\n  }\n\n  element.classList.add('is-stuck')\n}\n\n// Unpin an element.\nfunction unpinSet({element, placeholder}: StickySet) {\n  if (placeholder) {\n    element.style.position = 'static'\n    element.style.marginTop = placeholder.style.marginTop\n    placeholder.style.display = 'none'\n  }\n\n  element.classList.remove('is-stuck')\n}\n\nfunction updatePinnedSet({element, placeholder, offsetParent, top}: StickySet) {\n  if (placeholder && !hasSkippedToContent()) {\n    const elementBox = element.getBoundingClientRect()\n    const placeholderBox = placeholder.getBoundingClientRect()\n\n    setTopImportant(element, withShelfOffset(element, top))\n    element.style.left = `${placeholderBox.left}px`\n    element.style.width = `${placeholderBox.width}px`\n\n    // if the bottom of the fixed box overflows it's container, scroll it\n    if (offsetParent) {\n      const parentBox = offsetParent.getBoundingClientRect()\n\n      if (parentBox.bottom < elementBox.height + parseInt(String(top))) {\n        element.style.top = `${parentBox.bottom - elementBox.height}px`\n      }\n    }\n  }\n}\n\nfunction findOrCreatePlaceholder(el: HTMLElement): HTMLElement | null {\n  if (browserHasSticky(el)) {\n    return null\n  }\n\n  const previousElement = el.previousElementSibling as HTMLElement\n  if (previousElement && previousElement.classList.contains('is-placeholder')) {\n    return previousElement\n  }\n\n  const div = document.createElement('div')\n  div.style.visibility = 'hidden'\n  div.style.display = 'none'\n  div.style.height = window.getComputedStyle(el).height\n  div.className = el.className\n  div.classList.remove('js-sticky')\n  div.classList.add('is-placeholder')\n\n  return el.parentNode!.insertBefore(div, el)\n}\n\nfunction createSet(el: HTMLElement) {\n  const placeholder = findOrCreatePlaceholder(el)\n  const oldPosition = window.getComputedStyle(el).position\n\n  el.style.position = 'static' // do this to get offsetParent\n  const offsetParent = el.offsetParent\n\n  // set to fixed so we can read the `top` value from CSS\n  el.style.position = 'fixed'\n\n  const top = getOriginalTop(el)\n  const hash = {\n    element: el,\n    placeholder,\n    offsetParent,\n    top: top === 'auto' ? 0 : parseInt(top || '0')\n  }\n\n  // set back to static\n  el.style.position = oldPosition\n\n  stickySets.push(hash)\n}\n\nfunction removeSet(el: HTMLElement) {\n  const idx = stickySets.map(set => set.element).indexOf(el)\n  stickySets.splice(idx, 1)\n}\n\nasync function initializeSet(el: HTMLElement) {\n  await loaded\n  createSet(el)\n  checkElementsForSticking()\n  manageObservers()\n}\n\nobserve('.js-sticky', {\n  constructor: HTMLElement,\n  add(el) {\n    initializeSet(el)\n  },\n  remove(el) {\n    removeSet(el)\n    manageObservers()\n  }\n})\n\nobserve('.js-notification-top-shelf', {\n  constructor: HTMLElement,\n  add(shelfEl) {\n    initializeNotificationShelf(shelfEl)\n  },\n  remove() {\n    // Some pages have two shelves rendered for differing layouts at responsive\n    // breakpoints, so remove all shelves when any one is removed\n    for (const shelfEl of document.querySelectorAll('.js-notification-top-shelf')) {\n      shelfEl.remove()\n    }\n\n    if (notificationShelfHeight > 0) {\n      notificationShelfHeight = 0\n      updateTopOffsets()\n      forceStickyRelayout()\n    }\n  }\n})\n\n// Update the top value to include the shelf offset if elements are added later.\nobserve('.js-notification-shelf-offset-top, .js-position-sticky', {\n  constructor: HTMLElement,\n  add: updateTopOffset\n})\n\n// Sets the global notificationShelfHeight variable to match a newly rendered shelf\n// if required, so that other sticky headers can adjust their position to match.\nasync function initializeNotificationShelf(shelfEl: HTMLElement) {\n  // don't measure the height of a hidden shelf\n  if (shelfEl.offsetParent === null) return\n  await loaded\n\n  const height = Math.floor(shelfEl.getBoundingClientRect().height)\n  if (height > 0) {\n    notificationShelfHeight = height\n    updateTopOffsets()\n    forceStickyRelayout()\n  }\n}\n\n// Updates the top offset of all js-position-sticky or js-notification-shelf-offset-top\n// elements to include the height of the notification shelf.\n//\n// If the shelf has since been removed, will return `top` to it's original value.\nfunction updateTopOffsets() {\n  for (const el of document.querySelectorAll<HTMLElement>('.js-position-sticky, .js-notification-shelf-offset-top')) {\n    updateTopOffset(el)\n  }\n}\n\n// Updates the top offset to include the notification bar offset.\nfunction updateTopOffset(el: HTMLElement) {\n  if (el.classList.contains('js-notification-top-shelf')) return\n\n  const top = parseInt(getOriginalTop(el)) || 0\n  setTopImportant(el, top + notificationShelfHeight)\n}\n\n// Returns the original-top value if it's been set as a data-attribute, or if not\n// retrieves it from getComputedStyle and caches it.\n//\n// This is required because an element with an already modified top value may be\n// loaded in from the PJAX cache, and without this attribute, we cannot tell if\n// we already added the shelf offset to it's top value or not.\nfunction getOriginalTop(el: HTMLElement): string {\n  const originalTop = el.getAttribute('data-original-top')\n  if (originalTop != null) return originalTop\n\n  const top = window.getComputedStyle(el).top\n  el.setAttribute('data-original-top', top)\n  return top\n}\n\n// Add a pixel offset to a number (e.g an existing top value) to offset it\n// by the current height of the notification shelf.\nfunction withShelfOffset(el: HTMLElement, top: number): number {\n  if (el.classList.contains('js-notification-top-shelf')) return top\n\n  return top + notificationShelfHeight\n}\n\n// Update the top style property of an element with !important.\nfunction setTopImportant(el: HTMLElement, top: number) {\n  el.style.setProperty('top', `${top}px`, 'important')\n}\n","type Dimensions = {\n  top: number\n  left: number\n  bottom: number\n  right: number\n  height?: number\n  width?: number\n}\n\ntype Offset = {\n  top: number\n  left: number\n}\n\n// Returns the current coordinates of the element relative to the document.\nexport function offset(element: HTMLElement): Offset {\n  const rect = element.getBoundingClientRect()\n  return {\n    top: rect.top + window.pageYOffset,\n    left: rect.left + window.pageXOffset\n  }\n}\n\n// Get the closest ancestor element that has a scroll overflow.\n//\n// Will walk up the DOM from the element until it reaches an element with\n// overflow scroll. Basically, an element that can have scroll bars.\nexport function overflowParent(targetElement: HTMLElement): HTMLElement | null | undefined {\n  let element = targetElement\n  const document = element.ownerDocument\n  if (!document) {\n    return\n  }\n\n  if (!element.offsetParent) {\n    return\n  }\n\n  /* eslint-disable-next-line @typescript-eslint/ban-ts-comment */\n  // @ts-ignore\n  const HTMLElement = document.defaultView.HTMLElement\n\n  if (element === document.body) {\n    return\n  }\n\n  while (element !== document.body) {\n    if (element.parentElement instanceof HTMLElement) {\n      element = element.parentElement!\n    } else {\n      return\n    }\n\n    const {position, overflowY, overflowX} = getComputedStyle(element)\n    if (\n      position === 'fixed' ||\n      overflowY === 'auto' ||\n      overflowX === 'auto' ||\n      overflowY === 'scroll' ||\n      overflowX === 'scroll'\n    ) {\n      break\n    }\n  }\n\n  return element instanceof Document ? null : element\n}\n\n// Returns overflow/scroll offset relative to the container.\n//\n// Get element overflow offset.\n//\n// This value is useful for figuring out if the element is outside the\n// scrollbars of the container. If `top` is negative, the top of the\n// element is above the scroll view. If `bottom` is negative, the\n// bottom of the element is below the scroll view.\n//\n// +--------------------+.\n// | (outside viewport) |\n// +--------------------+ -|\n// |          |         |  |\n// |    top > |         |  |\n// |          |         |  | h\n// |          |         |  | e\n// |  v left  V right v |  | i\n// |-----> Element <----|  | g\n// |          ^         |  | h\n// |          |         |  | t\n// | bottom > |         |  |\n// |          |         |  |\n// +--------------------+ -|\n// | (outside viewport) |\n// +--------------------+.\n//\n// //=> {top: 100, left: 100, bottom: 800, right: 800, height: 1000, width 1000}.\nexport function overflowOffset(\n  element: HTMLElement,\n  targetContainer: Document | HTMLElement | null\n): Dimensions | undefined {\n  let container = targetContainer\n  const document = element.ownerDocument\n  if (!document) {\n    return\n  }\n\n  const documentElement = document.documentElement\n  if (!documentElement) {\n    return\n  }\n\n  if (element === documentElement) {\n    return\n  }\n\n  const elementOffset = positionedOffset(element, container)\n  if (!elementOffset) {\n    return\n  }\n\n  container = elementOffset._container\n\n  const scroll =\n    container === document.documentElement && document.defaultView\n      ? {\n          top: document.defaultView.pageYOffset,\n          left: document.defaultView.pageXOffset\n        }\n      : {\n          top: container.scrollTop,\n          left: container.scrollLeft\n        }\n\n  const top = elementOffset.top - scroll.top\n  const left = elementOffset.left - scroll.left\n  const height = container.clientHeight\n  const width = container.clientWidth\n  const bottom = height - (top + element.offsetHeight)\n  const right = width - (left + element.offsetWidth)\n  return {top, left, bottom, right, height, width}\n}\n\n// Returns position offset relative to the container.\n//\n// Measures the number of pixels from the top of the container to the\n// top of the element and the number of pixels from the bottom of the\n// containers full scroll height to the bottom of the element. If\n// container is `body`, this is the same as $(element).offset().\n//\n//     +---------------------+ -|\n//     |  outside | viewport |  |\n//     +----------|----------+  |\n//     |          |          |  |\n//     |    top > |          |  |\n//     |          |          |  | h\n//     |          |          |  | e\n//     |  v left  V right v  |  | i\n//     |-----> Element <-----|  | g\n//     |          ^          |  | h\n//     |          |          |  | t\n//     | bottom > |          |  |\n//     |          |          |  |\n//     +----------|----------+  |\n//     |  outside | viewport |  |\n//     +---------------------+ -|\n//\n//   {top: 100, left: 100, bottom: 800, right: 800}.\n//\n// Get element positioned offset.\n//\n// This value is useful for assigning to `scrollTop` to scroll to the item.\nexport function positionedOffset(\n  targetElement: HTMLElement,\n  container: HTMLElement | Document | Window | null\n): (Dimensions & {_container: HTMLElement}) | undefined {\n  let element = targetElement\n  const document = element.ownerDocument\n  if (!document) {\n    return\n  }\n\n  const documentElement = document.documentElement\n  if (!documentElement) {\n    return\n  }\n\n  /* eslint-disable-next-line @typescript-eslint/ban-ts-comment */\n  // @ts-ignore\n  const HTMLElement = document.defaultView.HTMLElement\n\n  let top = 0\n  let left = 0\n  const height = element.offsetHeight\n  const width = element.offsetWidth\n\n  while (!(element === document.body || element === container)) {\n    top += element.offsetTop || 0\n    left += element.offsetLeft || 0\n\n    if (element.offsetParent instanceof HTMLElement) {\n      element = element.offsetParent!\n    } else {\n      return\n    }\n  }\n\n  let scrollHeight\n  let scrollWidth\n  let measuredContainer: HTMLElement\n\n  if (\n    !container ||\n    container === document ||\n    container === document.defaultView ||\n    container === document.documentElement ||\n    container === document.body\n  ) {\n    measuredContainer = documentElement\n    scrollHeight = getDocumentHeight(document.body, documentElement)\n    scrollWidth = getDocumentWidth(document.body, documentElement)\n  } else if (container instanceof HTMLElement) {\n    measuredContainer = container\n    scrollHeight = container.scrollHeight\n    scrollWidth = container.scrollWidth\n  } else {\n    return\n  }\n\n  const bottom = scrollHeight - (top + height)\n  const right = scrollWidth - (left + width)\n  return {top, left, bottom, right, _container: measuredContainer}\n}\n\nfunction getDocumentHeight(documentBody: HTMLElement, documentElement: HTMLElement): number {\n  return Math.max(\n    documentBody.scrollHeight,\n    documentElement.scrollHeight,\n    documentBody.offsetHeight,\n    documentElement.offsetHeight,\n    documentElement.clientHeight\n  )\n}\n\nfunction getDocumentWidth(documentBody: HTMLElement, documentElement: HTMLElement): number {\n  return Math.max(\n    documentBody.scrollWidth,\n    documentElement.scrollWidth,\n    documentBody.offsetWidth,\n    documentElement.offsetWidth,\n    documentElement.clientWidth\n  )\n}\n","// This is a simple function that just returns Promise.resolve() It is used in instances when we want to queue a\n// microtask before moving onto the next operation, but want to do so in a very explicit manner: `await microtask`\n// looks a lot clearer in intent than `await void 0` or `await Promise.resolve()`.\n//\n// You would want to use `await microtask()` if you have something that needs to be done very urgently, but still\n// needs to be done asynchronously. This will _not_ yield to the browser for any UI updates or wait for idle, instead\n// it queues a task in the \"microtask\" which is run immediately after the current stack. Use this sparingly. This\n// will likely delay subsequent code for 0-10ms.\nexport function microtask(): Promise<void> {\n  return Promise.resolve()\n}\n\n// This function simply Promisifies requestAnimationFrame so it is awaitable.\n//\n// You would want to use `await animationFrame()` if you're happy to yield to the browser to complete any UI updates\n// before calling your next piece of code. This is useful if - for example - you need to wait for scroll events,\n// or CSS transitions or something. This will likely delay subsequent code for 16ms or so - much longer (30-60ms)\n// if the tab is not focussed.\nexport function animationFrame(): Promise<number> {\n  return new Promise(window.requestAnimationFrame)\n}\n\n// Rejects a promise after a timeout has elapsed. The promise is never\n// successfully fulfilled.\n//\n// Examples\n//\n//   try {\n//     const value = await Promise.race([timeout(100), somethingSlow()])\n//     console.log('Slow operation finished within the timeout', value)\n//   } catch (e) {\n//     console.log('Slow operation did not finish', e)\n//   }\n//\n// Returns a rejected Promise rejected after a timeout.\nexport async function timeout(ms: number, signal?: AbortSignal): Promise<void> {\n  let id\n  const done = new Promise<void>((resolve, reject) => {\n    id = self.setTimeout(() => reject(new Error('timeout')), ms)\n  })\n  if (!signal) return done\n  try {\n    await Promise.race([done, whenAborted(signal)])\n  } catch (e) {\n    self.clearTimeout(id)\n    throw e\n  }\n}\n\n// Fulfills a promise after a timeout has elapsed. The promise is never rejected.\n//\n// Examples\n//\n//   step1()\n//   await wait(100)\n//   step2()\n//\n// Returns a Promise fulfilled after a timeout.\nexport async function wait(ms: number, signal?: AbortSignal): Promise<void> {\n  let id\n  const done = new Promise<void>(resolve => {\n    id = self.setTimeout(resolve, ms)\n  })\n  if (!signal) return done\n  try {\n    await Promise.race([done, whenAborted(signal)])\n  } catch (e) {\n    self.clearTimeout(id)\n    throw e\n  }\n}\n\nfunction whenAborted(signal: AbortSignal): Promise<never> {\n  return new Promise((resolve, reject) => {\n    const error = new Error('aborted')\n    error.name = 'AbortError'\n    if (signal.aborted) {\n      reject(error)\n    } else {\n      signal.addEventListener('abort', () => reject(error))\n    }\n  })\n}\n\nexport function taskQueue<T>(fn: (values: T[]) => unknown): (value: T) => void {\n  const queue: T[] = []\n  return function (value: T) {\n    queue.push(value)\n    if (queue.length === 1) {\n      queueMicrotask(() => {\n        const values = [...queue]\n        queue.length = 0\n        fn(values)\n      })\n    }\n  }\n}\n","export function* filterMap<T, U>(items: T[], map: (item: T) => U | null | undefined): Iterable<U> {\n  for (const item of items) {\n    const value = map(item)\n    if (value != null) {\n      yield value\n    }\n  }\n}\n","import {filterMap} from './iterables'\n\ntype Comparator<T> = (a: T, b: T) => number\n\nexport function filterSort<T, K>(items: T[], map: (item: T) => K | null | undefined, compare: Comparator<K>): T[] {\n  const sortKey = (item: T): [T, K] | null => {\n    const key = map(item)\n    return key != null ? [item, key] : null\n  }\n  return [...filterMap(items, sortKey)].sort((a, b) => compare(a[1], b[1])).map(([item]) => item)\n}\n","// Example\n// ```js\n//     fuzzyScore(\"foo.html\", \"foo\")\n//     // => 0.6458333333333334\n// ```\n//\n// ```js\n//     // Compute re once\n//     re = fuzzyRegexp(\"foo\")\n//     fuzzyScore(\"foo.html\", re)\n//     fuzzyScore(\"bar.html\", re)\n//     // => 0.6458333333333334\n// ```\n//\n// Returns a number between 0 and 1. 0 being the worst match and 1\n// being an exact match.\nexport function fuzzyScore(string: string, query: string): number {\n  let score = stringScore(string, query)\n  if (score && query.indexOf('/') === -1) {\n    const basename = string.substring(string.lastIndexOf('/') + 1)\n    score += stringScore(basename, query)\n  }\n  return score\n}\n\n// Create a regexp that can be used to fuzzy match a given string. Any\n// special regexp characters in the input string will be escaped\n// correctly.\n//\n// A query of \"bar\" becomes /(.*)(b)([^a]*?)(a)([^r]*?)(r)(.*?)/.\n//\n// /\n//  (.*)     whatever's before the first b\n//  (b)      grab the first b of bar\n//  ([^a]*?) take everything up to the a of bar\n//  (a)      take the a of bar\n//  ([^r]*?) take everything up to the r of bar\n//  (r)      take the r of bar\n//  (.*?)    take the rest of the string\n// /\nexport function fuzzyRegexp(query: string): RegExp {\n  const chars = query.toLowerCase().split('')\n\n  let regex = ''\n\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i]\n    // must escape these chars so we match literals\n    const c = char.replace(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n    if (i === 0) {\n      // for the first we want to greedily match anything, which pushes\n      // the first match as late as possible in the string\n      regex += `(.*)(${c})`\n    } else {\n      regex += `([^${c}]*?)(${c})`\n    }\n  }\n  return new RegExp(`${regex}(.*?)$`, 'i')\n}\n\nexport function fuzzyHighlightElement(content: Element, text?: string, textRe?: RegExp): void {\n  if (text) {\n    const matches = content.innerHTML.trim().match(textRe || fuzzyRegexp(text))\n    if (!matches) return\n\n    let open = false\n    const html = []\n    for (let i = 1; i < matches.length; ++i) {\n      const m = matches[i]\n      if (!m) continue\n\n      if (i % 2 === 0) {\n        if (!open) {\n          // eslint-disable-next-line github/unescaped-html-literal\n          html.push('<mark>')\n          open = true\n        }\n      } else if (open) {\n        html.push('</mark>')\n        open = false\n      }\n      html.push(m)\n    }\n    content.innerHTML = html.join('')\n  } else {\n    const html = content.innerHTML.trim()\n    const clean = html.replace(/<\\/?mark>/g, '')\n    if (html !== clean) {\n      content.innerHTML = clean\n    }\n  }\n}\n\n// string_score.js: Quicksilver-like string scoring algorithm.\n//  https://raw.github.com/joshaven/string_score/master/coffee/string_score.coffee\n//\n// Copyright (C) 2009-2011 Joshaven Potter <yourtech@gmail.com>\n// Copyright (C) 2010-2011 Yesudeep Mangalapilly <yesudeep@gmail.com>\n// MIT license: http://www.opensource.org/licenses/mit-license.php\n//\n// A string score implementation.\nfunction stringScore(originalString: string, abbreviation: string): number {\n  let string = originalString\n  if (string === abbreviation) {\n    return 1.0\n  }\n  const stringLength = string.length\n  let totalCharacterScore = 0.0\n  let shouldAwardCommonPrefixBonus = 0\n  for (let i = 0; i < abbreviation.length; i++) {\n    const c = abbreviation[i]\n    const indexCLowercase = string.indexOf(c.toLowerCase())\n    const indexCUppercase = string.indexOf(c.toUpperCase())\n    const minIndex = Math.min(indexCLowercase, indexCUppercase)\n    const indexInString = minIndex > -1 ? minIndex : Math.max(indexCLowercase, indexCUppercase)\n    if (indexInString === -1) {\n      return 0.0\n    }\n    totalCharacterScore += 0.1\n    if (string[indexInString] === c) {\n      totalCharacterScore += 0.1\n    }\n    if (indexInString === 0) {\n      totalCharacterScore += 0.8\n      if (i === 0) {\n        shouldAwardCommonPrefixBonus = 1\n      }\n    }\n    if (string.charAt(indexInString - 1) === ' ') {\n      totalCharacterScore += 0.8\n    }\n    string = string.substring(indexInString + 1, stringLength)\n  }\n  const abbreviationLength = abbreviation.length\n  const abbreviationScore = totalCharacterScore / abbreviationLength\n  let finalScore = (abbreviationScore * (abbreviationLength / stringLength) + abbreviationScore) / 2\n  if (shouldAwardCommonPrefixBonus && finalScore + 0.1 < 1) {\n    finalScore += 0.1\n  }\n  return finalScore\n}\n\nexport type TextScore = {score: number; text: string}\nexport function compare(a: TextScore, b: TextScore): -1 | 0 | 1 {\n  if (a.score > b.score) {\n    return -1\n  } else if (a.score < b.score) {\n    return 1\n  } else if (a.text < b.text) {\n    return -1\n  } else if (a.text > b.text) {\n    return 1\n  } else {\n    return 0\n  }\n}\n","type TextField = HTMLInputElement | HTMLTextAreaElement\n\n/**\n * Throttled Input event.\n *\n * Delays firing `input` event until user is done typing.\n *\n * Details.\n *\n * Never fires while a key is down, waits for the next keyup.\n *   NOTE: Native OSX text fields won't repeat keys. FF will repeat key while held down.\n *\n * Never fires for selection changes (pressing left or right keys to move the cursor).\n */\n\nconst throttledInputEvents: WeakMap<\n  HTMLElement,\n  {\n    keypressed: boolean\n    inputed: boolean\n    timer: number | null | undefined\n    listener: ThrottledHandler\n    wait: number\n  }\n> = new WeakMap()\n\nfunction schedule(element: TextField) {\n  const events = throttledInputEvents.get(element)\n  if (!events) return\n  if (events.timer != null) clearTimeout(events.timer)\n\n  events.timer = window.setTimeout(() => {\n    if (events.timer != null) events.timer = null\n    events.inputed = false\n    events.listener.call(null, element)\n  }, events.wait)\n}\n\nfunction onKeydownInput(event: Event) {\n  const currentTarget = event.currentTarget as TextField\n  const events = throttledInputEvents.get(currentTarget)\n  if (!events) return\n  events.keypressed = true\n  if (events.timer != null) {\n    clearTimeout(events.timer)\n  }\n}\n\nfunction onKeyupInput(event: Event) {\n  const currentTarget = event.currentTarget as TextField\n  const events = throttledInputEvents.get(currentTarget)\n  if (!events) return\n  events.keypressed = false\n  if (events.inputed) {\n    schedule(currentTarget)\n  }\n}\n\nfunction onInputInput(event: Event) {\n  const currentTarget = event.currentTarget as TextField\n  const events = throttledInputEvents.get(currentTarget)\n  if (!events) return\n  events.inputed = true\n  if (!events.keypressed) {\n    schedule(currentTarget)\n  }\n}\n\ntype ThrottledHandler = (arg0: TextField) => unknown\n\nexport function addThrottledInputEventListener(\n  target: TextField,\n  listener: ThrottledHandler,\n  options: {wait: number | null} = {wait: null}\n) {\n  throttledInputEvents.set(target, {\n    keypressed: false,\n    inputed: false,\n    timer: undefined,\n    listener,\n    wait: options.wait != null ? options.wait : 100\n  })\n\n  target.addEventListener('keydown', onKeydownInput)\n  target.addEventListener('keyup', onKeyupInput)\n  target.addEventListener('input', onInputInput)\n}\n\nexport function removeThrottledInputEventListener(target: TextField, listener: ThrottledHandler) {\n  target.removeEventListener('keydown', onKeydownInput)\n  target.removeEventListener('keyup', onKeyupInput)\n  target.removeEventListener('input', onInputInput)\n\n  const events = throttledInputEvents.get(target)\n  if (events) {\n    if (events.timer != null && events.listener === listener) {\n      clearTimeout(events.timer)\n    }\n    throttledInputEvents.delete(target)\n  }\n}\n\nexport function dispatchThrottledInputEvent(target: TextField) {\n  const events = throttledInputEvents.get(target)\n  if (events) events.listener.call(null, target)\n}\n","// Due to the way `visible` is implemented, it causes the browser to\n// perform a full page reflow, it lays out all elements again, when called. This\n// is one of the most time consuming operations the browser can perform, so it\n// affects perceived page load times.\n//\n// The preferred way to determine element visibility is check for the presence\n// of the `hidden` attribute: `if (el.hidden) ...` and `el.hidden = false`.\n//\n// More info: https://github.com/github/eslint-plugin-github/blob/master/docs/rules/no-d-none.md.\n//\n// We would ideally like to remove the `visible` function and consistently\n// use the `hidden` attribute.\n//\n// Returns true if the element is hidden.\nfunction hidden(element: HTMLElement): boolean {\n  return element.offsetWidth <= 0 && element.offsetHeight <= 0\n}\n\nexport default function visible(element: HTMLElement): boolean {\n  return !hidden(element)\n}\n"],"sourceRoot":""}